{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar vanilla = require('valtio/vanilla');\nfunction subscribeKey(proxyObject, key, callback, notifyInSync) {\n  return vanilla.subscribe(proxyObject, function (ops) {\n    if (ops.some(function (op) {\n      return op[1][0] === key;\n    })) {\n      callback(proxyObject[key]);\n    }\n  }, notifyInSync);\n}\nvar currentCleanups;\nfunction watch(callback, options) {\n  var alive = true;\n  var cleanups = new Set();\n  var subscriptions = new Map();\n  var cleanup = function cleanup() {\n    if (alive) {\n      alive = false;\n      cleanups.forEach(function (clean) {\n        return clean();\n      });\n      cleanups.clear();\n      subscriptions.forEach(function (unsubscribe) {\n        return unsubscribe();\n      });\n      subscriptions.clear();\n    }\n  };\n  var revalidate = function revalidate() {\n    if (!alive) {\n      return;\n    }\n    cleanups.forEach(function (clean) {\n      return clean();\n    });\n    cleanups.clear();\n    var proxiesToSubscribe = new Set();\n    var parent = currentCleanups;\n    currentCleanups = cleanups;\n    try {\n      var cleanupReturn = callback(function (proxyObject) {\n        proxiesToSubscribe.add(proxyObject);\n        return proxyObject;\n      });\n      if (cleanupReturn) {\n        cleanups.add(cleanupReturn);\n      }\n    } finally {\n      currentCleanups = parent;\n    }\n    subscriptions.forEach(function (unsubscribe, proxyObject) {\n      if (proxiesToSubscribe.has(proxyObject)) {\n        proxiesToSubscribe.delete(proxyObject);\n      } else {\n        subscriptions.delete(proxyObject);\n        unsubscribe();\n      }\n    });\n    proxiesToSubscribe.forEach(function (proxyObject) {\n      var unsubscribe = vanilla.subscribe(proxyObject, revalidate, options == null ? void 0 : options.sync);\n      subscriptions.set(proxyObject, unsubscribe);\n    });\n  };\n  if (currentCleanups) {\n    currentCleanups.add(cleanup);\n  }\n  revalidate();\n  return cleanup;\n}\nvar DEVTOOLS = Symbol();\nfunction devtools(proxyObject, options) {\n  if (typeof options === 'string') {\n    console.warn('[Deprecated] Please use option object instead of name string');\n    options = {\n      name: options\n    };\n  }\n  var _ref = options || {},\n    enabled = _ref.enabled,\n    _ref$name = _ref.name,\n    name = _ref$name === void 0 ? '' : _ref$name;\n  var extension;\n  try {\n    extension = (enabled != null ? enabled : process.env.NODE_ENV !== \"production\") && window.__REDUX_DEVTOOLS_EXTENSION__;\n  } catch (_unused) {}\n  if (!extension) {\n    if (process.env.NODE_ENV !== \"production\" && enabled) {\n      console.warn('[Warning] Please install/enable Redux devtools extension');\n    }\n    return;\n  }\n  var isTimeTraveling = false;\n  var devtools = extension.connect({\n    name: name\n  });\n  var unsub1 = vanilla.subscribe(proxyObject, function (ops) {\n    var action = ops.filter(function (_ref2) {\n      _ref2[0];\n      var path = _ref2[1];\n      return path[0] !== DEVTOOLS;\n    }).map(function (_ref3) {\n      var op = _ref3[0],\n        path = _ref3[1];\n      return op + \":\" + path.map(String).join('.');\n    }).join(', ');\n    if (!action) {\n      return;\n    }\n    if (isTimeTraveling) {\n      isTimeTraveling = false;\n    } else {\n      var snapWithoutDevtools = Object.assign({}, vanilla.snapshot(proxyObject));\n      delete snapWithoutDevtools[DEVTOOLS];\n      devtools.send({\n        type: action,\n        updatedAt: new Date().toLocaleString()\n      }, snapWithoutDevtools);\n    }\n  });\n  var unsub2 = devtools.subscribe(function (message) {\n    var _message$payload3, _message$payload4;\n    if (message.type === 'ACTION' && message.payload) {\n      try {\n        Object.assign(proxyObject, JSON.parse(message.payload));\n      } catch (e) {\n        console.error('please dispatch a serializable value that JSON.parse() and proxy() support\\n', e);\n      }\n    }\n    if (message.type === 'DISPATCH' && message.state) {\n      var _message$payload, _message$payload2;\n      if (((_message$payload = message.payload) == null ? void 0 : _message$payload.type) === 'JUMP_TO_ACTION' || ((_message$payload2 = message.payload) == null ? void 0 : _message$payload2.type) === 'JUMP_TO_STATE') {\n        isTimeTraveling = true;\n        var state = JSON.parse(message.state);\n        Object.assign(proxyObject, state);\n      }\n      proxyObject[DEVTOOLS] = message;\n    } else if (message.type === 'DISPATCH' && ((_message$payload3 = message.payload) == null ? void 0 : _message$payload3.type) === 'COMMIT') {\n      devtools.init(vanilla.snapshot(proxyObject));\n    } else if (message.type === 'DISPATCH' && ((_message$payload4 = message.payload) == null ? void 0 : _message$payload4.type) === 'IMPORT_STATE') {\n      var _message$payload$next, _message$payload$next2;\n      var actions = (_message$payload$next = message.payload.nextLiftedState) == null ? void 0 : _message$payload$next.actionsById;\n      var computedStates = ((_message$payload$next2 = message.payload.nextLiftedState) == null ? void 0 : _message$payload$next2.computedStates) || [];\n      isTimeTraveling = true;\n      computedStates.forEach(function (_ref4, index) {\n        var state = _ref4.state;\n        var action = actions[index] || 'No action found';\n        Object.assign(proxyObject, state);\n        if (index === 0) {\n          devtools.init(vanilla.snapshot(proxyObject));\n        } else {\n          devtools.send(action, vanilla.snapshot(proxyObject));\n        }\n      });\n    }\n  });\n  devtools.init(vanilla.snapshot(proxyObject));\n  return function () {\n    unsub1();\n    unsub2 == null ? void 0 : unsub2();\n  };\n}\nvar sourceObjectMap = new WeakMap();\nvar derivedObjectMap = new WeakMap();\nvar markPending = function markPending(sourceObject, callback) {\n  var sourceObjectEntry = sourceObjectMap.get(sourceObject);\n  if (sourceObjectEntry) {\n    sourceObjectEntry[0].forEach(function (subscription) {\n      var derivedObject = subscription.d;\n      if (sourceObject !== derivedObject) {\n        markPending(derivedObject);\n      }\n    });\n    ++sourceObjectEntry[2];\n    if (callback) {\n      sourceObjectEntry[3].add(callback);\n    }\n  }\n};\nvar checkPending = function checkPending(sourceObject, callback) {\n  var sourceObjectEntry = sourceObjectMap.get(sourceObject);\n  if (sourceObjectEntry != null && sourceObjectEntry[2]) {\n    sourceObjectEntry[3].add(callback);\n    return true;\n  }\n  return false;\n};\nvar unmarkPending = function unmarkPending(sourceObject) {\n  var sourceObjectEntry = sourceObjectMap.get(sourceObject);\n  if (sourceObjectEntry) {\n    --sourceObjectEntry[2];\n    if (!sourceObjectEntry[2]) {\n      sourceObjectEntry[3].forEach(function (callback) {\n        return callback();\n      });\n      sourceObjectEntry[3].clear();\n    }\n    sourceObjectEntry[0].forEach(function (subscription) {\n      var derivedObject = subscription.d;\n      if (sourceObject !== derivedObject) {\n        unmarkPending(derivedObject);\n      }\n    });\n  }\n};\nvar addSubscription = function addSubscription(subscription) {\n  var sourceObject = subscription.s,\n    derivedObject = subscription.d;\n  var derivedObjectEntry = derivedObjectMap.get(derivedObject);\n  if (!derivedObjectEntry) {\n    derivedObjectEntry = [new Set()];\n    derivedObjectMap.set(subscription.d, derivedObjectEntry);\n  }\n  derivedObjectEntry[0].add(subscription);\n  var sourceObjectEntry = sourceObjectMap.get(sourceObject);\n  if (!sourceObjectEntry) {\n    var _subscriptions = new Set();\n    var _unsubscribe = vanilla.subscribe(sourceObject, function (ops) {\n      _subscriptions.forEach(function (subscription) {\n        var derivedObject = subscription.d,\n          callback = subscription.c,\n          notifyInSync = subscription.n,\n          ignoreKeys = subscription.i;\n        if (sourceObject === derivedObject && ops.every(function (op) {\n          return op[1].length === 1 && ignoreKeys.includes(op[1][0]);\n        })) {\n          return;\n        }\n        if (subscription.p) {\n          return;\n        }\n        markPending(sourceObject, callback);\n        if (notifyInSync) {\n          unmarkPending(sourceObject);\n        } else {\n          subscription.p = Promise.resolve().then(function () {\n            delete subscription.p;\n            unmarkPending(sourceObject);\n          });\n        }\n      });\n    }, true);\n    sourceObjectEntry = [_subscriptions, _unsubscribe, 0, new Set()];\n    sourceObjectMap.set(sourceObject, sourceObjectEntry);\n  }\n  sourceObjectEntry[0].add(subscription);\n};\nvar removeSubscription = function removeSubscription(subscription) {\n  var sourceObject = subscription.s,\n    derivedObject = subscription.d;\n  var derivedObjectEntry = derivedObjectMap.get(derivedObject);\n  derivedObjectEntry == null ? void 0 : derivedObjectEntry[0].delete(subscription);\n  if ((derivedObjectEntry == null ? void 0 : derivedObjectEntry[0].size) === 0) {\n    derivedObjectMap.delete(derivedObject);\n  }\n  var sourceObjectEntry = sourceObjectMap.get(sourceObject);\n  if (sourceObjectEntry) {\n    var _subscriptions2 = sourceObjectEntry[0],\n      _unsubscribe2 = sourceObjectEntry[1];\n    _subscriptions2.delete(subscription);\n    if (!_subscriptions2.size) {\n      _unsubscribe2();\n      sourceObjectMap.delete(sourceObject);\n    }\n  }\n};\nvar listSubscriptions = function listSubscriptions(derivedObject) {\n  var derivedObjectEntry = derivedObjectMap.get(derivedObject);\n  if (derivedObjectEntry) {\n    return Array.from(derivedObjectEntry[0]);\n  }\n  return [];\n};\nvar unstable_deriveSubscriptions = {\n  add: addSubscription,\n  remove: removeSubscription,\n  list: listSubscriptions\n};\nfunction derive(derivedFns, options) {\n  var proxyObject = (options == null ? void 0 : options.proxy) || vanilla.proxy({});\n  var notifyInSync = !!(options != null && options.sync);\n  var derivedKeys = Object.keys(derivedFns);\n  derivedKeys.forEach(function (key) {\n    if (Object.getOwnPropertyDescriptor(proxyObject, key)) {\n      throw new Error('object property already defined');\n    }\n    var fn = derivedFns[key];\n    var lastDependencies = null;\n    var evaluate = function evaluate() {\n      if (lastDependencies) {\n        if (Array.from(lastDependencies).map(function (_ref) {\n          var p = _ref[0];\n          return checkPending(p, evaluate);\n        }).some(function (isPending) {\n          return isPending;\n        })) {\n          return;\n        }\n        if (Array.from(lastDependencies).every(function (_ref2) {\n          var p = _ref2[0],\n            entry = _ref2[1];\n          return vanilla.getVersion(p) === entry.v;\n        })) {\n          return;\n        }\n      }\n      var dependencies = new Map();\n      var get = function get(p) {\n        dependencies.set(p, {\n          v: vanilla.getVersion(p)\n        });\n        return p;\n      };\n      var value = fn(get);\n      var subscribeToDependencies = function subscribeToDependencies() {\n        var _lastDependencies2;\n        dependencies.forEach(function (entry, p) {\n          var _lastDependencies, _lastDependencies$get;\n          var lastSubscription = (_lastDependencies = lastDependencies) == null ? void 0 : (_lastDependencies$get = _lastDependencies.get(p)) == null ? void 0 : _lastDependencies$get.s;\n          if (lastSubscription) {\n            entry.s = lastSubscription;\n          } else {\n            var subscription = {\n              s: p,\n              d: proxyObject,\n              k: key,\n              c: evaluate,\n              n: notifyInSync,\n              i: derivedKeys\n            };\n            addSubscription(subscription);\n            entry.s = subscription;\n          }\n        });\n        (_lastDependencies2 = lastDependencies) == null ? void 0 : _lastDependencies2.forEach(function (entry, p) {\n          if (!dependencies.has(p) && entry.s) {\n            removeSubscription(entry.s);\n          }\n        });\n        lastDependencies = dependencies;\n      };\n      if (value instanceof Promise) {\n        value.finally(subscribeToDependencies);\n      } else {\n        subscribeToDependencies();\n      }\n      proxyObject[key] = value;\n    };\n    evaluate();\n  });\n  return proxyObject;\n}\nfunction underive(proxyObject, options) {\n  var keysToDelete = options != null && options.delete ? new Set() : null;\n  listSubscriptions(proxyObject).forEach(function (subscription) {\n    var key = subscription.k;\n    if (!(options != null && options.keys) || options.keys.includes(key)) {\n      removeSubscription(subscription);\n      if (keysToDelete) {\n        keysToDelete.add(key);\n      }\n    }\n  });\n  if (keysToDelete) {\n    keysToDelete.forEach(function (key) {\n      delete proxyObject[key];\n    });\n  }\n}\nfunction addComputed_DEPRECATED(proxyObject, computedFns_FAKE, targetObject) {\n  if (targetObject === void 0) {\n    targetObject = proxyObject;\n  }\n  console.warn('addComputed is deprecated. Please consider using `derive` or `proxyWithComputed` instead. Falling back to emulation with derive.');\n  var derivedFns = {};\n  Object.keys(computedFns_FAKE).forEach(function (key) {\n    derivedFns[key] = function (get) {\n      return computedFns_FAKE[key](get(proxyObject));\n    };\n  });\n  return derive(derivedFns, {\n    proxy: targetObject\n  });\n}\nfunction proxyWithComputed(initialObject, computedFns) {\n  Object.keys(computedFns).forEach(function (key) {\n    if (Object.getOwnPropertyDescriptor(initialObject, key)) {\n      throw new Error('object property already defined');\n    }\n    var computedFn = computedFns[key];\n    var _ref = typeof computedFn === 'function' ? {\n        get: computedFn\n      } : computedFn,\n      get = _ref.get,\n      set = _ref.set;\n    var desc = {};\n    desc.get = function () {\n      return get(vanilla.snapshot(proxyObject));\n    };\n    if (set) {\n      desc.set = function (newValue) {\n        return set(proxyObject, newValue);\n      };\n    }\n    Object.defineProperty(initialObject, key, desc);\n  });\n  var proxyObject = vanilla.proxy(initialObject);\n  return proxyObject;\n}\nfunction proxyWithHistory(initialValue, skipSubscribe) {\n  if (skipSubscribe === void 0) {\n    skipSubscribe = false;\n  }\n  var proxyObject = vanilla.proxy({\n    value: initialValue,\n    history: vanilla.ref({\n      wip: initialValue,\n      snapshots: [],\n      index: -1\n    }),\n    canUndo: function canUndo() {\n      return proxyObject.history.index > 0;\n    },\n    undo: function undo() {\n      if (proxyObject.canUndo()) {\n        proxyObject.value = proxyObject.history.wip = proxyObject.history.snapshots[--proxyObject.history.index];\n        proxyObject.history.snapshots[proxyObject.history.index] = vanilla.snapshot(proxyObject).value;\n      }\n    },\n    canRedo: function canRedo() {\n      return proxyObject.history.index < proxyObject.history.snapshots.length - 1;\n    },\n    redo: function redo() {\n      if (proxyObject.canRedo()) {\n        proxyObject.value = proxyObject.history.wip = proxyObject.history.snapshots[++proxyObject.history.index];\n        proxyObject.history.snapshots[proxyObject.history.index] = vanilla.snapshot(proxyObject).value;\n      }\n    },\n    saveHistory: function saveHistory() {\n      proxyObject.history.snapshots.splice(proxyObject.history.index + 1);\n      proxyObject.history.snapshots.push(vanilla.snapshot(proxyObject).value);\n      ++proxyObject.history.index;\n    },\n    subscribe: function subscribe() {\n      return vanilla.subscribe(proxyObject, function (ops) {\n        if (ops.every(function (op) {\n          return op[1][0] === 'value' && (op[0] !== 'set' || op[2] !== proxyObject.history.wip);\n        })) {\n          proxyObject.saveHistory();\n        }\n      });\n    }\n  });\n  proxyObject.saveHistory();\n  if (!skipSubscribe) {\n    proxyObject.subscribe();\n  }\n  return proxyObject;\n}\nfunction _defineEnumerableProperties(obj, descs) {\n  for (var key in descs) {\n    var desc = descs[key];\n    desc.configurable = desc.enumerable = true;\n    if (\"value\" in desc) desc.writable = true;\n    Object.defineProperty(obj, key, desc);\n  }\n  if (Object.getOwnPropertySymbols) {\n    var objectSymbols = Object.getOwnPropertySymbols(descs);\n    for (var i = 0; i < objectSymbols.length; i++) {\n      var sym = objectSymbols[i];\n      var desc = descs[sym];\n      desc.configurable = desc.enumerable = true;\n      if (\"value\" in desc) desc.writable = true;\n      Object.defineProperty(obj, sym, desc);\n    }\n  }\n  return obj;\n}\nfunction proxySet(initialValues) {\n  var _Symbol$toStringTag, _proxy, _mutatorMap;\n  var set = vanilla.proxy((_proxy = {\n    data: Array.from(new Set(initialValues)),\n    has: function has(value) {\n      return this.data.indexOf(value) !== -1;\n    },\n    add: function add(value) {\n      var hasProxy = false;\n      if (typeof value === 'object' && value !== null) {\n        hasProxy = this.data.indexOf(vanilla.proxy(value)) !== -1;\n      }\n      if (this.data.indexOf(value) === -1 && !hasProxy) {\n        this.data.push(value);\n      }\n      return this;\n    },\n    delete: function _delete(value) {\n      var index = this.data.indexOf(value);\n      if (index === -1) {\n        return false;\n      }\n      this.data.splice(index, 1);\n      return true;\n    },\n    clear: function clear() {\n      this.data.splice(0);\n    },\n    get size() {\n      return this.data.length;\n    },\n    forEach: function forEach(cb) {\n      var _this = this;\n      this.data.forEach(function (value) {\n        cb(value, value, _this);\n      });\n    }\n  }, _Symbol$toStringTag = Symbol.toStringTag, _mutatorMap = {}, _mutatorMap[_Symbol$toStringTag] = _mutatorMap[_Symbol$toStringTag] || {}, _mutatorMap[_Symbol$toStringTag].get = function () {\n    return 'Set';\n  }, _proxy.toJSON = function toJSON() {\n    return {};\n  }, _proxy[Symbol.iterator] = function () {\n    return this.data[Symbol.iterator]();\n  }, _proxy.values = function values() {\n    return this.data.values();\n  }, _proxy.keys = function keys() {\n    return this.data.values();\n  }, _proxy.entries = function entries() {\n    return new Set(this.data).entries();\n  }, _defineEnumerableProperties(_proxy, _mutatorMap), _proxy));\n  Object.defineProperties(set, {\n    data: {\n      enumerable: false\n    },\n    size: {\n      enumerable: false\n    },\n    toJSON: {\n      enumerable: false\n    }\n  });\n  Object.seal(set);\n  return set;\n}\nfunction proxyMap(entries) {\n  var _Symbol$toStringTag, _proxy, _mutatorMap;\n  var map = vanilla.proxy((_proxy = {\n    data: Array.from(entries || []),\n    has: function has(key) {\n      return this.data.some(function (p) {\n        return p[0] === key;\n      });\n    },\n    set: function set(key, value) {\n      var record = this.data.find(function (p) {\n        return p[0] === key;\n      });\n      if (record) {\n        record[1] = value;\n      } else {\n        this.data.push([key, value]);\n      }\n      return this;\n    },\n    get: function get(key) {\n      var _this$data$find;\n      return (_this$data$find = this.data.find(function (p) {\n        return p[0] === key;\n      })) == null ? void 0 : _this$data$find[1];\n    },\n    delete: function _delete(key) {\n      var index = this.data.findIndex(function (p) {\n        return p[0] === key;\n      });\n      if (index === -1) {\n        return false;\n      }\n      this.data.splice(index, 1);\n      return true;\n    },\n    clear: function clear() {\n      this.data.splice(0);\n    },\n    get size() {\n      return this.data.length;\n    },\n    toJSON: function toJSON() {\n      return {};\n    },\n    forEach: function forEach(cb) {\n      var _this = this;\n      this.data.forEach(function (p) {\n        cb(p[1], p[0], _this);\n      });\n    },\n    keys: function keys() {\n      return this.data.map(function (p) {\n        return p[0];\n      }).values();\n    },\n    values: function values() {\n      return this.data.map(function (p) {\n        return p[1];\n      }).values();\n    },\n    entries: function entries() {\n      return new Map(this.data).entries();\n    }\n  }, _Symbol$toStringTag = Symbol.toStringTag, _mutatorMap = {}, _mutatorMap[_Symbol$toStringTag] = _mutatorMap[_Symbol$toStringTag] || {}, _mutatorMap[_Symbol$toStringTag].get = function () {\n    return 'Map';\n  }, _proxy[Symbol.iterator] = function () {\n    return this.entries();\n  }, _defineEnumerableProperties(_proxy, _mutatorMap), _proxy));\n  Object.defineProperties(map, {\n    data: {\n      enumerable: false\n    },\n    size: {\n      enumerable: false\n    },\n    toJSON: {\n      enumerable: false\n    }\n  });\n  Object.seal(map);\n  return map;\n}\nexports.addComputed = addComputed_DEPRECATED;\nexports.derive = derive;\nexports.devtools = devtools;\nexports.proxyMap = proxyMap;\nexports.proxySet = proxySet;\nexports.proxyWithComputed = proxyWithComputed;\nexports.proxyWithHistory = proxyWithHistory;\nexports.subscribeKey = subscribeKey;\nexports.underive = underive;\nexports.unstable_deriveSubscriptions = unstable_deriveSubscriptions;\nexports.watch = watch;","map":null,"metadata":{},"sourceType":"script"}