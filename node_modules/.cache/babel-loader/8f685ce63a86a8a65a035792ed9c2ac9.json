{"ast":null,"code":"/**\n * @file Main scene model\n * @description Scene model for your application\n */\n\nimport { ACameraModel, Color, GetAppState, NodeTransform3D, V3, Vec2, Vec3 } from \"../../../anigraph\";\nimport { BaseSceneModel } from \"../../BaseClasses\";\nimport { ATexture } from \"src/anigraph/rendering/ATexture\";\nimport { APointLightModel } from \"../../../anigraph/scene/lights\";\nimport { AppConfigs } from \"../../AppConfigs\";\nimport { PlayerModel } from \"../Nodes/PlayerNode\";\nimport { GameTerrainModel } from \"../Nodes/GameTerrain/GameTerrainModel\";\nconst exampleLevel = {\n  player: [0, 2],\n  terrains: [[-1, 0, 8, 1], [10, 1, 5, 1], [17, 3, 5, 1], [27, 0, 10, 1]]\n};\nlet appState = GetAppState();\nexport class MainSceneModel extends BaseSceneModel {\n  constructor() {\n    super(...arguments);\n    this._player = void 0;\n    this.playerTexture = void 0;\n    this.bots = [];\n    this.gameTerrains = [];\n  }\n  get player() {\n    return this._player;\n  }\n  set player(v) {\n    this._player = v;\n  }\n  async PreloadAssets() {\n    await super.PreloadAssets();\n    await GameTerrainModel.LoadShader();\n    await PlayerModel.LoadShader();\n    // this.materials.setMaterialModel(\"textured\", await ABasicShaderModel.CreateModel(\"basic\"));\n  }\n\n  initCamera() {\n    this.cameraModel = ACameraModel.CreatePerspectiveFOV(90, 1, 0.01, 100);\n    this.cameraModel.setPose(NodeTransform3D.LookAt(V3(0.0, 0, 5), V3(0, 0, 0), V3(0, 1, 0)));\n  }\n\n  /**\n   * The view light is a light that is attached to the camera.\n   */\n  initViewLight() {\n    /**\n     * Create a point light\n     * You can have up to 16 point lights in the scene at once by default\n     */\n    this.viewLight = new APointLightModel(this.camera.pose, Color.FromString(\"#ffffff\"), 0.5, AppConfigs.ViewLightRange, 1);\n\n    /**\n     * Add it as a child of the camera model so that it will move with the camera\n     */\n    this.cameraModel.addChild(this.viewLight);\n  }\n  async initGameTerrain() {\n    for (let [x1, y1, w, h] of exampleLevel.terrains) {\n      let terrain = await GameTerrainModel.Create(w, h);\n      terrain.position.x = x1 + w / 2;\n      terrain.position.y = y1 + h / 2;\n      this.gameTerrains.push(terrain);\n      this.addChild(terrain);\n    }\n  }\n  async initGameHero() {\n    this.playerTexture = await ATexture.LoadAsync(\"./images/tanktexburngreen.jpeg\");\n    this.player = await PlayerModel.Create(this.playerTexture);\n    this.player.position = new Vec3(...exampleLevel.player, 0);\n    this.addChild(this.player);\n  }\n  async initScene() {\n    await this.initGameTerrain();\n    await this.initGameHero();\n\n    /**\n     * Now let's initialize the view light\n     */\n    this.initViewLight();\n  }\n  timeUpdate(t) {\n    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    /**\n     * We can call timeUpdate on all of the model nodes in the scene here, which will trigger any updates that they\n     * individually define.\n     */\n    for (let c of this.getDescendantList()) {\n      c.timeUpdate(t);\n    }\n    if (!debug) {\n      this.player.update(this.gameTerrains);\n      if (this.player.position.y < -10 || t <= 0.5) {\n        this.player.position = new Vec3(...exampleLevel.player, 0);\n        this.player.velocity = new Vec3();\n        const playerPos = this.player.position;\n        const cameraPos = playerPos.clone();\n        cameraPos.z = 10;\n        this.cameraModel.setPose(NodeTransform3D.LookAt(cameraPos, playerPos, new Vec3(0, 1, 0)));\n      }\n      if (Math.abs(this.cameraModel.pose.position.x - this.player.position.x) >= 0.01 || Math.abs(this.cameraModel.pose.position.y - this.player.position.y) >= 0.01) {\n        const cameraPos = this.cameraModel.pose.position.clone();\n        const playerPos = this.player.position.clone();\n        const playerVel = this.player.velocity.clone();\n        // higher gravity will look like player falling down harder\n        const g = AppConfigs.Gravity > 10 ? (AppConfigs.Gravity - 10) / 10 : 0;\n        playerVel.y = playerVel.y < g * playerVel.y ? 0 : playerVel.y;\n        // rate of camera movement, with 1 being camera on player at all times\n        const rate = this.cameraModel.pose.position.y < this.player.position.y ? 0.04 : 0.05;\n        // 1.5 is how much screen moves with player\n        const velocityCamera = cameraPos.clone().plus(playerVel.clone().times(1.5));\n        const new_camera_pos = velocityCamera.clone().plus(playerPos.clone().minus(velocityCamera).times(rate));\n        new_camera_pos.z = 10;\n        const new_target_pos = new_camera_pos.clone();\n        new_target_pos.z = 0;\n        this.cameraModel.setPose(NodeTransform3D.LookAt(new_camera_pos, new_target_pos, new Vec3(0, 1, 0)));\n      }\n      this.cameraModel.signalCameraProjectionUpdate();\n    }\n\n    // /**\n    //  * For interactions between models, we can trigger logic here. For example, if you want characters to walk on\n    //  * uneven terrain, you can make that happen by completing the functions used here:\n    //  */\n    // const self = this;\n    // function adjustHeight(character:Particle3D){\n    //     let height = self.terrain.getTerrainHeightAtPoint(character.position.xy);\n    //     if(character.position.z<height){character.position.z = height;}\n    // }\n    //\n    // /**\n    //  * Here we would apply our adjust height function to the player\n    //  */\n    // adjustHeight(this.player);\n    //\n    // /**\n    //  * Now lets update bots\n    //  */\n    // let orbitradius = 0.25;\n    // for(let ei=0;ei<this.bots.length;ei++){\n    //     let e = this.bots[ei];\n    //\n    //     /**\n    //      * Characters have velocity and mass properties in case you want to implement particle physics\n    //      * But for now we will just have them orbit each other.\n    //      */\n    //     e.position = new Vec3(Math.cos(t*(ei+1)), Math.sin(t*(ei+1)),0).times(orbitradius);\n    //\n    //     /**\n    //      * adjust their height\n    //      */\n    //     adjustHeight(e);\n    // }\n  }\n\n  getCoordinatesForCursorEvent(event) {\n    var _event$ndcCursor;\n    return (_event$ndcCursor = event.ndcCursor) !== null && _event$ndcCursor !== void 0 ? _event$ndcCursor : new Vec2();\n  }\n}","map":{"version":3,"names":["ACameraModel","Color","GetAppState","NodeTransform3D","V3","Vec2","Vec3","BaseSceneModel","ATexture","APointLightModel","AppConfigs","PlayerModel","GameTerrainModel","exampleLevel","player","terrains","appState","MainSceneModel","_player","playerTexture","bots","gameTerrains","v","PreloadAssets","LoadShader","initCamera","cameraModel","CreatePerspectiveFOV","setPose","LookAt","initViewLight","viewLight","camera","pose","FromString","ViewLightRange","addChild","initGameTerrain","x1","y1","w","h","terrain","Create","position","x","y","push","initGameHero","LoadAsync","initScene","timeUpdate","t","debug","c","getDescendantList","update","velocity","playerPos","cameraPos","clone","z","Math","abs","playerVel","g","Gravity","rate","velocityCamera","plus","times","new_camera_pos","minus","new_target_pos","signalCameraProjectionUpdate","getCoordinatesForCursorEvent","event","ndcCursor"],"sources":["/Users/home/Desktop/cs4620-final-project/src/app/main/Scene/MainSceneModel.ts"],"sourcesContent":["/**\n * @file Main scene model\n * @description Scene model for your application\n */\n\nimport {ACameraModel, AInteractionEvent, Color, GetAppState, NodeTransform3D, V3, Vec2, Vec3} from \"../../../anigraph\";\nimport {BaseSceneModel} from \"../../BaseClasses\";\nimport {ATexture} from \"src/anigraph/rendering/ATexture\";\nimport {APointLightModel} from \"../../../anigraph/scene/lights\";\nimport {AppConfigs} from \"../../AppConfigs\";\nimport {PlayerModel} from \"../Nodes/PlayerNode\";\nimport {BotModel} from \"../Nodes/CharacterNodes/BotModel\";\nimport {GameTerrainModel} from \"../Nodes/GameTerrain/GameTerrainModel\";\n\nconst exampleLevel: {player: [number, number], terrains: [number, number, number, number][]} = {\n    player: [0, 2],\n    terrains: [\n      [-1, 0, 8, 1],\n      [10, 1, 5, 1],\n      [17, 3, 5, 1],\n      [27, 0, 10, 1],\n    ],\n};\n\nlet appState = GetAppState();\nexport class MainSceneModel extends BaseSceneModel {\n    /**\n     * Our custom player model, and a texture to use for our player\n     */\n    _player!:PlayerModel;\n    get player():PlayerModel{\n        return this._player as PlayerModel;\n    }\n    set player(v:PlayerModel){\n        this._player = v;\n    }\n    playerTexture!:ATexture;\n\n    /**\n     * An array of bots. Your\n     */\n    bots:BotModel[]=[];\n\n    gameTerrains:GameTerrainModel[]=[];\n\n\n    async PreloadAssets() {\n        await super.PreloadAssets();\n        await GameTerrainModel.LoadShader();\n        await PlayerModel.LoadShader();\n        // this.materials.setMaterialModel(\"textured\", await ABasicShaderModel.CreateModel(\"basic\"));\n\n    }\n\n    initCamera() {\n        this.cameraModel = ACameraModel.CreatePerspectiveFOV(90, 1, 0.01, 100);\n        this.cameraModel.setPose(\n            NodeTransform3D.LookAt(\n                V3(0.0, 0, 5), V3(0,0,0),\n                V3(0,1,0)\n            )\n        )\n    }\n\n    /**\n     * The view light is a light that is attached to the camera.\n     */\n    initViewLight(){\n\n        /**\n         * Create a point light\n         * You can have up to 16 point lights in the scene at once by default\n         */\n        this.viewLight = new APointLightModel(\n            this.camera.pose,\n            Color.FromString(\"#ffffff\"),\n            0.5,\n            AppConfigs.ViewLightRange,\n            1\n        );\n\n        /**\n         * Add it as a child of the camera model so that it will move with the camera\n         */\n        this.cameraModel.addChild(this.viewLight);\n    }\n\n    async initGameTerrain() {\n        for (let [x1, y1, w, h] of exampleLevel.terrains) {\n            let terrain = await GameTerrainModel.Create(w, h);\n            terrain.position.x = x1 + w / 2;\n            terrain.position.y = y1 + h / 2;\n            this.gameTerrains.push(terrain);\n            this.addChild(terrain);\n        }\n    }\n\n    async initGameHero() {\n        this.playerTexture = await ATexture.LoadAsync(\"./images/tanktexburngreen.jpeg\")\n        this.player = await PlayerModel.Create(this.playerTexture);\n        this.player.position = new Vec3(...exampleLevel.player, 0);\n        this.addChild(this.player);\n    }\n\n\n    async initScene() {\n        await this.initGameTerrain();\n        await this.initGameHero();\n\n        /**\n         * Now let's initialize the view light\n         */\n        this.initViewLight();\n    }\n\n    timeUpdate(t: number, debug: boolean = false, ...args:any[]) {\n\n        /**\n         * We can call timeUpdate on all of the model nodes in the scene here, which will trigger any updates that they\n         * individually define.\n         */\n        for(let c of this.getDescendantList()){\n            c.timeUpdate(t);\n        }\n\n        if (!debug) {\n\n            this.player.update(this.gameTerrains);\n\n            if (this.player.position.y < -10 || t <= 0.5) {\n                this.player.position = new Vec3(...exampleLevel.player, 0);\n                this.player.velocity = new Vec3();\n                const playerPos = this.player.position;\n                const cameraPos = playerPos.clone();\n                cameraPos.z = 10;\n                this.cameraModel.setPose(\n                  NodeTransform3D.LookAt(\n                    cameraPos, playerPos,\n                    new Vec3(0, 1, 0)\n                  )\n                );\n            } \n            \n            if (Math.abs(this.cameraModel.pose.position.x - this.player.position.x)  >= 0.01 ||\n            Math.abs(this.cameraModel.pose.position.y - this.player.position.y) >= 0.01) {\n\n                const cameraPos = this.cameraModel.pose.position.clone()\n                const playerPos = this.player.position.clone();\n                const playerVel = this.player.velocity.clone();\n                // higher gravity will look like player falling down harder\n                const g = AppConfigs.Gravity > 10? (AppConfigs.Gravity - 10)/10 : 0\n                playerVel.y = playerVel.y < g * playerVel.y ? 0 : playerVel.y\n                // rate of camera movement, with 1 being camera on player at all times\n                const rate = this.cameraModel.pose.position.y < this.player.position.y ? 0.04 : 0.05\n                // 1.5 is how much screen moves with player\n                const velocityCamera = cameraPos.clone().plus(playerVel.clone().times(1.5))\n                const new_camera_pos = velocityCamera.clone().plus(playerPos.clone().minus(velocityCamera).times(rate))\n                new_camera_pos.z = 10;\n\n                const new_target_pos = new_camera_pos.clone()\n                new_target_pos.z = 0;\n\n                this.cameraModel.setPose(\n                  NodeTransform3D.LookAt(\n                    new_camera_pos, new_target_pos,\n                    new Vec3(0, 1, 0)\n                  )\n                );\n            }\n            this.cameraModel.signalCameraProjectionUpdate();\n        }\n\n\n        // /**\n        //  * For interactions between models, we can trigger logic here. For example, if you want characters to walk on\n        //  * uneven terrain, you can make that happen by completing the functions used here:\n        //  */\n        // const self = this;\n        // function adjustHeight(character:Particle3D){\n        //     let height = self.terrain.getTerrainHeightAtPoint(character.position.xy);\n        //     if(character.position.z<height){character.position.z = height;}\n        // }\n        //\n        // /**\n        //  * Here we would apply our adjust height function to the player\n        //  */\n        // adjustHeight(this.player);\n        //\n        // /**\n        //  * Now lets update bots\n        //  */\n        // let orbitradius = 0.25;\n        // for(let ei=0;ei<this.bots.length;ei++){\n        //     let e = this.bots[ei];\n        //\n        //     /**\n        //      * Characters have velocity and mass properties in case you want to implement particle physics\n        //      * But for now we will just have them orbit each other.\n        //      */\n        //     e.position = new Vec3(Math.cos(t*(ei+1)), Math.sin(t*(ei+1)),0).times(orbitradius);\n        //\n        //     /**\n        //      * adjust their height\n        //      */\n        //     adjustHeight(e);\n        // }\n    }\n\n    getCoordinatesForCursorEvent(event: AInteractionEvent){\n        return event.ndcCursor??new Vec2();\n    }\n}\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}