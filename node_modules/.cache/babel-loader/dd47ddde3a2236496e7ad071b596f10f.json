{"ast":null,"code":"var _dec, _class;\nimport * as THREE from \"three\";\nimport { V3, Mat4, NodeTransform3D } from \"../\";\nimport { VertexArray3D } from \"./VertexArray3D\";\nimport { BoundingBox3D } from \"./BoundingBox3D\";\nimport { ref } from \"valtio\";\nimport { AObject, ASerializable } from \"../base\";\nimport { GetDeepTHREEJSClone } from \"../rendering\";\nexport let AObject3DModelWrapper = (_dec = ASerializable(\"AObject3DModelWrapper\"), _dec(_class = class AObject3DModelWrapper extends AObject {\n  // protected _sourceTransform: TransformationInterface;\n\n  get sourceTransform() {\n    return this._sourceTransform;\n  }\n\n  // get sourceScale() {\n  //   return this.sourceTransform.scale;\n  // }\n\n  // get uid() {\n  //   return this.object.uuid;\n  // }\n  constructor(object) {\n    super(object.uuid);\n    this.object = void 0;\n    this._sourceTransform = void 0;\n    this.object = ref(object);\n    this.object.matrixAutoUpdate = false;\n    // this._sourceTransform = new Mat4();\n    this._sourceTransform = new NodeTransform3D();\n  }\n  getNewSceneObject() {\n    let wrapInGroup = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let deepCopy = arguments.length > 1 ? arguments[1] : undefined;\n    let scale = arguments.length > 2 ? arguments[2] : undefined;\n    let obj;\n    if (deepCopy) {\n      obj = GetDeepTHREEJSClone(this.object);\n    } else {\n      if (this.object instanceof THREE.Mesh) {\n        obj = new THREE.Mesh(this.object.geometry, this.object.material);\n      } else {\n        obj = this.object.clone();\n      }\n    }\n    obj.matrixAutoUpdate = false;\n    if (scale === undefined) {\n      this.sourceTransform.assignTo(obj.matrix);\n    } else {\n      this.sourceTransform.getMatrix().times(Mat4.Scale3D(scale)).assignTo(obj.matrix);\n    }\n    if (wrapInGroup) {\n      let group = new THREE.Group();\n      group.matrixAutoUpdate = false;\n      group.add(obj);\n      return group;\n    } else {\n      return obj;\n    }\n  }\n  setSourceScale(sourceScale) {\n    this._sourceTransform.scale = sourceScale;\n    // Mat4.Scale3D(sourceScale).assignTo(this.object.matrix);\n    this._sourceTransform.getMatrix().assignTo(this.object.matrix);\n  }\n  getBoundingBoxVertexArray() {\n    return VertexArray3D.BoundingBoxMeshVertsForObject3D(this.object);\n  }\n\n  // setSourceScale(sourceScale: number) {\n  //   this._sourceTransform.scale = sourceScale;\n  //   // Mat4.Scale3D(sourceScale).assignTo(this.object.matrix);\n  //   this._sourceTransform.getMatrix().assignTo(this.object.matrix);\n  // }\n\n  set sourceTransform(v) {\n    if (v instanceof NodeTransform3D) {\n      this._sourceTransform = v;\n    } else {\n      this._sourceTransform = NodeTransform3D.FromMatrix(v.getMat4());\n    }\n    this._sourceTransform.assignTo(this.object.matrix);\n  }\n  getBounds() {\n    let threebox = new THREE.Box3().setFromObject(this.object);\n    let bounds = new BoundingBox3D();\n    bounds.minPoint = V3(threebox.min.x, threebox.min.y, threebox.min.z);\n    bounds.maxPoint = V3(threebox.max.x, threebox.max.y, threebox.max.z);\n    return bounds;\n  }\n  // getBounds(){\n  //     return this.getBounds3D();\n  // }\n}) || _class);","map":{"version":3,"names":["THREE","V3","Mat4","NodeTransform3D","VertexArray3D","BoundingBox3D","ref","AObject","ASerializable","GetDeepTHREEJSClone","AObject3DModelWrapper","sourceTransform","_sourceTransform","constructor","object","uuid","matrixAutoUpdate","getNewSceneObject","wrapInGroup","deepCopy","scale","obj","Mesh","geometry","material","clone","undefined","assignTo","matrix","getMatrix","times","Scale3D","group","Group","add","setSourceScale","sourceScale","getBoundingBoxVertexArray","BoundingBoxMeshVertsForObject3D","v","FromMatrix","getMat4","getBounds","threebox","Box3","setFromObject","bounds","minPoint","min","x","y","z","maxPoint","max"],"sources":["/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/src/anigraph/geometry/AObject3DModelWrapper.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport {V3, Mat4, TransformationInterface, NodeTransform3D,} from \"../\";\nimport {HasBounds} from \"./HasBounds\";\nimport {VertexArray3D} from \"./VertexArray3D\";\nimport {BoundingBox3D} from \"./BoundingBox3D\";\nimport { ref } from \"valtio\";\nimport {AObject, ASerializable} from \"../base\";\nimport {GetDeepTHREEJSClone} from \"../rendering\";\n\n@ASerializable(\"AObject3DModelWrapper\")\nexport class AObject3DModelWrapper extends AObject implements HasBounds {\n  public object: THREE.Object3D;\n  // protected _sourceTransform: TransformationInterface;\n  protected _sourceTransform: NodeTransform3D;\n\n  get sourceTransform() :NodeTransform3D{\n    return this._sourceTransform;\n  }\n\n  // get sourceScale() {\n  //   return this.sourceTransform.scale;\n  // }\n\n  // get uid() {\n  //   return this.object.uuid;\n  // }\n  constructor(object: THREE.Object3D) {\n    super(object.uuid);\n    this.object = ref(object);\n    this.object.matrixAutoUpdate = false;\n    // this._sourceTransform = new Mat4();\n    this._sourceTransform = new NodeTransform3D();\n  }\n\n  getNewSceneObject(wrapInGroup:boolean=false, deepCopy?:boolean, scale?:number) {\n    let obj: THREE.Object3D;\n    if(deepCopy){\n      obj = GetDeepTHREEJSClone(this.object);\n    }else {\n      if (this.object instanceof THREE.Mesh) {\n        obj = new THREE.Mesh(this.object.geometry, this.object.material);\n      } else {\n        obj = this.object.clone();\n      }\n    }\n    obj.matrixAutoUpdate = false;\n    if(scale===undefined) {\n      this.sourceTransform.assignTo(obj.matrix);\n    }else{\n      (this.sourceTransform.getMatrix() as Mat4).times(Mat4.Scale3D(scale)).assignTo(obj.matrix);\n    }\n    if(wrapInGroup){\n      let group = new THREE.Group();\n      group.matrixAutoUpdate=false;\n      group.add(obj);\n      return group;\n    }else {\n      return obj;\n    }\n  }\n\n  setSourceScale(sourceScale:number){\n    this._sourceTransform.scale=sourceScale;\n    // Mat4.Scale3D(sourceScale).assignTo(this.object.matrix);\n    this._sourceTransform.getMatrix().assignTo(this.object.matrix);\n  }\n\n  getBoundingBoxVertexArray() {\n    return VertexArray3D.BoundingBoxMeshVertsForObject3D(this.object);\n  }\n\n  // setSourceScale(sourceScale: number) {\n  //   this._sourceTransform.scale = sourceScale;\n  //   // Mat4.Scale3D(sourceScale).assignTo(this.object.matrix);\n  //   this._sourceTransform.getMatrix().assignTo(this.object.matrix);\n  // }\n\n  set sourceTransform(v: TransformationInterface) {\n    if(v instanceof NodeTransform3D) {\n    this._sourceTransform = v;\n    }else{\n      this._sourceTransform = NodeTransform3D.FromMatrix(v.getMat4());\n    }\n    this._sourceTransform.assignTo(this.object.matrix);\n  }\n\n  getBounds(): BoundingBox3D {\n    let threebox = new THREE.Box3().setFromObject(this.object);\n    let bounds = new BoundingBox3D();\n    bounds.minPoint = V3(threebox.min.x, threebox.min.y, threebox.min.z);\n    bounds.maxPoint = V3(threebox.max.x, threebox.max.y, threebox.max.z);\n    return bounds;\n  }\n  // getBounds(){\n  //     return this.getBounds3D();\n  // }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}