{"ast":null,"code":"import _initializerDefineProperty from \"/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js\";\nimport _applyDecoratedDescriptor from \"/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js\";\nimport _initializerWarningHelper from \"/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js\";\nvar _dec, _class, _class2, _descriptor, _class3;\nimport { AObject } from \"../base/aobject/AObject\";\nimport { AObjectState } from \"../base/aobject/AObject\";\nimport { ASerializable } from \"../base/aserial/ASerializable\";\n// import {v4 as uuidv4} from \"uuid\";\n// import {ADragInteraction} from \"../ainteraction\";\nimport { _ASystemTime } from \"./ASystemTime\";\nexport let AClockEnums;\n\n/***\n * time passed is tiem-refStart\n * Pausing\n */\n(function (AClockEnums) {\n  AClockEnums[AClockEnums[\"DEFAULT_PERIOD_IN_MILLISECONDS\"] = 1000] = \"DEFAULT_PERIOD_IN_MILLISECONDS\";\n  AClockEnums[\"TIME_UPDATE_SUBSCRIPTION_HANDLE\"] = \"TimeUpdate\";\n})(AClockEnums || (AClockEnums = {}));\nexport let AClock = (_dec = ASerializable(\"AClock\"), _dec(_class = (_class2 = (_class3 = class AClock extends AObject {\n  //Whether the clock is paused\n\n  // The time value of the clock is the difference between the current time and refStart.\n  // When the clock is unpaused, refStart remains constant as time progresses, increasing the value of the clock.\n  // When the clock is unpaused after pausing, the time it spent paused will be added to refStart.\n\n  // The time when the clock was last paused or unpaused\n\n  // The time of the last update\n\n  // The current clock's value at the last update\n\n  // Offset is used to \"commit\" the passage of time to the clock's memory.\n  // This becomes important if we change the clock's rate, as previous milliseconds may passed at different rates, contributing different amounts to the clock's current value.\n\n  // This defines the current rate of the clock in terms of a period.\n  // It can be changed over time to make the clock progress slower or faster.\n\n  /** Get set paused */\n  set paused(value) {\n    this._paused = value;\n  }\n  get paused() {\n    return this._paused;\n  }\n  get lastTimeUpdated() {\n    return this._lastClockTimeUpdated;\n  }\n  get rate() {\n    return AClockEnums.DEFAULT_PERIOD_IN_MILLISECONDS / this._periodInMilliseconds;\n  }\n  set rate(v) {\n    let now = this._getNow();\n    this._offset = this.time;\n    this._refStart = now;\n    this._periodInMilliseconds = AClockEnums.DEFAULT_PERIOD_IN_MILLISECONDS / v;\n  }\n  addTimeListener(callback, handle) {\n    const self = this;\n    return this.addStateKeyListener(\"time\", () => {\n      callback(self.time);\n    }, handle, false);\n  }\n  constructor() {\n    super();\n    _initializerDefineProperty(this, \"time\", _descriptor, this);\n    this._paused = true;\n    this._refStart = 0;\n    this._lastPauseStateChange = 0;\n    this._lastUpdate = 0;\n    this._lastClockTimeUpdated = 0;\n    this._offset = 0;\n    this._periodInMilliseconds = AClockEnums.DEFAULT_PERIOD_IN_MILLISECONDS;\n    this.reset(0);\n    this.initClockSubscription();\n  }\n  initClockSubscription() {\n    const self = this;\n    this.subscribe(AClock.SystemTime.addListener(t => {\n      self.update(t);\n    }), AClockEnums.TIME_UPDATE_SUBSCRIPTION_HANDLE);\n  }\n  reset() {\n    let t0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    this.time = t0;\n    this._refStart = t0;\n    this._lastPauseStateChange = t0;\n    this._lastUpdate = t0;\n    this._offset = 0;\n    this._periodInMilliseconds = AClockEnums.DEFAULT_PERIOD_IN_MILLISECONDS;\n    this._paused = true;\n  }\n  update(t) {\n    if (this._paused) {\n      return;\n    }\n    this.time = this._offset + (t - this._refStart) / this._periodInMilliseconds;\n    this._lastUpdate = t;\n    this._lastClockTimeUpdated = this.time;\n  }\n  _getNow() {\n    return Date.now();\n  }\n  play() {\n    if (!this.paused) {\n      return;\n    }\n    let now = this._getNow();\n    this._refStart = this._refStart + (now - this._lastPauseStateChange);\n    this._paused = false;\n    this._lastPauseStateChange = now;\n    this.activateSubscription(AClockEnums.TIME_UPDATE_SUBSCRIPTION_HANDLE);\n  }\n  pause() {\n    let now = this._getNow();\n    this._paused = true;\n    this._lastPauseStateChange = now;\n    this.deactivateSubscription(AClockEnums.TIME_UPDATE_SUBSCRIPTION_HANDLE);\n  }\n\n  /**\n   * IMPORTANT! If you want to remove the listener at the end of the action\n   * you need to do so in the actionOverCallback!\n   * @param callback\n   * @param duration\n   * @param actionOverCallback\n   * @param tween\n   * @returns {AStateCallbackSwitch}\n   * @constructor\n   */\n  CreateTimedAction(callback, duration, actionOverCallback, tween) {\n    const self = this;\n    const startTime = this.time;\n    return this.addTimeListener(t => {\n      //calculate how much time has passed\n      let timePassed = t - startTime;\n      // Check to see if the duration has passed\n      if (timePassed > duration) {\n        if (actionOverCallback) {\n          actionOverCallback();\n        }\n        return;\n      }\n      let normalizedTime = timePassed / duration;\n      if (tween) {\n        normalizedTime = tween.eval(normalizedTime);\n      }\n      callback(normalizedTime);\n    });\n  }\n}, _class3.SystemTime = new _ASystemTime(), _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"time\", [AObjectState], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);\nAClock.SystemTime.unpause();","map":{"version":3,"names":["AObject","AObjectState","ASerializable","_ASystemTime","AClockEnums","AClock","paused","value","_paused","lastTimeUpdated","_lastClockTimeUpdated","rate","DEFAULT_PERIOD_IN_MILLISECONDS","_periodInMilliseconds","v","now","_getNow","_offset","time","_refStart","addTimeListener","callback","handle","self","addStateKeyListener","constructor","_lastPauseStateChange","_lastUpdate","reset","initClockSubscription","subscribe","SystemTime","addListener","t","update","TIME_UPDATE_SUBSCRIPTION_HANDLE","t0","Date","play","activateSubscription","pause","deactivateSubscription","CreateTimedAction","duration","actionOverCallback","tween","startTime","timePassed","normalizedTime","eval","unpause"],"sources":["/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/src/anigraph/time/AClock.ts"],"sourcesContent":["import {AObject} from \"../base/aobject/AObject\";\nimport {AObjectState} from \"../base/aobject/AObject\";\nimport {ASerializable} from \"../base/aserial/ASerializable\";\nimport {CallbackType} from \"../basictypes\";\n\nimport {BezierTween} from \"../geometry\";\n// import {v4 as uuidv4} from \"uuid\";\n// import {ADragInteraction} from \"../ainteraction\";\nimport { _ASystemTime } from \"./ASystemTime\";\n\nexport enum AClockEnums {\n  DEFAULT_PERIOD_IN_MILLISECONDS = 1000,\n  TIME_UPDATE_SUBSCRIPTION_HANDLE = \"TimeUpdate\",\n}\n\n/***\n * time passed is tiem-refStart\n * Pausing\n */\n@ASerializable(\"AClock\")\nexport class AClock extends AObject {\n  static SystemTime: _ASystemTime = new _ASystemTime();\n\n  @AObjectState time!: number;\n\n  //Whether the clock is paused\n  protected _paused: boolean = true;\n\n  // The time value of the clock is the difference between the current time and refStart.\n  // When the clock is unpaused, refStart remains constant as time progresses, increasing the value of the clock.\n  // When the clock is unpaused after pausing, the time it spent paused will be added to refStart.\n  protected _refStart: number = 0;\n\n  // The time when the clock was last paused or unpaused\n  protected _lastPauseStateChange: number = 0;\n\n  // The time of the last update\n  protected _lastUpdate: number = 0;\n\n  // The current clock's value at the last update\n  protected _lastClockTimeUpdated: number = 0;\n\n  // Offset is used to \"commit\" the passage of time to the clock's memory.\n  // This becomes important if we change the clock's rate, as previous milliseconds may passed at different rates, contributing different amounts to the clock's current value.\n  protected _offset: number = 0;\n\n  // This defines the current rate of the clock in terms of a period.\n  // It can be changed over time to make the clock progress slower or faster.\n  protected _periodInMilliseconds: number =\n    AClockEnums.DEFAULT_PERIOD_IN_MILLISECONDS;\n\n  /** Get set paused */\n  set paused(value: boolean) {\n    this._paused = value;\n  }\n  get paused() {\n    return this._paused;\n  }\n\n  get lastTimeUpdated() {\n    return this._lastClockTimeUpdated;\n  }\n\n  get rate() {\n    return (\n      AClockEnums.DEFAULT_PERIOD_IN_MILLISECONDS / this._periodInMilliseconds\n    );\n  }\n  set rate(v: number) {\n    let now = this._getNow();\n    this._offset = this.time;\n    this._refStart = now;\n    this._periodInMilliseconds = AClockEnums.DEFAULT_PERIOD_IN_MILLISECONDS / v;\n  }\n\n  addTimeListener(callback: (t: number) => any, handle?: string) {\n    const self = this;\n    return this.addStateKeyListener(\n      \"time\",\n      () => {\n        callback(self.time);\n      },\n      handle,\n      false\n    );\n  }\n\n  constructor() {\n    super();\n    this.reset(0);\n    this.initClockSubscription();\n  }\n\n  initClockSubscription() {\n    const self = this;\n    this.subscribe(\n      AClock.SystemTime.addListener((t) => {\n        self.update(t);\n      }),\n      AClockEnums.TIME_UPDATE_SUBSCRIPTION_HANDLE\n    );\n  }\n\n  reset(t0: number = 0) {\n    this.time = t0;\n    this._refStart = t0;\n    this._lastPauseStateChange = t0;\n    this._lastUpdate = t0;\n    this._offset = 0;\n    this._periodInMilliseconds = AClockEnums.DEFAULT_PERIOD_IN_MILLISECONDS;\n    this._paused = true;\n  }\n\n  update(t: number) {\n    if (this._paused) {\n      return;\n    }\n    this.time =\n      this._offset + (t - this._refStart) / this._periodInMilliseconds;\n    this._lastUpdate = t;\n    this._lastClockTimeUpdated = this.time;\n  }\n\n  _getNow() {\n    return Date.now();\n  }\n\n  play() {\n    if (!this.paused) {\n      return;\n    }\n    let now = this._getNow();\n    this._refStart = this._refStart + (now - this._lastPauseStateChange);\n    this._paused = false;\n    this._lastPauseStateChange = now;\n    this.activateSubscription(AClockEnums.TIME_UPDATE_SUBSCRIPTION_HANDLE);\n  }\n\n  pause() {\n    let now = this._getNow();\n    this._paused = true;\n    this._lastPauseStateChange = now;\n    this.deactivateSubscription(AClockEnums.TIME_UPDATE_SUBSCRIPTION_HANDLE);\n  }\n\n  /**\n   * IMPORTANT! If you want to remove the listener at the end of the action\n   * you need to do so in the actionOverCallback!\n   * @param callback\n   * @param duration\n   * @param actionOverCallback\n   * @param tween\n   * @returns {AStateCallbackSwitch}\n   * @constructor\n   */\n  CreateTimedAction(\n    callback: (actionProgress: number) => any,\n    duration: number,\n    actionOverCallback: CallbackType,\n    tween?: BezierTween\n  ) {\n    const self = this;\n    const startTime = this.time;\n    return this.addTimeListener((t: number) => {\n      //calculate how much time has passed\n      let timePassed = t - startTime;\n      // Check to see if the duration has passed\n      if (timePassed > duration) {\n        if (actionOverCallback) {\n          actionOverCallback();\n        }\n        return;\n      }\n      let normalizedTime: number = timePassed / duration;\n      if (tween) {\n        normalizedTime = tween.eval(normalizedTime);\n      }\n      callback(normalizedTime);\n    });\n  }\n}\n\n\nAClock.SystemTime.unpause();\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}