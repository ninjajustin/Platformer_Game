{"ast":null,"code":"import { BufferGeometry, FileLoader, Float32BufferAttribute, Loader, LoaderUtils, Color } from 'three';\n\n/**\n * Description: A THREE loader for PLY ASCII files (known as the Polygon\n * File Format or the Stanford Triangle Format).\n *\n * Limitations: ASCII decoding assumes file is UTF-8.\n *\n * Usage:\n *\tconst loader = new PLYLoader();\n *\tloader.load('./models/ply/ascii/dolphins.ply', function (geometry) {\n *\n *\t\tscene.add( new THREE.Mesh( geometry ) );\n *\n *\t} );\n *\n * If the PLY file uses non standard property names, they can be mapped while\n * loading. For example, the following maps the properties\n * “diffuse_(red|green|blue)” in the file to standard color names.\n *\n * loader.setPropertyNameMapping( {\n *\tdiffuse_red: 'red',\n *\tdiffuse_green: 'green',\n *\tdiffuse_blue: 'blue'\n * } );\n *\n */\n\nconst _color = new Color();\nclass PLYLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.propertyNameMapping = {};\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function (text) {\n      try {\n        onLoad(scope.parse(text));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  setPropertyNameMapping(mapping) {\n    this.propertyNameMapping = mapping;\n  }\n  parse(data) {\n    function parseHeader(data) {\n      const patternHeader = /^ply([\\s\\S]*)end_header(\\r\\n|\\r|\\n)/;\n      let headerText = '';\n      let headerLength = 0;\n      const result = patternHeader.exec(data);\n      if (result !== null) {\n        headerText = result[1];\n        headerLength = new Blob([result[0]]).size;\n      }\n      const header = {\n        comments: [],\n        elements: [],\n        headerLength: headerLength,\n        objInfo: ''\n      };\n      const lines = headerText.split(/\\r\\n|\\r|\\n/);\n      let currentElement;\n      function make_ply_element_property(propertValues, propertyNameMapping) {\n        const property = {\n          type: propertValues[0]\n        };\n        if (property.type === 'list') {\n          property.name = propertValues[3];\n          property.countType = propertValues[1];\n          property.itemType = propertValues[2];\n        } else {\n          property.name = propertValues[1];\n        }\n        if (property.name in propertyNameMapping) {\n          property.name = propertyNameMapping[property.name];\n        }\n        return property;\n      }\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line === '') continue;\n        const lineValues = line.split(/\\s+/);\n        const lineType = lineValues.shift();\n        line = lineValues.join(' ');\n        switch (lineType) {\n          case 'format':\n            header.format = lineValues[0];\n            header.version = lineValues[1];\n            break;\n          case 'comment':\n            header.comments.push(line);\n            break;\n          case 'element':\n            if (currentElement !== undefined) {\n              header.elements.push(currentElement);\n            }\n            currentElement = {};\n            currentElement.name = lineValues[0];\n            currentElement.count = parseInt(lineValues[1]);\n            currentElement.properties = [];\n            break;\n          case 'property':\n            currentElement.properties.push(make_ply_element_property(lineValues, scope.propertyNameMapping));\n            break;\n          case 'obj_info':\n            header.objInfo = line;\n            break;\n          default:\n            console.log('unhandled', lineType, lineValues);\n        }\n      }\n      if (currentElement !== undefined) {\n        header.elements.push(currentElement);\n      }\n      return header;\n    }\n    function parseASCIINumber(n, type) {\n      switch (type) {\n        case 'char':\n        case 'uchar':\n        case 'short':\n        case 'ushort':\n        case 'int':\n        case 'uint':\n        case 'int8':\n        case 'uint8':\n        case 'int16':\n        case 'uint16':\n        case 'int32':\n        case 'uint32':\n          return parseInt(n);\n        case 'float':\n        case 'double':\n        case 'float32':\n        case 'float64':\n          return parseFloat(n);\n      }\n    }\n    function parseASCIIElement(properties, line) {\n      const values = line.split(/\\s+/);\n      const element = {};\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          const list = [];\n          const n = parseASCIINumber(values.shift(), properties[i].countType);\n          for (let j = 0; j < n; j++) {\n            list.push(parseASCIINumber(values.shift(), properties[i].itemType));\n          }\n          element[properties[i].name] = list;\n        } else {\n          element[properties[i].name] = parseASCIINumber(values.shift(), properties[i].type);\n        }\n      }\n      return element;\n    }\n    function parseASCII(data, header) {\n      // PLY ascii format specification, as per http://en.wikipedia.org/wiki/PLY_(file_format)\n\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      let result;\n      const patternBody = /end_header\\s([\\s\\S]*)$/;\n      let body = '';\n      if ((result = patternBody.exec(data)) !== null) {\n        body = result[1];\n      }\n      const lines = body.split(/\\r\\n|\\r|\\n/);\n      let currentElement = 0;\n      let currentElementCount = 0;\n      for (let i = 0; i < lines.length; i++) {\n        let line = lines[i];\n        line = line.trim();\n        if (line === '') {\n          continue;\n        }\n        if (currentElementCount >= header.elements[currentElement].count) {\n          currentElement++;\n          currentElementCount = 0;\n        }\n        const element = parseASCIIElement(header.elements[currentElement].properties, line);\n        handleElement(buffer, header.elements[currentElement].name, element);\n        currentElementCount++;\n      }\n      return postProcess(buffer);\n    }\n    function postProcess(buffer) {\n      let geometry = new BufferGeometry();\n\n      // mandatory buffer data\n\n      if (buffer.indices.length > 0) {\n        geometry.setIndex(buffer.indices);\n      }\n      geometry.setAttribute('position', new Float32BufferAttribute(buffer.vertices, 3));\n\n      // optional buffer data\n\n      if (buffer.normals.length > 0) {\n        geometry.setAttribute('normal', new Float32BufferAttribute(buffer.normals, 3));\n      }\n      if (buffer.uvs.length > 0) {\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.uvs, 2));\n      }\n      if (buffer.colors.length > 0) {\n        geometry.setAttribute('color', new Float32BufferAttribute(buffer.colors, 3));\n      }\n      if (buffer.faceVertexUvs.length > 0) {\n        geometry = geometry.toNonIndexed();\n        geometry.setAttribute('uv', new Float32BufferAttribute(buffer.faceVertexUvs, 2));\n      }\n      geometry.computeBoundingSphere();\n      return geometry;\n    }\n    function handleElement(buffer, elementName, element) {\n      function findAttrName(names) {\n        for (let i = 0, l = names.length; i < l; i++) {\n          const name = names[i];\n          if (name in element) return name;\n        }\n        return null;\n      }\n      const attrX = findAttrName(['x', 'px', 'posx']) || 'x';\n      const attrY = findAttrName(['y', 'py', 'posy']) || 'y';\n      const attrZ = findAttrName(['z', 'pz', 'posz']) || 'z';\n      const attrNX = findAttrName(['nx', 'normalx']);\n      const attrNY = findAttrName(['ny', 'normaly']);\n      const attrNZ = findAttrName(['nz', 'normalz']);\n      const attrS = findAttrName(['s', 'u', 'texture_u', 'tx']);\n      const attrT = findAttrName(['t', 'v', 'texture_v', 'ty']);\n      const attrR = findAttrName(['red', 'diffuse_red', 'r', 'diffuse_r']);\n      const attrG = findAttrName(['green', 'diffuse_green', 'g', 'diffuse_g']);\n      const attrB = findAttrName(['blue', 'diffuse_blue', 'b', 'diffuse_b']);\n      if (elementName === 'vertex') {\n        buffer.vertices.push(element[attrX], element[attrY], element[attrZ]);\n        if (attrNX !== null && attrNY !== null && attrNZ !== null) {\n          buffer.normals.push(element[attrNX], element[attrNY], element[attrNZ]);\n        }\n        if (attrS !== null && attrT !== null) {\n          buffer.uvs.push(element[attrS], element[attrT]);\n        }\n        if (attrR !== null && attrG !== null && attrB !== null) {\n          _color.setRGB(element[attrR] / 255.0, element[attrG] / 255.0, element[attrB] / 255.0).convertSRGBToLinear();\n          buffer.colors.push(_color.r, _color.g, _color.b);\n        }\n      } else if (elementName === 'face') {\n        const vertex_indices = element.vertex_indices || element.vertex_index; // issue #9338\n        const texcoord = element.texcoord;\n        if (vertex_indices.length === 3) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[2]);\n          if (texcoord && texcoord.length === 6) {\n            buffer.faceVertexUvs.push(texcoord[0], texcoord[1]);\n            buffer.faceVertexUvs.push(texcoord[2], texcoord[3]);\n            buffer.faceVertexUvs.push(texcoord[4], texcoord[5]);\n          }\n        } else if (vertex_indices.length === 4) {\n          buffer.indices.push(vertex_indices[0], vertex_indices[1], vertex_indices[3]);\n          buffer.indices.push(vertex_indices[1], vertex_indices[2], vertex_indices[3]);\n        }\n      }\n    }\n    function binaryRead(dataview, at, type, little_endian) {\n      switch (type) {\n        // corespondences for non-specific length types here match rply:\n        case 'int8':\n        case 'char':\n          return [dataview.getInt8(at), 1];\n        case 'uint8':\n        case 'uchar':\n          return [dataview.getUint8(at), 1];\n        case 'int16':\n        case 'short':\n          return [dataview.getInt16(at, little_endian), 2];\n        case 'uint16':\n        case 'ushort':\n          return [dataview.getUint16(at, little_endian), 2];\n        case 'int32':\n        case 'int':\n          return [dataview.getInt32(at, little_endian), 4];\n        case 'uint32':\n        case 'uint':\n          return [dataview.getUint32(at, little_endian), 4];\n        case 'float32':\n        case 'float':\n          return [dataview.getFloat32(at, little_endian), 4];\n        case 'float64':\n        case 'double':\n          return [dataview.getFloat64(at, little_endian), 8];\n      }\n    }\n    function binaryReadElement(dataview, at, properties, little_endian) {\n      const element = {};\n      let result,\n        read = 0;\n      for (let i = 0; i < properties.length; i++) {\n        if (properties[i].type === 'list') {\n          const list = [];\n          result = binaryRead(dataview, at + read, properties[i].countType, little_endian);\n          const n = result[0];\n          read += result[1];\n          for (let j = 0; j < n; j++) {\n            result = binaryRead(dataview, at + read, properties[i].itemType, little_endian);\n            list.push(result[0]);\n            read += result[1];\n          }\n          element[properties[i].name] = list;\n        } else {\n          result = binaryRead(dataview, at + read, properties[i].type, little_endian);\n          element[properties[i].name] = result[0];\n          read += result[1];\n        }\n      }\n      return [element, read];\n    }\n    function parseBinary(data, header) {\n      const buffer = {\n        indices: [],\n        vertices: [],\n        normals: [],\n        uvs: [],\n        faceVertexUvs: [],\n        colors: []\n      };\n      const little_endian = header.format === 'binary_little_endian';\n      const body = new DataView(data, header.headerLength);\n      let result,\n        loc = 0;\n      for (let currentElement = 0; currentElement < header.elements.length; currentElement++) {\n        for (let currentElementCount = 0; currentElementCount < header.elements[currentElement].count; currentElementCount++) {\n          result = binaryReadElement(body, loc, header.elements[currentElement].properties, little_endian);\n          loc += result[1];\n          const element = result[0];\n          handleElement(buffer, header.elements[currentElement].name, element);\n        }\n      }\n      return postProcess(buffer);\n    }\n\n    //\n\n    let geometry;\n    const scope = this;\n    if (data instanceof ArrayBuffer) {\n      const text = LoaderUtils.decodeText(new Uint8Array(data));\n      const header = parseHeader(text);\n      geometry = header.format === 'ascii' ? parseASCII(text, header) : parseBinary(data, header);\n    } else {\n      geometry = parseASCII(data, parseHeader(data));\n    }\n    return geometry;\n  }\n}\nexport { PLYLoader };","map":null,"metadata":{},"sourceType":"module"}