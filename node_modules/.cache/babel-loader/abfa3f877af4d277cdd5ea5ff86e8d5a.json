{"ast":null,"code":"var _dec, _class;\nimport { ASerializable } from \"../../base\";\nimport { V3, Vec3, Mat4, V4, Quaternion } from \"../linalg\";\nimport { Precision } from \"../Precision\";\nimport { NodeTransform2D } from \"./NodeTransform2D\";\nexport let NodeTransform3D = (_dec = ASerializable(\"NodeTransform3D\"), _dec(_class = class NodeTransform3D {\n  get scale() {\n    return this._scale;\n  }\n  set scale(value) {\n    if (value instanceof Vec3) {\n      this._scale = value;\n    } else {\n      this._scale = new Vec3(value, value, value);\n    }\n  }\n  constructor() {\n    this.position = void 0;\n    this.anchor = void 0;\n    this._scale = void 0;\n    this.rotation = void 0;\n    if ((arguments.length <= 0 ? undefined : arguments[0]) instanceof Mat4) {\n      let pos = arguments.length > 1 ? arguments.length <= 1 ? undefined : arguments[1] : undefined;\n      let rotation = arguments.length > 2 ? arguments.length <= 2 ? undefined : arguments[2] : undefined;\n      this.setWithMatrix(arguments.length <= 0 ? undefined : arguments[0], pos, rotation);\n      if (!this.position) {\n        this.position = new Vec3(0, 0, 0);\n      }\n    } else {\n      var _ref, _ref2, _ref3, _ref4;\n      this.position = arguments.length > 0 ? (_ref = arguments.length <= 0 ? undefined : arguments[0]) !== null && _ref !== void 0 ? _ref : new Vec3(0, 0, 0) : new Vec3(0, 0, 0);\n      this.rotation = arguments.length > 1 ? (_ref2 = arguments.length <= 1 ? undefined : arguments[1]) !== null && _ref2 !== void 0 ? _ref2 : new Quaternion() : new Quaternion();\n      this.scale = arguments.length > 2 ? (_ref3 = arguments.length <= 2 ? undefined : arguments[2]) !== null && _ref3 !== void 0 ? _ref3 : new Vec3(1, 1, 1) : new Vec3(1, 1, 1);\n      this.anchor = arguments.length > 3 ? (_ref4 = arguments.length <= 3 ? undefined : arguments[3]) !== null && _ref4 !== void 0 ? _ref4 : new Vec3(0, 0, 0) : new Vec3(0, 0, 0);\n    }\n  }\n  getPosition() {\n    return this.position;\n  }\n  _getQuaternionRotation() {\n    return this.rotation;\n  }\n  _setQuaternionRotation(q) {\n    this.rotation = q;\n  }\n  setPosition(position) {\n    this.position = position;\n  }\n  clone() {\n    return new NodeTransform3D(this.position.clone(), this.rotation.clone(), this.scale.clone(), this.anchor.clone());\n  }\n  NodeTransform3D() {\n    return this.clone();\n  }\n  static FromPoseMatrix(mat) {\n    let translation = mat.c3;\n    let rotationM = mat.clone();\n    rotationM.c3 = V4(0, 0, 0, 1);\n    let rotationQ = Quaternion.FromMatrix(rotationM);\n    return new NodeTransform3D(translation.Point3D, rotationQ);\n  }\n  appliedToPoint(p) {\n    return this.getMat4().times(p.Point3DH).Point3D;\n  }\n  times(other) {\n    // @ts-ignore\n    return this.getMat4().times(other);\n  }\n\n  /**\n   * Returns the transformation matrix for this set of transform properties.\n   *\n   * @returns the transformation matrix\n   */\n  getMatrix() {\n    // return Mat4.Translation3D(this.position)\n    //     .times(this.rotation.Mat4())\n    //     .times(Mat4.Scale3D(this.scale))\n    //     .times(Mat4.Translation3D(this.anchor.times(-1)));\n\n    let P = Mat4.Translation3D(this.position);\n    let R = this.rotation.Mat4();\n    let S = Mat4.Scale3D(this.scale);\n    let A = Mat4.Translation3D(this.anchor.times(-1));\n    return P.times(R).times(S).times(A);\n    // let m = new Matrix4();\n    // m.compose(this.position.asThreeJS(),this.rotation, this.scale.asThreeJS());\n    // let mobj = Mat4.FromThreeJS(m).getTranspose();\n    // const anchor = Mat4.Translation3D(this.anchor.times(-1));\n    // return mobj.times(anchor);\n  }\n\n  assignTo(threejsMat) {\n    this.getMat4().assignTo(threejsMat);\n  }\n  getMat4() {\n    return this.getMatrix();\n  }\n  static PoseProduct(lhs, rhs) {\n    let nt = lhs.rotation.appliedTo(rhs.position).plus(lhs.position);\n    let nr = lhs.rotation.times(rhs.rotation);\n    return new NodeTransform3D(nt, nr);\n  }\n  getInverse() {\n    let inv = new NodeTransform3D();\n    inv.scale = V3(1 / this.scale.x, 1 / this.scale.y, 1 / this.scale.z);\n    inv.rotation = this.rotation.getInverse();\n    inv.position = inv.rotation.appliedTo(this.position.times(-1)).timesElementWise(inv.scale);\n    return inv;\n  }\n  getRightMultipliedByRotation(r) {\n    return new NodeTransform3D(this.position.clone(), this.rotation.times(r));\n  }\n  getLeftMultipliedByRotation(r) {\n    return new NodeTransform3D(r.appliedTo(this.position), r.times(this.rotation));\n  }\n  NodeTransform2D(cameraMatrix) {\n    let P = cameraMatrix ? cameraMatrix : Mat4.Identity();\n    let thisxvec = P.times(this.rotation.Mat4().c0);\n    let p3d = P.times(this.position.Point3DH).Point3D;\n    // let thisM = this.getMat4();\n    return new NodeTransform2D(p3d.XY, Math.atan2(thisxvec.y, thisxvec.x), this.scale.XY, this.anchor.XY);\n  }\n\n  /**\n   * Sets the transform properties based on the given affine transformation\n   * matrix and optional position.\n   *\n   * This function should set the transform based on an input matrix and\n   * (optionally) a starting position. Calling T.getMatrix() on the resulting\n   * transform should produce the input matrix `m`. Position should\n   * be the point where changes to rotation or scale will rotate and scale around.\n   * Meanings of position, rotation, scale, and anchor match those used in Adobe\n   * standards (e.g., After Effects). The corresponding matrix is calculated\n   * as shown in getMatrix() above: (P)*(R)*(S)*(-A). Position is specified as\n   * a constraint because the two translations in the above equation create a\n   * redundancy.\n   *\n   * We recommend familiarizing yourself with the available methods in\n   * `src/anigraph/amath/Mat3.ts`.\n   *\n   * Also familiarize yourself with the available functions in\n   * `src/anigraph/amath/Precision.ts`. These are useful when dealing with\n   * floating point inaccuracies and other small numbers.\n   *\n   * Note: do not let the scale factor be less than epsilon.\n   *\n   * @param m the affine transformation matrix\n   * @param position the starting positon\n   */\n  setWithMatrix(m, position, rotation) {\n    if (position !== undefined) {\n      this.position = position;\n    }\n    if (rotation) {\n      this.rotation = rotation;\n    } else {\n      this.rotation = Quaternion.FromMatrix(m);\n    }\n    let PRSA = m;\n    let RSA = Mat4.Translation3D(this.position.times(-1)).times(PRSA);\n    let rmat = this.rotation.Mat4();\n    let rimat = rmat.getInverse();\n    const SA = rimat.times(RSA);\n    this.scale = new Vec3(Precision.ClampAbsAboveEpsilon(SA.m00), Precision.ClampAbsAboveEpsilon(SA.m11), Precision.ClampAbsAboveEpsilon(SA.m22));\n    let P = Mat4.Translation3D(this.position);\n    let R = rmat.clone();\n    let S = Mat4.Scale3D(this.scale);\n    let PRS = P.times(R).times(S);\n    let PRSinv = PRS.getInverse();\n    if (PRSinv === null) {\n      throw new Error(`tried to set transform with matrix that has zero determinant: ${m}`);\n      return;\n    }\n    this.anchor = PRSinv.times(m).c3.Point3D.times(-1);\n  }\n  static LookAt(location, target, up) {\n    let position = location;\n    let look = target.minus(location).getNormalized();\n    return new NodeTransform3D(position, Quaternion.FromCameraOrientationVectors(look, up));\n\n    // Leaving the code below for reference -- students can ignore\n\n    // let look = target.minus(location);\n    // let zneg = look.getNormalized().times(-1);\n    // let r = zneg.cross(up).getNormalized();\n    // let upn = zneg.cross(r)\n    // let M = Mat4.FromColumns(\n    //     r.Vec3DH,\n    //     upn.Vec3DH,\n    //     zneg.Vec3DH,\n    //     location.Point3DH\n    // )\n    // could extract scale here\n    // let position = location;\n    // let R = Mat4.FromColumns(M.r0, M.r1,M.r2,V4(0,0,0,1));\n    // let rotation = Quaternion.FromMatrix(R);\n    // return new NodeTransform3D(position, rotation);\n  }\n\n  static FromPositionZUpAndScale(position, z, up, scale) {\n    return new NodeTransform3D(position, Quaternion.FromZAndUp(z, up), scale);\n  }\n  static PointToward(location, target, up) {\n    let position = location;\n    let look = location.minus(target).getNormalized();\n    return new NodeTransform3D(position, Quaternion.FromCameraOrientationVectors(look, up));\n  }\n  static RotationZ(radians) {\n    return new NodeTransform3D(new Vec3(0, 0, 0), Quaternion.RotationZ(radians));\n  }\n  static FromMatrix(mat, position, rotation) {\n    let T = new NodeTransform3D();\n    T.setWithMatrix(mat, position, rotation);\n    return T;\n  }\n  static FromThreeJSObject(obj) {\n    return new NodeTransform3D(Vec3.FromThreeJS(obj.position), Quaternion.FromQuaternion(obj.quaternion), Vec3.FromThreeJS(obj.scale));\n  }\n  assignToObject3DPose(obj) {\n    obj.position.set(this.position.x, this.position.y, this.position.z);\n    obj.quaternion.set(this.rotation.x, this.rotation.y, this.rotation.z, this.rotation.w);\n    obj.scale.set(this.scale.x, this.scale.y, this.scale.z);\n    this.getMatrix().assignTo(obj.matrix);\n  }\n  getObjectSpaceOrigin() {\n    return this.getMatrix().times(V4(0, 0, 0, 1)).getHomogenized().Point3D;\n  }\n}) || _class);","map":{"version":3,"names":["ASerializable","V3","Vec3","Mat4","V4","Quaternion","Precision","NodeTransform2D","NodeTransform3D","scale","_scale","value","constructor","position","anchor","rotation","pos","length","undefined","setWithMatrix","getPosition","_getQuaternionRotation","_setQuaternionRotation","q","setPosition","clone","FromPoseMatrix","mat","translation","c3","rotationM","rotationQ","FromMatrix","Point3D","appliedToPoint","p","getMat4","times","Point3DH","other","getMatrix","P","Translation3D","R","S","Scale3D","A","assignTo","threejsMat","PoseProduct","lhs","rhs","nt","appliedTo","plus","nr","getInverse","inv","x","y","z","timesElementWise","getRightMultipliedByRotation","r","getLeftMultipliedByRotation","cameraMatrix","Identity","thisxvec","c0","p3d","XY","Math","atan2","m","PRSA","RSA","rmat","rimat","SA","ClampAbsAboveEpsilon","m00","m11","m22","PRS","PRSinv","Error","LookAt","location","target","up","look","minus","getNormalized","FromCameraOrientationVectors","FromPositionZUpAndScale","FromZAndUp","PointToward","RotationZ","radians","T","FromThreeJSObject","obj","FromThreeJS","FromQuaternion","quaternion","assignToObject3DPose","set","w","matrix","getObjectSpaceOrigin","getHomogenized"],"sources":["/Users/home/Desktop/cs4620-final-project/src/anigraph/math/nodetransforms/NodeTransform3D.ts"],"sourcesContent":["import * as THREE from \"three\";\nimport { ASerializable } from \"../../base\";\nimport { NodeTransform } from \"./NodeTransform\";\nimport {V3, Vec3, Mat4, V4, Quaternion, Vec4} from \"../linalg\";\nimport { Precision } from \"../Precision\";\nimport { NodeTransform2D } from \"./NodeTransform2D\";\nimport {Color} from \"../Color\";\n\n@ASerializable(\"NodeTransform3D\")\nexport class NodeTransform3D implements NodeTransform<Vec3, Mat4> {\n  public position!: Vec3;\n  public anchor!: Vec3;\n  public _scale!: Vec3;\n  public rotation!: Quaternion;\n\n  get scale(): Vec3 {\n    return this._scale;\n  }\n  set scale(value: Vec3 | number) {\n    if (value instanceof Vec3) {\n      this._scale = value;\n    } else {\n      this._scale = new Vec3(value, value, value);\n    }\n  }\n\n  constructor(\n    position?: Vec3,\n    rotation?: Quaternion,\n    scale?: Vec3|number,\n    anchor?: Vec3\n  );\n  constructor(matrix: Mat4, position?: Vec3, rotation?: Quaternion);\n  constructor(...args: any[]) {\n    if (args[0] instanceof Mat4) {\n      let pos = args.length > 1 ? args[1] : undefined;\n      let rotation = args.length > 2 ? args[2] : undefined;\n      this.setWithMatrix(args[0], pos, rotation);\n      if (!this.position) {\n        this.position = new Vec3(0, 0, 0);\n      }\n    } else {\n      this.position = args.length > 0 ? args[0]??new Vec3(0, 0, 0) : new Vec3(0, 0, 0);\n      this.rotation = args.length > 1 ? args[1]??new Quaternion() : new Quaternion();\n      this.scale = args.length > 2 ? args[2]??new Vec3(1, 1, 1) : new Vec3(1, 1, 1);\n      this.anchor = args.length > 3 ? args[3]??new Vec3(0, 0, 0) : new Vec3(0, 0, 0);\n    }\n  }\n\n\n  getPosition(): Vec3 {\n    return this.position;\n  }\n  _getQuaternionRotation(): Quaternion {\n    return this.rotation;\n  }\n  _setQuaternionRotation(q: Quaternion): void {\n    this.rotation = q;\n  }\n  setPosition(position: Vec3): void {\n    this.position = position;\n  }\n\n  clone() {\n    return new NodeTransform3D(\n      this.position.clone(),\n      this.rotation.clone(),\n      this.scale.clone(),\n      this.anchor.clone()\n    );\n  }\n\n  NodeTransform3D() {\n    return this.clone();\n  }\n\n  static FromPoseMatrix(mat: Mat4) {\n    let translation = mat.c3;\n    let rotationM = mat.clone();\n    rotationM.c3 = V4(0, 0, 0, 1);\n    let rotationQ = Quaternion.FromMatrix(rotationM);\n    return new NodeTransform3D(translation.Point3D, rotationQ);\n  }\n\n\n  appliedToPoint(p:Vec3){\n    return this.getMat4().times(p.Point3DH).Point3D;\n  }\n\n  times(other:Vec4):Vec4;\n  times(other:Mat4):Mat4;\n  times(other:Vec4|Mat4|number):Vec4|Mat4{\n    // @ts-ignore\n    return this.getMat4().times(other);\n  }\n\n\n  /**\n   * Returns the transformation matrix for this set of transform properties.\n   *\n   * @returns the transformation matrix\n   */\n  getMatrix() {\n    // return Mat4.Translation3D(this.position)\n    //     .times(this.rotation.Mat4())\n    //     .times(Mat4.Scale3D(this.scale))\n    //     .times(Mat4.Translation3D(this.anchor.times(-1)));\n\n    let P = Mat4.Translation3D(this.position);\n    let R = this.rotation.Mat4();\n    let S = Mat4.Scale3D(this.scale);\n    let A = Mat4.Translation3D(this.anchor.times(-1));\n    return P.times(R).times(S).times(A);\n    // let m = new Matrix4();\n    // m.compose(this.position.asThreeJS(),this.rotation, this.scale.asThreeJS());\n    // let mobj = Mat4.FromThreeJS(m).getTranspose();\n    // const anchor = Mat4.Translation3D(this.anchor.times(-1));\n    // return mobj.times(anchor);\n  }\n\n  assignTo(threejsMat: THREE.Matrix4) {\n    this.getMat4().assignTo(threejsMat);\n  }\n\n  getMat4(): Mat4 {\n    return this.getMatrix();\n  }\n\n  static PoseProduct(lhs: NodeTransform3D, rhs: NodeTransform3D) {\n    let nt = lhs.rotation.appliedTo(rhs.position).plus(lhs.position);\n    let nr = lhs.rotation.times(rhs.rotation);\n    return new NodeTransform3D(nt, nr);\n  }\n\n  getInverse() {\n    let inv = new NodeTransform3D();\n    inv.scale = V3(1 / this.scale.x, 1 / this.scale.y, 1 / this.scale.z);\n    inv.rotation = this.rotation.getInverse();\n    inv.position = inv.rotation\n      .appliedTo(this.position.times(-1))\n      .timesElementWise(inv.scale);\n    return inv;\n  }\n\n  getRightMultipliedByRotation(r: Quaternion) {\n    return new NodeTransform3D(this.position.clone(), this.rotation.times(r));\n  }\n\n  getLeftMultipliedByRotation(r: Quaternion) {\n    return new NodeTransform3D(\n      r.appliedTo(this.position),\n      r.times(this.rotation)\n    );\n  }\n\n  NodeTransform2D(cameraMatrix?: Mat4) {\n    let P = cameraMatrix ? cameraMatrix : Mat4.Identity();\n    let thisxvec = P.times(this.rotation.Mat4().c0);\n    let p3d = P.times(this.position.Point3DH).Point3D;\n    // let thisM = this.getMat4();\n    return new NodeTransform2D(\n      p3d.XY,\n      Math.atan2(thisxvec.y, thisxvec.x),\n      this.scale.XY,\n      this.anchor.XY\n    );\n  }\n\n  /**\n   * Sets the transform properties based on the given affine transformation\n   * matrix and optional position.\n   *\n   * This function should set the transform based on an input matrix and\n   * (optionally) a starting position. Calling T.getMatrix() on the resulting\n   * transform should produce the input matrix `m`. Position should\n   * be the point where changes to rotation or scale will rotate and scale around.\n   * Meanings of position, rotation, scale, and anchor match those used in Adobe\n   * standards (e.g., After Effects). The corresponding matrix is calculated\n   * as shown in getMatrix() above: (P)*(R)*(S)*(-A). Position is specified as\n   * a constraint because the two translations in the above equation create a\n   * redundancy.\n   *\n   * We recommend familiarizing yourself with the available methods in\n   * `src/anigraph/amath/Mat3.ts`.\n   *\n   * Also familiarize yourself with the available functions in\n   * `src/anigraph/amath/Precision.ts`. These are useful when dealing with\n   * floating point inaccuracies and other small numbers.\n   *\n   * Note: do not let the scale factor be less than epsilon.\n   *\n   * @param m the affine transformation matrix\n   * @param position the starting positon\n   */\n  setWithMatrix(m: Mat4, position?: Vec3, rotation?: Quaternion) {\n    if (position !== undefined) {\n      this.position = position;\n    }\n    if (rotation) {\n      this.rotation = rotation;\n    } else {\n      this.rotation = Quaternion.FromMatrix(m);\n    }\n\n    let PRSA = m;\n    let RSA = Mat4.Translation3D(this.position.times(-1)).times(PRSA);\n    let rmat = this.rotation.Mat4();\n    let rimat = rmat.getInverse();\n\n    const SA = rimat.times(RSA);\n    this.scale = new Vec3(\n      Precision.ClampAbsAboveEpsilon(SA.m00),\n      Precision.ClampAbsAboveEpsilon(SA.m11),\n      Precision.ClampAbsAboveEpsilon(SA.m22)\n    );\n\n    let P = Mat4.Translation3D(this.position);\n    let R = rmat.clone();\n    let S = Mat4.Scale3D(this.scale);\n    let PRS = P.times(R).times(S);\n    let PRSinv = PRS.getInverse();\n\n    if (PRSinv === null) {\n      throw new Error(\n        `tried to set transform with matrix that has zero determinant: ${m}`\n      );\n      return;\n    }\n    this.anchor = PRSinv.times(m).c3.Point3D.times(-1);\n  }\n\n  static LookAt(location: Vec3, target: Vec3, up: Vec3) {\n    let position = location;\n    let look = target.minus(location).getNormalized();\n    return new NodeTransform3D(position, Quaternion.FromCameraOrientationVectors(look, up));\n\n    // Leaving the code below for reference -- students can ignore\n\n    // let look = target.minus(location);\n    // let zneg = look.getNormalized().times(-1);\n    // let r = zneg.cross(up).getNormalized();\n    // let upn = zneg.cross(r)\n    // let M = Mat4.FromColumns(\n    //     r.Vec3DH,\n    //     upn.Vec3DH,\n    //     zneg.Vec3DH,\n    //     location.Point3DH\n    // )\n    // could extract scale here\n    // let position = location;\n    // let R = Mat4.FromColumns(M.r0, M.r1,M.r2,V4(0,0,0,1));\n    // let rotation = Quaternion.FromMatrix(R);\n    // return new NodeTransform3D(position, rotation);\n  }\n\n  static FromPositionZUpAndScale(position: Vec3, z: Vec3, up: Vec3, scale:Vec3|number) {\n    return new NodeTransform3D(position, Quaternion.FromZAndUp(z, up), scale);\n  }\n\n\n  static PointToward(location: Vec3, target: Vec3, up: Vec3) {\n    let position = location;\n    let look = location.minus(target).getNormalized();\n    return new NodeTransform3D(position, Quaternion.FromCameraOrientationVectors(look, up));\n  }\n\n  static RotationZ(radians: number) {\n    return new NodeTransform3D(\n      new Vec3(0, 0, 0),\n      Quaternion.RotationZ(radians)\n    );\n  }\n\n  static FromMatrix(mat: Mat4, position?: Vec3, rotation?: Quaternion) {\n    let T = new NodeTransform3D();\n    T.setWithMatrix(mat, position, rotation);\n    return T;\n  }\n\n  static FromThreeJSObject(obj: THREE.Object3D) {\n    return new NodeTransform3D(\n      Vec3.FromThreeJS(obj.position),\n      Quaternion.FromQuaternion(obj.quaternion),\n      Vec3.FromThreeJS(obj.scale)\n    );\n  }\n\n  assignToObject3DPose(obj: THREE.Object3D) {\n    obj.position.set(this.position.x, this.position.y, this.position.z);\n    obj.quaternion.set(\n      this.rotation.x,\n      this.rotation.y,\n      this.rotation.z,\n      this.rotation.w\n    );\n    obj.scale.set(this.scale.x, this.scale.y, this.scale.z);\n    this.getMatrix().assignTo(obj.matrix);\n  }\n\n  getObjectSpaceOrigin() {\n    return this.getMatrix().times(V4(0, 0, 0, 1)).getHomogenized().Point3D;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}