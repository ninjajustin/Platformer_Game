{"ast":null,"code":"import { Precision } from \"../\";\nexport class BoundingBox {\n  constructor() {\n    this.minPoint = void 0;\n    this.maxPoint = void 0;\n    this.transform = void 0;\n    for (var _len = arguments.length, points = new Array(_len), _key = 0; _key < _len; _key++) {\n      points[_key] = arguments[_key];\n    }\n    if (points !== undefined) {\n      for (let p of points) {\n        this.boundPoint(p);\n      }\n    }\n  }\n  reset() {\n    this.minPoint = undefined;\n    this.maxPoint = undefined;\n  }\n  pointInBounds(p, epsilon) {\n    if (!this.minPoint || !this.maxPoint) {\n      return false;\n    }\n    if (epsilon === undefined) {\n      epsilon = Precision.epsilon;\n    }\n    let ndim = p.nDimensions;\n    for (let c = 0; c < ndim; c++) {\n      if (p.elements[c] < this.minPoint.elements[c] || p.elements[c] > this.maxPoint.elements[c]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * BoundPoint should adapt our bounds to include a new point should that point be outside of the current bounds.\n   * @param p\n   */\n  boundPoint(p) {\n    if (!this.minPoint || !this.maxPoint) {\n      this.minPoint = p.clone();\n      this.maxPoint = p.clone();\n      return;\n    }\n    let ndim = this.minPoint.nDimensions;\n    for (let c = 0; c < ndim; c++) {\n      if (p.elements[c] < this.minPoint.elements[c]) {\n        this.minPoint.elements[c] = p.elements[c];\n      }\n      if (p.elements[c] > this.maxPoint.elements[c]) {\n        this.maxPoint.elements[c] = p.elements[c];\n      }\n    }\n  }\n}","map":{"version":3,"names":["Precision","BoundingBox","constructor","minPoint","maxPoint","transform","points","undefined","p","boundPoint","reset","pointInBounds","epsilon","ndim","nDimensions","c","elements","clone"],"sources":["/Users/home/Desktop/cs4620-final-project/src/anigraph/geometry/BoundingBox.ts"],"sourcesContent":["import { Precision } from \"../\";\nimport { VectorBase} from \"../\";\nimport { TransformationInterface} from \"../\";\n\nexport abstract class BoundingBox<\n  VertexType extends VectorBase,\n  TransformType extends TransformationInterface\n> {\n  public minPoint!: VertexType | undefined;\n  public maxPoint!: VertexType | undefined;\n  public transform!: TransformType;\n  abstract get center(): VertexType | undefined;\n  abstract get corners(): VertexType[];\n  abstract clone(): this;\n\n  abstract randomTransformedPoint(): VertexType;\n\n  constructor(...points: Array<VertexType>) {\n    if (points !== undefined) {\n      for (let p of points) {\n        this.boundPoint(p);\n      }\n    }\n  }\n\n  reset() {\n    this.minPoint = undefined;\n    this.maxPoint = undefined;\n  }\n\n  pointInBounds(p: VertexType, epsilon?: number): boolean {\n    if (!this.minPoint || !this.maxPoint) {\n      return false;\n    }\n    if (epsilon === undefined) {\n      epsilon = Precision.epsilon;\n    }\n\n    let ndim: number = p.nDimensions;\n    for (let c = 0; c < ndim; c++) {\n      if (\n        p.elements[c] < this.minPoint.elements[c] ||\n        p.elements[c] > this.maxPoint.elements[c]\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * BoundPoint should adapt our bounds to include a new point should that point be outside of the current bounds.\n   * @param p\n   */\n  public boundPoint(p: VertexType): void {\n    if (!this.minPoint || !this.maxPoint) {\n      this.minPoint = p.clone();\n      this.maxPoint = p.clone();\n      return;\n    }\n    let ndim: number = this.minPoint.nDimensions;\n    for (let c = 0; c < ndim; c++) {\n      if (p.elements[c] < this.minPoint.elements[c]) {\n        this.minPoint.elements[c] = p.elements[c];\n      }\n      if (p.elements[c] > this.maxPoint.elements[c]) {\n        this.maxPoint.elements[c] = p.elements[c];\n      }\n    }\n  }\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,KAAK;AAI/B,OAAO,MAAeC,WAAW,CAG/B;EAUAC,WAAW,GAA+B;IAAA,KATnCC,QAAQ;IAAA,KACRC,QAAQ;IAAA,KACRC,SAAS;IAAA,kCAODC,MAAM;MAANA,MAAM;IAAA;IACnB,IAAIA,MAAM,KAAKC,SAAS,EAAE;MACxB,KAAK,IAAIC,CAAC,IAAIF,MAAM,EAAE;QACpB,IAAI,CAACG,UAAU,CAACD,CAAC,CAAC;MACpB;IACF;EACF;EAEAE,KAAK,GAAG;IACN,IAAI,CAACP,QAAQ,GAAGI,SAAS;IACzB,IAAI,CAACH,QAAQ,GAAGG,SAAS;EAC3B;EAEAI,aAAa,CAACH,CAAa,EAAEI,OAAgB,EAAW;IACtD,IAAI,CAAC,IAAI,CAACT,QAAQ,IAAI,CAAC,IAAI,CAACC,QAAQ,EAAE;MACpC,OAAO,KAAK;IACd;IACA,IAAIQ,OAAO,KAAKL,SAAS,EAAE;MACzBK,OAAO,GAAGZ,SAAS,CAACY,OAAO;IAC7B;IAEA,IAAIC,IAAY,GAAGL,CAAC,CAACM,WAAW;IAChC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,EAAEE,CAAC,EAAE,EAAE;MAC7B,IACEP,CAAC,CAACQ,QAAQ,CAACD,CAAC,CAAC,GAAG,IAAI,CAACZ,QAAQ,CAACa,QAAQ,CAACD,CAAC,CAAC,IACzCP,CAAC,CAACQ,QAAQ,CAACD,CAAC,CAAC,GAAG,IAAI,CAACX,QAAQ,CAACY,QAAQ,CAACD,CAAC,CAAC,EACzC;QACA,OAAO,KAAK;MACd;IACF;IACA,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;EACSN,UAAU,CAACD,CAAa,EAAQ;IACrC,IAAI,CAAC,IAAI,CAACL,QAAQ,IAAI,CAAC,IAAI,CAACC,QAAQ,EAAE;MACpC,IAAI,CAACD,QAAQ,GAAGK,CAAC,CAACS,KAAK,EAAE;MACzB,IAAI,CAACb,QAAQ,GAAGI,CAAC,CAACS,KAAK,EAAE;MACzB;IACF;IACA,IAAIJ,IAAY,GAAG,IAAI,CAACV,QAAQ,CAACW,WAAW;IAC5C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,IAAI,EAAEE,CAAC,EAAE,EAAE;MAC7B,IAAIP,CAAC,CAACQ,QAAQ,CAACD,CAAC,CAAC,GAAG,IAAI,CAACZ,QAAQ,CAACa,QAAQ,CAACD,CAAC,CAAC,EAAE;QAC7C,IAAI,CAACZ,QAAQ,CAACa,QAAQ,CAACD,CAAC,CAAC,GAAGP,CAAC,CAACQ,QAAQ,CAACD,CAAC,CAAC;MAC3C;MACA,IAAIP,CAAC,CAACQ,QAAQ,CAACD,CAAC,CAAC,GAAG,IAAI,CAACX,QAAQ,CAACY,QAAQ,CAACD,CAAC,CAAC,EAAE;QAC7C,IAAI,CAACX,QAAQ,CAACY,QAAQ,CAACD,CAAC,CAAC,GAAGP,CAAC,CAACQ,QAAQ,CAACD,CAAC,CAAC;MAC3C;IACF;EACF;AACF"},"metadata":{},"sourceType":"module"}