{"ast":null,"code":"import { A3DModelLoader, ACameraModel, APointLightModel, Color, GetAppState, NodeTransform3D, V3, Vec2, Vec3 } from \"../../../../../anigraph\";\nimport { BaseSceneModel, CharacterModel } from \"../../../../BaseClasses\";\nimport { BotModel, ExampleParticleSystemModel, ExampleThreeJSNodeModel, SphereParticle, TerrainModel } from \"../../../Nodes\";\nimport { ATexture } from \"../../../../../anigraph/rendering/ATexture\";\nimport { AppConfigs } from \"../../../../AppConfigs\";\nimport { ExampleLoadedCharacterModel } from \"../../../Nodes/Loaded/ExampleLoadedCharacterModel\";\nimport { ABasicShaderModel } from \"../../../../../anigraph/rendering/shadermodels/ABasicShaderModel\";\nimport { AddStandardUniforms } from \"../HowToAddUniformToControlPanel\";\nimport { BillboardParticleSystemModel } from \"../../../Nodes/BillboardParticleSystem\";\n// import {AddStandardUniforms} from \"../HowToAddUniformToControlPanel\";\n\nlet appState = GetAppState();\n\n/**\n * Here we will define some enums that are simple strings.\n * These will be what we call different shader model instances. Note that we could just type these strings directly into\n * the code when we use them, but defining them as an enum will help avoid bugs caused by typos, and it will let you use\n * refactoring features of your IDE if you want to change these variables later.\n */\nvar MyMaterialNames;\n(function (MyMaterialNames) {\n  MyMaterialNames[\"basicshader1\"] = \"basicshader1\";\n  MyMaterialNames[\"mymaterial2\"] = \"mymaterial2\";\n})(MyMaterialNames || (MyMaterialNames = {}));\nexport class Example1SceneModel extends BaseSceneModel {\n  constructor() {\n    super(...arguments);\n    this.terrain = void 0;\n    this._player = void 0;\n    this.loaded3DModel = void 0;\n    this.playerMaterial = void 0;\n    this.catModel = void 0;\n    this.catTexture = void 0;\n    this.bots = [];\n    this.billboardParticles = void 0;\n  }\n  get player() {\n    return this._player;\n  }\n  set player(v) {\n    this._player = v;\n  }\n  async loadModelFromFile(path, transform) {\n    /**\n     * Here we need to load the .ply file into an AObject3DModelWrapper instance\n     */\n    let meshObject = await A3DModelLoader.LoadFromPath(path);\n    meshObject.sourceTransform = transform !== null && transform !== void 0 ? transform : new NodeTransform3D();\n    return meshObject;\n  }\n  async PreloadAssets() {\n    await super.PreloadAssets();\n    await TerrainModel.LoadShader();\n    await CharacterModel.LoadShader();\n    await ExampleParticleSystemModel.LoadShader();\n    const self = this;\n\n    /**\n     * Here we will create a shader model and name it with the string defined in `MyMaterialNames.basicshader1`.\n     * The shaderName argument to CreateModel is the name used in the shader folder and glsl files under\n     * `public/shaders/`\n     */\n    let basicshader1ShaderMaterialModel = await ABasicShaderModel.CreateModel(\"customexample1\");\n    await this.materials.setMaterialModel(MyMaterialNames.basicshader1, basicshader1ShaderMaterialModel);\n\n    /**\n     * If we want to use vertex colors in our shader, we need to set useVertexColors to true.\n     * This will turn vertex colors on by default for materials created with this model.\n     * Each time you create a material, you can turn off vertex colors for that material if you want.\n     */\n    basicshader1ShaderMaterialModel.usesVertexColors = true;\n\n    /**\n     * Once a shader model is set like this, we can access it with the material name we assigned it to like so:\n     */\n    this.playerMaterial = this.materials.CreateShaderMaterial(MyMaterialNames.basicshader1);\n\n    /**\n     * Ok, now let's load a 3D model to use for our player.\n     */\n\n    /**\n     * We could use a dragon with vertex colors specified in a .ply file\n     */\n    // let dragonTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ(),Vec3.UnitX().times(-1), 0.005);\n    // this.loaded3DModel = await this.loadModelFromFile(\"./models/ply/dragon_color_onground.ply\", dragonTransform);\n    let birdTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.01);\n    /**\n     * Our cat comes with a texture, so lets add it to the character material\n     */\n    let birdTexture = await ATexture.LoadAsync(\"./models/gltf/Bird_diffuse.jpg\");\n\n    /**\n     * Or a cat!!! Here it is defined as a .glb file, which you can export from blender by exporting a mesh as a gltf format\n     */\n    let catTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.01);\n    this.loaded3DModel = await this.loadModelFromFile(\"./models/gltf/cat.glb\", catTransform);\n    /**\n     * Our cat comes with a texture, so lets add it to the character material\n     */\n    let catTexture = await ATexture.LoadAsync(\"./models/gltf/Cat_diffuse.jpg\");\n    this.playerMaterial.setTexture('diffuse', catTexture);\n\n    // dolphin object\n    let dolphinTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.01);\n\n    /**\n     * Our cat comes with a texture, so lets add it to the character material\n     */\n    let dolphinTexture = await ATexture.LoadAsync(\"./models/gltf/Dolphin_diffuse.jpg\");\n\n    //city object\n    let cityTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.01);\n\n    // let cityTexture = await ATexture.LoadAsync(\"./models/gltf/City_diffuse.jpeg\");\n    // this.playerMaterial.setTexture('diffuse', cityTexture);\n\n    //mountains object\n    let mountainsTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 1.0);\n    let mountainsTexture = await ATexture.LoadAsync(\"./models/gltf/Mountains_diffuse.jpg\");\n    let templeTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.02);\n    let templeTexture = await ATexture.LoadAsync(\"./models/gltf/Temple_diffuse.png\");\n\n    //desert background --> can't figure out how to get it level with floor, always above\n    let desertTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.01);\n    let desertTexture = await ATexture.LoadAsync(\"./models/gltf/Desert_diffuse.jpg\");\n\n    //street crashes\n    let streetTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.01);\n    let streetTexture = await ATexture.LoadAsync(\"./models/gltf/Street_diffuse.png\");\n    let palmTreeTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.01);\n    let palmTreeTexture = await ATexture.LoadAsync(\"./models/gltf/Street_diffuse.png\");\n    this.loaded3DModel = await this.loadModelFromFile(\"./models/gltf/palmTree.obj\", palmTreeTransform);\n    this.playerMaterial.setTexture('diffuse', palmTreeTexture);\n  }\n  initCamera() {\n    this.cameraModel = ACameraModel.CreatePerspectiveFOV(90, 1, 0.01, 10);\n    this.cameraModel.setPose(NodeTransform3D.LookAt(V3(-0.2, 0.8, 0.75), V3(0, 0, 0.5), V3(0, 0, 0.4)));\n  }\n\n  /**\n   * The view light is a light that is attached to the camera.\n   */\n  initViewLight() {\n    /**\n     * Create a point light\n     * You can have up to 16 point lights in the scene at once by default\n     */\n    this.viewLight = new APointLightModel(this.camera.pose, Color.FromString(\"#ffffff\"), 0.5, AppConfigs.ViewLightRange, 1);\n\n    /**\n     * Add it as a child of the camera model so that it will move with the camera\n     */\n    this.cameraModel.addChild(this.viewLight);\n  }\n  async initTerrain() {\n    this.terrain = await TerrainModel.Create(AppConfigs.GroundTexture,\n    // texture\n    AppConfigs.TerrainScaleX,\n    // scaleX\n    AppConfigs.TerrainScaleY,\n    // scaleY\n    AppConfigs.TerrainDataTextureWidth,\n    // number of vertices wide\n    AppConfigs.TerrainDataTextureHeight,\n    // number of vertices tall\n    undefined,\n    // transform for terrain, identity if left blank\n    AppConfigs.TerrainWrapTextureX,\n    // number of times texture should wrap across surface in X\n    AppConfigs.TerrainWrapTextureY // number of times texture should wrap across surface in Y\n    );\n\n    this.addChild(this.terrain);\n  }\n  async initCharacters() {\n    /**\n     * First we will initialze the player and add it to the scene.\n     */\n    // this.playerTexture = await ATexture.LoadAsync(\"./images/tanktexburngreen.jpeg\")\n    // this.player = await PlayerModel.Create(this.playerTexture);\n\n    /**\n     * Here we will initialize our player using the loaded .ply model and the shader material model we attached to\n     * the string MyMaterialNames.basicshader1\n     * @type {ExampleLoadedCharacterModel}\n     */\n    this.player = new ExampleLoadedCharacterModel(this.loaded3DModel, this.playerMaterial);\n    AddStandardUniforms(this.player.material);\n    this.addChild(this.player);\n\n    /**\n     * Then we will create a bunch of bots with different cat faces...\n     * Let's make each one a child of the last.\n     */\n    let parent = this;\n    for (let e = 0; e < 6; e++) {\n      let bot = await BotModel.Create(`./images/catfaces/catface0${e + 1}.jpeg`);\n      bot.position = new Vec3((Math.random() - 0.5) * AppConfigs.TerrainScaleX, (Math.random() - 0.5) * AppConfigs.TerrainScaleY, 0);\n      bot.mass = 50;\n      this.bots.push(bot);\n      parent.addChild(bot);\n      parent = bot;\n    }\n  }\n  async initScene() {\n    await this.initTerrain();\n    await this.initCharacters();\n    this.addChild(new ExampleThreeJSNodeModel());\n\n    /**\n     * Now an example particle system.\n     */\n    let particles = new ExampleParticleSystemModel();\n    particles.orbitRadius = 0.3;\n    let radius = 0.05;\n    particles.addParticle(new SphereParticle(undefined, undefined, radius));\n    particles.addParticle(new SphereParticle(undefined, undefined, radius));\n    particles.addParticle(new SphereParticle(undefined, undefined, radius));\n\n    /**\n     * We will add the particle system to one of the bots for kicks...\n     */\n    this.bots[this.bots.length - 1].addChild(particles);\n\n    /**\n     * Now let's initialize the view light\n     */\n    this.initViewLight();\n\n    /**\n     * Let's add the particle system controls to the control pannel...\n     */\n    // BillboardParticleSystemModel.AddParticleSystemControls();\n\n    /**\n     * And now let's create our particle system\n     */\n    this.billboardParticles = new BillboardParticleSystemModel(200);\n    this.addChild(this.billboardParticles);\n  }\n  timeUpdate(t) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    this.basicUpdate(t, ...args);\n    // this.spinBots(t, ...args);\n  }\n\n  /**\n   * Here we will separate out logic that check to see if a particle (characters implement the particle interface, so\n   * this can be used on characters as well) intersects the terrain.\n   * @param particle\n   */\n  adjustParticleHeight(particle) {\n    let height = this.terrain.getTerrainHeightAtPoint(particle.position.xy);\n    if (particle.position.z < height) {\n      particle.position.z = height;\n    }\n  }\n  basicUpdate(t) {\n    /**\n     * We can call timeUpdate on all of the model nodes in the scene here, which will trigger any updates that they\n     * individually define.\n     */\n    for (let c of this.getDescendantList()) {\n      c.timeUpdate(t);\n    }\n    this.adjustParticleHeight(this.player);\n    for (let ei = 0; ei < this.bots.length; ei++) {\n      let e = this.bots[ei];\n      /**\n       * adjust their height\n       */\n      this.adjustParticleHeight(e);\n    }\n  }\n  spinBots(t) {\n    /**\n     * Now lets update bots\n     */\n    let orbitradius = 0.25;\n    for (let ei = 0; ei < this.bots.length; ei++) {\n      let e = this.bots[ei];\n      e.position.xy = new Vec2(Math.cos(t * (ei + 1)), Math.sin(t * (ei + 1))).times(orbitradius);\n      this.adjustParticleHeight(e);\n    }\n  }\n  getCoordinatesForCursorEvent(event) {\n    var _event$ndcCursor;\n    return (_event$ndcCursor = event.ndcCursor) !== null && _event$ndcCursor !== void 0 ? _event$ndcCursor : new Vec2();\n  }\n}","map":{"version":3,"names":["A3DModelLoader","ACameraModel","APointLightModel","Color","GetAppState","NodeTransform3D","V3","Vec2","Vec3","BaseSceneModel","CharacterModel","BotModel","ExampleParticleSystemModel","ExampleThreeJSNodeModel","SphereParticle","TerrainModel","ATexture","AppConfigs","ExampleLoadedCharacterModel","ABasicShaderModel","AddStandardUniforms","BillboardParticleSystemModel","appState","MyMaterialNames","Example1SceneModel","terrain","_player","loaded3DModel","playerMaterial","catModel","catTexture","bots","billboardParticles","player","v","loadModelFromFile","path","transform","meshObject","LoadFromPath","sourceTransform","PreloadAssets","LoadShader","self","basicshader1ShaderMaterialModel","CreateModel","materials","setMaterialModel","basicshader1","usesVertexColors","CreateShaderMaterial","birdTransform","FromPositionZUpAndScale","UnitZ","times","UnitY","birdTexture","LoadAsync","catTransform","setTexture","dolphinTransform","dolphinTexture","cityTransform","mountainsTransform","mountainsTexture","templeTransform","templeTexture","desertTransform","desertTexture","streetTransform","streetTexture","palmTreeTransform","palmTreeTexture","initCamera","cameraModel","CreatePerspectiveFOV","setPose","LookAt","initViewLight","viewLight","camera","pose","FromString","ViewLightRange","addChild","initTerrain","Create","GroundTexture","TerrainScaleX","TerrainScaleY","TerrainDataTextureWidth","TerrainDataTextureHeight","undefined","TerrainWrapTextureX","TerrainWrapTextureY","initCharacters","material","parent","e","bot","position","Math","random","mass","push","initScene","particles","orbitRadius","radius","addParticle","length","timeUpdate","t","args","basicUpdate","adjustParticleHeight","particle","height","getTerrainHeightAtPoint","xy","z","c","getDescendantList","ei","spinBots","orbitradius","cos","sin","getCoordinatesForCursorEvent","event","ndcCursor"],"sources":["/Users/home/Desktop/cs4620-final-project/src/app/main/Scene/ExampleScenes/Example1/Example1SceneModel.ts"],"sourcesContent":["import {\n    A3DModelLoader,\n    ACameraModel, AInteractionEvent,\n    AModel, AObject3DModelWrapper,\n    APointLightModel, AShaderMaterial,\n    Color,\n    GetAppState,\n    NodeTransform3D, Quaternion,\n    V3, Vec2,\n    Vec3\n} from \"../../../../../anigraph\";\nimport {BaseSceneModel, CharacterModel, CharacterModelInterface} from \"../../../../BaseClasses\";\nimport {\n    BotModel,\n    ExampleParticleSystemModel,\n    ExampleThreeJSNodeModel,\n    PlayerModel,\n    SphereParticle,\n    TerrainModel\n} from \"../../../Nodes\";\nimport {ATexture} from \"../../../../../anigraph/rendering/ATexture\";\nimport {AppConfigs} from \"../../../../AppConfigs\";\nimport {Particle3D} from \"../../../../../anigraph/physics/AParticle3D\";\nimport {LoadedCharacterModel} from \"../../../../BaseClasses/LoadedCharacterModel\";\nimport {ExampleLoadedCharacterModel} from \"../../../Nodes/Loaded/ExampleLoadedCharacterModel\";\nimport {ABasicShaderModel} from \"../../../../../anigraph/rendering/shadermodels/ABasicShaderModel\";\nimport {AddStandardUniforms} from \"../HowToAddUniformToControlPanel\";\nimport {json} from \"stream/consumers\";\nimport {BillboardParticleSystemModel} from \"../../../Nodes/BillboardParticleSystem\";\n// import {AddStandardUniforms} from \"../HowToAddUniformToControlPanel\";\n\nlet appState = GetAppState();\n\n/**\n * Here we will define some enums that are simple strings.\n * These will be what we call different shader model instances. Note that we could just type these strings directly into\n * the code when we use them, but defining them as an enum will help avoid bugs caused by typos, and it will let you use\n * refactoring features of your IDE if you want to change these variables later.\n */\nenum MyMaterialNames{\n    basicshader1=\"basicshader1\",\n    mymaterial2=\"mymaterial2\",\n}\n\n\nexport class Example1SceneModel extends BaseSceneModel {\n    /**\n     * Our custom terrain model\n     */\n    terrain!:TerrainModel;\n\n    /**\n     * Our custom player model, and a texture to use for our player\n     */\n    _player!:CharacterModelInterface;\n    get player():CharacterModelInterface{\n        return this._player as LoadedCharacterModel;\n    }\n    set player(v:CharacterModelInterface){\n        this._player = v;\n    }\n    loaded3DModel!:AObject3DModelWrapper;\n    playerMaterial!:AShaderMaterial;\n\n\n    catModel!:AObject3DModelWrapper;\n    catTexture!:ATexture;\n\n    /**\n     * An array of bots. Your\n     */\n    bots:BotModel[]=[];\n\n    billboardParticles!:BillboardParticleSystemModel;\n\n\n    async loadModelFromFile(path:string, transform?:NodeTransform3D){\n        /**\n         * Here we need to load the .ply file into an AObject3DModelWrapper instance\n         */\n        let meshObject = await A3DModelLoader.LoadFromPath(path)\n        meshObject.sourceTransform = transform??new NodeTransform3D();\n        return meshObject;\n    }\n\n\n    async PreloadAssets() {\n        await super.PreloadAssets();\n        await TerrainModel.LoadShader();\n        await CharacterModel.LoadShader();\n        await ExampleParticleSystemModel.LoadShader();\n\n\n        const self = this;\n\n        /**\n         * Here we will create a shader model and name it with the string defined in `MyMaterialNames.basicshader1`.\n         * The shaderName argument to CreateModel is the name used in the shader folder and glsl files under\n         * `public/shaders/`\n         */\n        let basicshader1ShaderMaterialModel = await ABasicShaderModel.CreateModel(\"customexample1\");\n        await this.materials.setMaterialModel(MyMaterialNames.basicshader1, basicshader1ShaderMaterialModel);\n\n        /**\n         * If we want to use vertex colors in our shader, we need to set useVertexColors to true.\n         * This will turn vertex colors on by default for materials created with this model.\n         * Each time you create a material, you can turn off vertex colors for that material if you want.\n         */\n        basicshader1ShaderMaterialModel.usesVertexColors=true;\n\n        /**\n         * Once a shader model is set like this, we can access it with the material name we assigned it to like so:\n         */\n        this.playerMaterial = this.materials.CreateShaderMaterial(MyMaterialNames.basicshader1);\n\n\n\n        /**\n         * Ok, now let's load a 3D model to use for our player.\n         */\n\n\n        /**\n         * We could use a dragon with vertex colors specified in a .ply file\n         */\n        // let dragonTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ(),Vec3.UnitX().times(-1), 0.005);\n        // this.loaded3DModel = await this.loadModelFromFile(\"./models/ply/dragon_color_onground.ply\", dragonTransform);\n        let birdTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.01);\n        /**\n         * Our cat comes with a texture, so lets add it to the character material\n         */\n        let birdTexture = await ATexture.LoadAsync(\"./models/gltf/Bird_diffuse.jpg\");\n\n\n        /**\n         * Or a cat!!! Here it is defined as a .glb file, which you can export from blender by exporting a mesh as a gltf format\n         */\n        let catTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.01);\n        this.loaded3DModel = await this.loadModelFromFile(\"./models/gltf/cat.glb\", catTransform);\n        /**\n         * Our cat comes with a texture, so lets add it to the character material\n         */\n        let catTexture = await ATexture.LoadAsync(\"./models/gltf/Cat_diffuse.jpg\");\n        this.playerMaterial.setTexture('diffuse', catTexture);\n\n        // dolphin object\n        let dolphinTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.01);\n\n        /**\n         * Our cat comes with a texture, so lets add it to the character material\n         */\n        let dolphinTexture = await ATexture.LoadAsync(\"./models/gltf/Dolphin_diffuse.jpg\");\n\n\n        //city object\n        let cityTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.01);\n\n        // let cityTexture = await ATexture.LoadAsync(\"./models/gltf/City_diffuse.jpeg\");\n        // this.playerMaterial.setTexture('diffuse', cityTexture);\n\n        //mountains object\n        let mountainsTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 1.0);\n        let mountainsTexture = await ATexture.LoadAsync(\"./models/gltf/Mountains_diffuse.jpg\");\n\n        let templeTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.02);\n        let templeTexture = await ATexture.LoadAsync(\"./models/gltf/Temple_diffuse.png\");\n\n        //desert background --> can't figure out how to get it level with floor, always above\n        let desertTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.01);\n        let desertTexture = await ATexture.LoadAsync(\"./models/gltf/Desert_diffuse.jpg\");\n\n        //street crashes\n        let streetTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.01);\n        let streetTexture = await ATexture.LoadAsync(\"./models/gltf/Street_diffuse.png\");\n\n        let palmTreeTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), 0.01);\n        let palmTreeTexture = await ATexture.LoadAsync(\"./models/gltf/Street_diffuse.png\");\n\n        this.loaded3DModel = await this.loadModelFromFile(\"./models/gltf/palmTree.obj\", palmTreeTransform);\n        this.playerMaterial.setTexture('diffuse', palmTreeTexture);\n\n    }\n\n\n    initCamera() {\n        this.cameraModel = ACameraModel.CreatePerspectiveFOV(90, 1, 0.01, 10);\n\n        this.cameraModel.setPose(\n            NodeTransform3D.LookAt(\n                V3(-0.2, 0.8, 0.75), V3(0,0,0.5),\n                V3(0,0,0.4)\n            )\n        )\n\n    }\n\n    /**\n     * The view light is a light that is attached to the camera.\n     */\n    initViewLight(){\n\n        /**\n         * Create a point light\n         * You can have up to 16 point lights in the scene at once by default\n         */\n        this.viewLight = new APointLightModel(\n            this.camera.pose,\n            Color.FromString(\"#ffffff\"),\n            0.5,\n            AppConfigs.ViewLightRange,\n            1\n        );\n\n        /**\n         * Add it as a child of the camera model so that it will move with the camera\n         */\n        this.cameraModel.addChild(this.viewLight);\n    }\n\n    async initTerrain(){\n        this.terrain = await TerrainModel.Create(\n            AppConfigs.GroundTexture, // texture\n            AppConfigs.TerrainScaleX, // scaleX\n            AppConfigs.TerrainScaleY, // scaleY\n            AppConfigs.TerrainDataTextureWidth, // number of vertices wide\n            AppConfigs.TerrainDataTextureHeight, // number of vertices tall\n            undefined, // transform for terrain, identity if left blank\n            AppConfigs.TerrainWrapTextureX, // number of times texture should wrap across surface in X\n            AppConfigs.TerrainWrapTextureY, // number of times texture should wrap across surface in Y\n        );\n\n        this.addChild(this.terrain);\n    }\n\n\n\n    async initCharacters(){\n\n\n        /**\n         * First we will initialze the player and add it to the scene.\n         */\n        // this.playerTexture = await ATexture.LoadAsync(\"./images/tanktexburngreen.jpeg\")\n        // this.player = await PlayerModel.Create(this.playerTexture);\n\n        /**\n         * Here we will initialize our player using the loaded .ply model and the shader material model we attached to\n         * the string MyMaterialNames.basicshader1\n         * @type {ExampleLoadedCharacterModel}\n         */\n        this.player = new ExampleLoadedCharacterModel(\n            this.loaded3DModel,\n            this.playerMaterial\n        );\n        AddStandardUniforms(this.player.material);\n        this.addChild(this.player);\n\n\n\n\n        /**\n         * Then we will create a bunch of bots with different cat faces...\n         * Let's make each one a child of the last.\n         */\n        let parent:AModel = this;\n        for(let e=0;e<6; e++) {\n            let bot = await BotModel.Create(`./images/catfaces/catface0${e + 1}.jpeg`);\n            bot.position = new Vec3((Math.random() - 0.5) * AppConfigs.TerrainScaleX, (Math.random() - 0.5) * AppConfigs.TerrainScaleY, 0);\n            bot.mass = 50;\n            this.bots.push(bot);\n            parent.addChild(bot);\n            parent = bot;\n        }\n    }\n\n\n    async initScene() {\n        await this.initTerrain();\n        await this.initCharacters();\n\n        this.addChild(new ExampleThreeJSNodeModel());\n\n        /**\n         * Now an example particle system.\n         */\n        let particles = new ExampleParticleSystemModel();\n        particles.orbitRadius = 0.3;\n        let radius = 0.05;\n        particles.addParticle(new SphereParticle(undefined, undefined, radius));\n        particles.addParticle(new SphereParticle(undefined, undefined, radius));\n        particles.addParticle(new SphereParticle(undefined, undefined, radius));\n\n        /**\n         * We will add the particle system to one of the bots for kicks...\n         */\n        this.bots[this.bots.length-1].addChild(particles);\n\n        /**\n         * Now let's initialize the view light\n         */\n        this.initViewLight();\n\n        /**\n         * Let's add the particle system controls to the control pannel...\n         */\n        // BillboardParticleSystemModel.AddParticleSystemControls();\n\n        /**\n         * And now let's create our particle system\n         */\n        this.billboardParticles = new BillboardParticleSystemModel(200);\n        this.addChild(this.billboardParticles);\n\n    }\n\n    timeUpdate(t: number, ...args:any[]) {\n        this.basicUpdate(t, ...args);\n        // this.spinBots(t, ...args);\n    }\n\n    /**\n     * Here we will separate out logic that check to see if a particle (characters implement the particle interface, so\n     * this can be used on characters as well) intersects the terrain.\n     * @param particle\n     */\n    adjustParticleHeight(particle:Particle3D){\n        let height = this.terrain.getTerrainHeightAtPoint(particle.position.xy);\n        if(particle.position.z<height){particle.position.z = height;}\n    }\n\n    basicUpdate(t:number, ...args:any[]){\n        /**\n         * We can call timeUpdate on all of the model nodes in the scene here, which will trigger any updates that they\n         * individually define.\n         */\n        for(let c of this.getDescendantList()){\n            c.timeUpdate(t);\n        }\n\n        this.adjustParticleHeight(this.player);\n        for(let ei=0;ei<this.bots.length;ei++){\n            let e = this.bots[ei];\n            /**\n             * adjust their height\n             */\n            this.adjustParticleHeight(e);\n        }\n    }\n\n    spinBots(t:number, ...args:any[]){\n        /**\n         * Now lets update bots\n         */\n        let orbitradius = 0.25;\n        for(let ei=0;ei<this.bots.length;ei++){\n            let e = this.bots[ei];\n            e.position.xy = new Vec2(Math.cos(t*(ei+1)), Math.sin(t*(ei+1))).times(orbitradius);\n            this.adjustParticleHeight(e);\n        }\n    }\n\n\n    getCoordinatesForCursorEvent(event: AInteractionEvent){\n        return event.ndcCursor??new Vec2();\n    }\n}\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}