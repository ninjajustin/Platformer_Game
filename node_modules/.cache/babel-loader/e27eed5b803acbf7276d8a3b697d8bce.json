{"ast":null,"code":"import { AObjectNode } from \"../aobject\";\nimport { AClock } from \"../../time\";\nimport { AInteractionModeMap, BasicInteractionModes } from \"../../interaction\";\nimport { v4 as uuidv4 } from \"uuid\";\nexport class AController extends AObjectNode {\n  get time() {\n    return this._clock.time;\n  }\n  /**\n   * Getter for the current interaction mode.\n   * @returns {AInteractionMode}\n   */\n  get interactionMode() {\n    return this._interactions.modes[this._currentInteractionModeName];\n  }\n  constructor() {\n    super();\n    this._model = void 0;\n    this._clock = void 0;\n    this._interactions = void 0;\n    this._currentInteractionModeName = void 0;\n    this._clock = new AClock();\n    this._clock.play();\n    this._interactions = new AInteractionModeMap(this);\n    this._currentInteractionModeName = BasicInteractionModes.Default;\n  }\n  getContextDOMElement() {\n    return this.sceneController.renderWindow.contextElement;\n  }\n\n  /**\n   * Add an interaction to the current mode.\n   * @param interaction\n   */\n  addInteraction(interaction) {\n    this.interactionMode.addInteraction(interaction);\n    // interaction.owner = this;\n    return interaction;\n  }\n  activateInteractions() {\n    this.interactionMode.activate();\n  }\n  setCurrentInteractionMode(name) {\n    this.interactionMode.deactivate();\n    let activeMode = name ? name : BasicInteractionModes.Default;\n    this._interactions.setActiveMode(activeMode);\n    this._currentInteractionModeName = activeMode;\n  }\n  defineInteractionMode(name, mode) {\n    this._interactions.defineMode(name, mode);\n  }\n  clearInteractionMode(name) {\n    this._interactions.undefineMode(name);\n  }\n  isInteractionModeDefined(name) {\n    return this._interactions.modeIsDefined(name);\n  }\n\n  /**\n   * If you provide a handle, then the action will not call so long as an existing subscription by that handle exists.\n   * This means that you won't duplicate the action before one has finished previously.\n   * @param callback\n   * @param duration\n   * @param tween\n   * @param actionOverCallback\n   * @param handle\n   */\n  addTimedAction(callback, duration, actionOverCallback, tween, handle) {\n    if (handle && handle in this._subscriptions) {\n      return;\n    }\n    const self = this;\n    const subscriptionHandle = handle !== null && handle !== void 0 ? handle : uuidv4();\n    this.subscribe(this._clock.CreateTimedAction(callback, duration, () => {\n      self.unsubscribe(subscriptionHandle);\n      if (actionOverCallback) {\n        actionOverCallback();\n      }\n    }, tween), subscriptionHandle);\n  }\n  release() {\n    this.dispose();\n    super.release(...arguments);\n  }\n  dispose() {\n    this._interactions.dispose();\n  }\n}","map":{"version":3,"names":["AObjectNode","AClock","AInteractionModeMap","BasicInteractionModes","v4","uuidv4","AController","time","_clock","interactionMode","_interactions","modes","_currentInteractionModeName","constructor","_model","play","Default","getContextDOMElement","sceneController","renderWindow","contextElement","addInteraction","interaction","activateInteractions","activate","setCurrentInteractionMode","name","deactivate","activeMode","setActiveMode","defineInteractionMode","mode","defineMode","clearInteractionMode","undefineMode","isInteractionModeDefined","modeIsDefined","addTimedAction","callback","duration","actionOverCallback","tween","handle","_subscriptions","self","subscriptionHandle","subscribe","CreateTimedAction","unsubscribe","release","dispose"],"sources":["/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/src/anigraph/base/amvc/AController.ts"],"sourcesContent":["import {AModel} from \"./AModel\";\nimport {AObjectNode} from \"../aobject\";\nimport {AClock} from \"../../time\";\nimport {AInteraction, AInteractionMode, AInteractionModeMap, BasicInteractionModes} from \"../../interaction\";\nimport {CallbackType} from \"../../basictypes\";\nimport {BezierTween} from \"../../geometry\";\nimport {ARenderDelegate} from \"../../rendering\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport {HasInteractions} from \"./HasInteractions\";\n\nexport interface AControllerInterface{\n    sceneController:ARenderDelegate;\n    get eventTarget():HTMLElement;\n}\n\nexport interface SceneControllerInterface extends ARenderDelegate, AControllerInterface{\n}\n\nexport abstract class AController extends AObjectNode implements AControllerInterface, HasInteractions{\n    protected _model!:AModel;\n    protected _clock: AClock;\n    get time(){\n        return this._clock.time;\n    }\n    abstract get sceneController():SceneControllerInterface;\n    abstract get eventTarget():HTMLElement;\n\n    /**\n     * Interaction mode map. Has a .modes property that maps mode names to AInteractionModes.\n     * @type {AInteractionModeMap}\n     * @protected\n     */\n    protected _interactions!: AInteractionModeMap;\n    /**\n     * Right now, controllers are restricted to having one or zero active modes at a time. The name of the current mode, which can be active or inactive, is stored here.\n     * @type {string}\n     * @protected\n     */\n    protected _currentInteractionModeName: string;\n\n\n    /**\n     * Getter for the current interaction mode.\n     * @returns {AInteractionMode}\n     */\n    get interactionMode() {\n        return this._interactions.modes[this._currentInteractionModeName];\n    }\n\n    constructor() {\n        super();\n        this._clock = new AClock();\n        this._clock.play();\n        this._interactions = new AInteractionModeMap(this);\n        this._currentInteractionModeName = BasicInteractionModes.Default;\n    }\n\n    getContextDOMElement(){\n        return this.sceneController.renderWindow.contextElement;\n    }\n\n    /**\n     * Add an interaction to the current mode.\n     * @param interaction\n     */\n    addInteraction(interaction: AInteraction) {\n        this.interactionMode.addInteraction(interaction);\n        // interaction.owner = this;\n        return interaction;\n    }\n\n    activateInteractions() {\n        this.interactionMode.activate();\n    }\n\n    setCurrentInteractionMode(name?: string) {\n        this.interactionMode.deactivate();\n        let activeMode = name ? name : BasicInteractionModes.Default;\n        this._interactions.setActiveMode(activeMode);\n        this._currentInteractionModeName = activeMode;\n    }\n\n    defineInteractionMode(name: string, mode?: AInteractionMode) {\n        this._interactions.defineMode(name, mode);\n    }\n\n    clearInteractionMode(name: string) {\n        this._interactions.undefineMode(name)\n    }\n\n    isInteractionModeDefined(name: string):boolean {\n        return this._interactions.modeIsDefined(name);\n    }\n\n\n    /**\n     * If you provide a handle, then the action will not call so long as an existing subscription by that handle exists.\n     * This means that you won't duplicate the action before one has finished previously.\n     * @param callback\n     * @param duration\n     * @param tween\n     * @param actionOverCallback\n     * @param handle\n     */\n    addTimedAction(callback: (actionProgress: number) => any, duration: number, actionOverCallback?: CallbackType, tween?: BezierTween, handle?: string) {\n        if (handle && (handle in this._subscriptions)) {\n            return;\n        }\n        const self = this;\n        const subscriptionHandle = handle ?? uuidv4();\n        this.subscribe(this._clock.CreateTimedAction(callback, duration, () => {\n                self.unsubscribe(subscriptionHandle);\n                if (actionOverCallback) {\n                    actionOverCallback();\n                }\n            }, tween),\n            subscriptionHandle);\n    }\n\n    release(...args: undefined[]) {\n        this.dispose();\n        super.release(...args);\n    }\n\n    dispose() {\n        this._interactions.dispose();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}