{"ast":null,"code":"var _dec, _class, _class2;\nimport { ANodeModel3D, ASerializable, AShaderModel, Color } from \"../../../../../anigraph\";\nimport { ABasicShaderModel } from \"../../../../../anigraph/rendering/shadermodels/ABasicShaderModel\";\nvar ParticleEvents;\n(function (ParticleEvents) {\n  ParticleEvents[\"PARTICLES_UPDATED\"] = \"PARTICLES_UPDATED\";\n})(ParticleEvents || (ParticleEvents = {}));\nexport let ExampleParticleSystemModel = (_dec = ASerializable(\"ExampleParticleSystemModel\"), _dec(_class = (_class2 = class ExampleParticleSystemModel extends ANodeModel3D {\n  static async LoadShader() {\n    await AShaderModel.ShaderSourceLoaded(\"exampleparticle\");\n    ExampleParticleSystemModel.ShaderModel = await ABasicShaderModel.CreateModel(\"exampleparticle\");\n  }\n\n  /**\n   * Here we don't want to make particles AObjectState because we may update particles one at a time, which would\n   * cause listeners to update for every minor change. Instead, we will batch these updates by sending an update\n   * signal with `this.signalParticlesUpdated()` to anything that added a listener using `addParticlesListener`\n   */\n\n  constructor() {\n    super();\n    this.particles = void 0;\n    this.orbitRadius = 0.5;\n    this.orbitFrequency = 2;\n    this.zOffset = 0.1;\n    this.particles = [];\n    this.setMaterial(ExampleParticleSystemModel.ShaderModel.CreateMaterial());\n    this.material.setUniform(\"particleColor\", Color.FromRGBA(0.2, 1.0, 0.2, 0.5));\n  }\n  addParticle(particle) {\n    this.particles.push(particle);\n  }\n\n  /**\n   *\n   * @param callback\n   * @param handle\n   * @param synchronous\n   * @returns {AStateCallbackSwitch}\n   */\n  addParticlesListener(callback, handle) {\n    let synchronous = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return this.addEventListener(ParticleEvents.PARTICLES_UPDATED, callback, handle);\n  }\n  signalParticlesUpdated() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    this.signalEvent(ParticleEvents.PARTICLES_UPDATED, ...args);\n  }\n  timeUpdate(t) {\n    super.timeUpdate(t);\n    let phase = t * Math.PI * 2 * this.orbitFrequency;\n    for (let p = 0; p < this.particles.length; p++) {\n      let offset = p * Math.PI * 2 / this.particles.length;\n      this.particles[p].position.x = this.orbitRadius * Math.sin(offset + phase);\n      this.particles[p].position.y = this.orbitRadius * Math.cos(offset + phase);\n      this.particles[p].position.z = this.zOffset;\n    }\n    this.signalParticlesUpdated();\n  }\n}, _class2.ShaderModel = void 0, _class2)) || _class);","map":{"version":3,"names":["ANodeModel3D","ASerializable","AShaderModel","Color","ABasicShaderModel","ParticleEvents","ExampleParticleSystemModel","LoadShader","ShaderSourceLoaded","ShaderModel","CreateModel","constructor","particles","orbitRadius","orbitFrequency","zOffset","setMaterial","CreateMaterial","material","setUniform","FromRGBA","addParticle","particle","push","addParticlesListener","callback","handle","synchronous","addEventListener","PARTICLES_UPDATED","signalParticlesUpdated","args","signalEvent","timeUpdate","t","phase","Math","PI","p","length","offset","position","x","sin","y","cos","z"],"sources":["/Users/home/Desktop/cs4620-final-project/src/app/main/Nodes/ExampleNodes/ExampleParticleSystemNode/ExampleParticleSystemModel.ts"],"sourcesContent":["import {ANodeModel3D, AObject, ASerializable, AShaderModel, Color,} from \"../../../../../anigraph\";\nimport {SphereParticle} from \"./SphereParticle\";\nimport {ABasicShaderModel} from \"../../../../../anigraph/rendering/shadermodels/ABasicShaderModel\";\n\nenum ParticleEvents{\n    PARTICLES_UPDATED=\"PARTICLES_UPDATED\"\n}\n\n@ASerializable(\"ExampleParticleSystemModel\")\nexport class ExampleParticleSystemModel extends ANodeModel3D{\n    static ShaderModel:ABasicShaderModel;\n    static async LoadShader(...args:any[]){\n        await AShaderModel.ShaderSourceLoaded(\"exampleparticle\");\n        ExampleParticleSystemModel.ShaderModel = await ABasicShaderModel.CreateModel(\"exampleparticle\")\n    }\n\n    /**\n     * Here we don't want to make particles AObjectState because we may update particles one at a time, which would\n     * cause listeners to update for every minor change. Instead, we will batch these updates by sending an update\n     * signal with `this.signalParticlesUpdated()` to anything that added a listener using `addParticlesListener`\n     */\n    particles:SphereParticle[];\n\n    orbitRadius:number=0.5;\n    orbitFrequency:number=2;\n    zOffset:number=0.1;\n\n    constructor() {\n        super();\n        this.particles = [];\n        this.setMaterial(ExampleParticleSystemModel.ShaderModel.CreateMaterial());\n        this.material.setUniform(\"particleColor\", Color.FromRGBA(0.2,1.0,0.2,0.5));\n    }\n\n    addParticle(particle:SphereParticle){\n        this.particles.push(particle);\n    }\n\n    /**\n     *\n     * @param callback\n     * @param handle\n     * @param synchronous\n     * @returns {AStateCallbackSwitch}\n     */\n    addParticlesListener(callback:(self:AObject)=>void, handle?:string, synchronous:boolean=true,){\n        return this.addEventListener(ParticleEvents.PARTICLES_UPDATED,callback, handle);\n    }\n\n    signalParticlesUpdated(...args:any[]){\n        this.signalEvent(ParticleEvents.PARTICLES_UPDATED, ...args);\n    }\n\n    timeUpdate(t: number, ...args:any[]) {\n        super.timeUpdate(t);\n\n        let phase = t*Math.PI*2*this.orbitFrequency;\n        for(let p=0;p<this.particles.length;p++){\n            let offset = p*Math.PI*2/(this.particles.length);\n            this.particles[p].position.x = this.orbitRadius*Math.sin(offset+phase);\n            this.particles[p].position.y = this.orbitRadius*Math.cos(offset+phase);\n            this.particles[p].position.z = this.zOffset;\n        }\n\n        this.signalParticlesUpdated();\n    }\n\n}\n"],"mappings":";AAAA,SAAQA,YAAY,EAAWC,aAAa,EAAEC,YAAY,EAAEC,KAAK,QAAQ,yBAAyB;AAElG,SAAQC,iBAAiB,QAAO,kEAAkE;AAAC,IAE9FC,cAAc;AAAA,WAAdA,cAAc;EAAdA,cAAc;AAAA,GAAdA,cAAc,KAAdA,cAAc;AAInB,WACaC,0BAA0B,WADtCL,aAAa,CAAC,4BAA4B,CAAC,2BAA5C,MACaK,0BAA0B,SAASN,YAAY;EAExD,aAAaO,UAAU,GAAe;IAClC,MAAML,YAAY,CAACM,kBAAkB,CAAC,iBAAiB,CAAC;IACxDF,0BAA0B,CAACG,WAAW,GAAG,MAAML,iBAAiB,CAACM,WAAW,CAAC,iBAAiB,CAAC;EACnG;;EAEA;AACJ;AACA;AACA;AACA;;EAOIC,WAAW,GAAG;IACV,KAAK,EAAE;IAAC,KAPZC,SAAS;IAAA,KAETC,WAAW,GAAQ,GAAG;IAAA,KACtBC,cAAc,GAAQ,CAAC;IAAA,KACvBC,OAAO,GAAQ,GAAG;IAId,IAAI,CAACH,SAAS,GAAG,EAAE;IACnB,IAAI,CAACI,WAAW,CAACV,0BAA0B,CAACG,WAAW,CAACQ,cAAc,EAAE,CAAC;IACzE,IAAI,CAACC,QAAQ,CAACC,UAAU,CAAC,eAAe,EAAEhB,KAAK,CAACiB,QAAQ,CAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,CAAC,CAAC;EAC9E;EAEAC,WAAW,CAACC,QAAuB,EAAC;IAChC,IAAI,CAACV,SAAS,CAACW,IAAI,CAACD,QAAQ,CAAC;EACjC;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIE,oBAAoB,CAACC,QAA6B,EAAEC,MAAc,EAA4B;IAAA,IAA1BC,WAAmB,uEAAC,IAAI;IACxF,OAAO,IAAI,CAACC,gBAAgB,CAACvB,cAAc,CAACwB,iBAAiB,EAACJ,QAAQ,EAAEC,MAAM,CAAC;EACnF;EAEAI,sBAAsB,GAAe;IAAA,kCAAXC,IAAI;MAAJA,IAAI;IAAA;IAC1B,IAAI,CAACC,WAAW,CAAC3B,cAAc,CAACwB,iBAAiB,EAAE,GAAGE,IAAI,CAAC;EAC/D;EAEAE,UAAU,CAACC,CAAS,EAAiB;IACjC,KAAK,CAACD,UAAU,CAACC,CAAC,CAAC;IAEnB,IAAIC,KAAK,GAAGD,CAAC,GAACE,IAAI,CAACC,EAAE,GAAC,CAAC,GAAC,IAAI,CAACvB,cAAc;IAC3C,KAAI,IAAIwB,CAAC,GAAC,CAAC,EAACA,CAAC,GAAC,IAAI,CAAC1B,SAAS,CAAC2B,MAAM,EAACD,CAAC,EAAE,EAAC;MACpC,IAAIE,MAAM,GAAGF,CAAC,GAACF,IAAI,CAACC,EAAE,GAAC,CAAC,GAAE,IAAI,CAACzB,SAAS,CAAC2B,MAAO;MAChD,IAAI,CAAC3B,SAAS,CAAC0B,CAAC,CAAC,CAACG,QAAQ,CAACC,CAAC,GAAG,IAAI,CAAC7B,WAAW,GAACuB,IAAI,CAACO,GAAG,CAACH,MAAM,GAACL,KAAK,CAAC;MACtE,IAAI,CAACvB,SAAS,CAAC0B,CAAC,CAAC,CAACG,QAAQ,CAACG,CAAC,GAAG,IAAI,CAAC/B,WAAW,GAACuB,IAAI,CAACS,GAAG,CAACL,MAAM,GAACL,KAAK,CAAC;MACtE,IAAI,CAACvB,SAAS,CAAC0B,CAAC,CAAC,CAACG,QAAQ,CAACK,CAAC,GAAG,IAAI,CAAC/B,OAAO;IAC/C;IAEA,IAAI,CAACe,sBAAsB,EAAE;EACjC;AAEJ,CAAC,UAzDUrB,WAAW"},"metadata":{},"sourceType":"module"}