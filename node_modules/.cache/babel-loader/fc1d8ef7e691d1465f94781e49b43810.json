{"ast":null,"code":"/***\n * The BoundingBox3D class\n * This class represents a 3D bounding box using\n * - minPoint (Vec3): the point defined by the minimum x, y, and z coordinates being bound.\n * - maxPoint (Vec3): the point defined by the maximum x, y, and z coordinates being bound.\n * - transform (NodeTransform3D): a transformation associated with the bounding box. This allows for\n *   oriented bounding boxes.\n */\n\nimport * as THREE from \"three\";\nimport { V3, Vec3, Vec4, V2, Mat4 } from \"../math\";\nimport { BoundingBox } from \"./BoundingBox\";\nimport { BoundingBox2D } from \"./BoundingBox2D\";\nimport { VertexArray3D } from \"./VertexArray3D\";\nimport { VertexArray2D } from \"./VertexArray2D\";\nimport { VertexIndexArray } from \"./VertexIndexArray\";\n\n// export class BoundingBox3D extends BoundingBox<Vec3, Mat4>\nexport class BoundingBox3D extends BoundingBox {\n  constructor() {\n    super();\n    // this.transform = new Mat4();\n    this.transform = new Mat4();\n  }\n  clone() {\n    var _this$minPoint, _this$maxPoint;\n    let cfunc = this.constructor;\n    let clone = new cfunc();\n    clone.minPoint = (_this$minPoint = this.minPoint) === null || _this$minPoint === void 0 ? void 0 : _this$minPoint.clone();\n    clone.maxPoint = (_this$maxPoint = this.maxPoint) === null || _this$maxPoint === void 0 ? void 0 : _this$maxPoint.clone();\n    clone.transform = this.transform.clone();\n    return clone;\n  }\n  static FromVec3s(verts) {\n    let va = VertexArray3D.FromVec3List(verts);\n    return BoundingBox3D.FromVertexArray3D(va);\n  }\n\n  /**\n   * Get a bounding box at a specified location with a specified side length\n   * @param location\n   * @param size\n   * @returns {BoundingBox3D}\n   * @constructor\n   */\n  static BoxAtLocationWithSize(location) {\n    let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    let box = new BoundingBox3D();\n    let hsize = size * 0.5;\n    box.boundPoint(V3(hsize, hsize, hsize));\n    box.boundPoint(V3(-hsize, -hsize, -hsize));\n    box.transform = Mat4.Translation3D(location);\n    // box.transform = new Mat4();\n    // box.transform.c3 = new Vec4(location.x, location.y, location.z, 1.0);\n\n    return box;\n  }\n\n  /**\n   * Get a bounding box 3D that bounds points from the given VertexArray3D\n   * @param verts\n   * @returns {BoundingBox3D}\n   * @constructor\n   */\n  static FromVertexArray3D(verts) {\n    let rval = new BoundingBox3D();\n    rval.boundVertexPositionArrray(verts.position);\n    return rval;\n  }\n\n  /**\n   * Adjusts the current bounding box to bound all of the points specified in va.\n   * @param va\n   */\n  boundVertexPositionArrray(va) {\n    let nverts = va.nVerts;\n    for (let vi = 0; vi < nverts; vi++) {\n      this.boundPoint(va.getAt(vi));\n    }\n  }\n\n  /**\n   * Gets the ThreeJS bounds and converts them to a BoundingBox3D object.\n   * @param obj\n   * @returns {BoundingBox3D}\n   * @constructor\n   */\n  static FromTHREEJSObject(obj) {\n    let threebox = new THREE.Box3().setFromObject(obj);\n    let bounds = new BoundingBox3D();\n    bounds.minPoint = V3(threebox.min.x, threebox.min.y, threebox.min.z);\n    bounds.maxPoint = V3(threebox.max.x, threebox.max.y, threebox.max.z);\n    return bounds;\n  }\n\n  /**\n   * Get a random point in the object space (not transformed by this.transform) of the bounding box\n   * @returns {Vec3}\n   */\n  randomPointObjectSpace() {\n    let rand1 = Math.random();\n    let rand2 = Math.random();\n    let rand3 = Math.random();\n    if (!this.minPoint || !this.maxPoint) {\n      return V3();\n    }\n    return V3(this.minPoint.x * rand1 + this.maxPoint.x * (1 - rand1), this.minPoint.y * rand2 + this.maxPoint.y * (1 - rand2), this.minPoint.z * rand3 + this.maxPoint.z * (1 - rand3));\n  }\n\n  /**\n   * Get a random point from the region bounded by the oriented bounding box\n   * (i.e., the box after transforming by this.transform)\n   * @returns {Vec3}\n   */\n  randomTransformedPoint() {\n    return this.transform.getMatrix().times(this.randomPointObjectSpace().Point3DH).Point3D;\n  }\n\n  /**\n   * Center of box\n   * @returns {Vec3}\n   */\n  get center() {\n    if (!this.minPoint || !this.maxPoint) {\n      return;\n    }\n    return this.transform.getMatrix().times(this.minPoint.plus(this.maxPoint).times(0.5).Point3DH).Point3D;\n  }\n\n  /**\n   * The width in object space\n   * @returns {number}\n   */\n  get localWidth() {\n    // @ts-ignore\n    return this.maxPoint.x - this.minPoint.x;\n  }\n\n  /**\n   * The height in object space\n   * @returns {number}\n   */\n  get localHeight() {\n    // @ts-ignore\n    return this.maxPoint.y - this.minPoint.y;\n  }\n\n  /**\n   * The depth in object space\n   * @returns {number}\n   */\n  get localDepth() {\n    // @ts-ignore\n    return this.maxPoint.z - this.minPoint.z;\n  }\n\n  /**\n   * Adjust the bounds to contrain the given point (if adjustment is necessary).\n   * @param p\n   */\n  boundPoint(p) {\n    if (!this.minPoint || !this.maxPoint) {\n      let pcl = p instanceof Vec3 ? p : p instanceof Vec4 ? p.Point3D : Vec3.From2DHPoint(p);\n      this.minPoint = pcl.clone();\n      this.maxPoint = pcl.clone();\n      return;\n    }\n    let ndim = Math.min(this.minPoint.nDimensions, p.elements.length);\n    for (let c = 0; c < ndim; c++) {\n      if (p.elements[c] < this.minPoint.elements[c]) {\n        this.minPoint.elements[c] = p.elements[c];\n      }\n      if (p.elements[c] > this.maxPoint.elements[c]) {\n        this.maxPoint.elements[c] = p.elements[c];\n      }\n    }\n  }\n\n  /**\n   * [-1, -1, -1]\n   * [1,  -1, -1]\n   * [1,   1, -1]\n   * [-1,  1, -1]\n   * [-1, -1,  1]\n   * [1,  -1,  1]\n   * [1,   1,  1]\n   * [-1,  1,  1]\n   *\n   * near face far face order\n   * @returns {any[] | Vec3[]}\n   */\n  get corners() {\n    let tmat = this.transform.getMatrix();\n    if (!this.minPoint || !this.maxPoint) {\n      return [];\n    }\n    return [tmat.times(this.minPoint.Point3DH).Point3D, tmat.times(V3(this.maxPoint.x, this.minPoint.y, this.minPoint.z).Point3DH).Point3D, tmat.times(V3(this.maxPoint.x, this.maxPoint.y, this.minPoint.z).Point3DH).Point3D, tmat.times(V3(this.minPoint.x, this.maxPoint.y, this.minPoint.z).Point3DH).Point3D, tmat.times(V3(this.minPoint.x, this.minPoint.y, this.maxPoint.z).Point3DH).Point3D, tmat.times(V3(this.maxPoint.x, this.minPoint.y, this.maxPoint.z).Point3DH).Point3D, tmat.times(this.maxPoint.Point3DH).Point3D, tmat.times(V3(this.minPoint.x, this.maxPoint.y, this.maxPoint.z).Point3DH).Point3D];\n  }\n\n  /**\n   * gets minpoint, far bottom right, maxpoint, near top left, minpoint\n   * @returns {VertexArray2D}\n   * @constructor\n   */\n  GetBoundaryLinesVertexArray2D() {\n    let va = new VertexArray2D();\n    let corners = this.corners;\n    if (!corners.length) {\n      return va;\n    }\n    va.addVertex(corners[0].XY);\n    va.addVertex(corners[1].XY);\n    va.addVertex(corners[2].XY);\n    va.addVertex(corners[3].XY);\n    va.addVertex(corners[0].XY);\n    return va;\n  }\n  GetBoundaryLinesVertexArray() {\n    let va = new VertexArray2D();\n    let corners = this.corners;\n    if (!corners.length) {\n      return va;\n    }\n    va.addVertex(corners[0].Point2D);\n    va.addVertex(corners[1].Point2D);\n    va.addVertex(corners[2].Point2D);\n    va.addVertex(corners[3].Point2D);\n    va.addVertex(corners[4].Point2D);\n    va.addVertex(corners[5].Point2D);\n    va.addVertex(corners[6].Point2D);\n    va.addVertex(corners[7].Point2D);\n    console.warn(\"have not specified indices for 3d boundary lines array\");\n    // indices should be defined.\n    return va;\n  }\n  GetBoxTriangleMeshVerts() {\n    let va = new VertexArray3D();\n    let corners = this.corners;\n    if (!corners.length) {\n      return va;\n    }\n    va.addVertex(corners[0]);\n    va.addVertex(corners[1]);\n    va.addVertex(corners[2]);\n    va.addVertex(corners[3]);\n    va.addVertex(corners[4]);\n    va.addVertex(corners[5]);\n    va.addVertex(corners[6]);\n    va.addVertex(corners[7]);\n    va.indices = new VertexIndexArray(3);\n    va.indices.push([2, 1, 0]);\n    va.indices.push([3, 2, 0]);\n\n    //back\n    va.indices.push([5, 6, 4]);\n    va.indices.push([6, 7, 4]);\n\n    // left\n    va.indices.push([3, 0, 4]);\n    va.indices.push([7, 3, 4]);\n\n    //right\n    va.indices.push([1, 2, 5]);\n    va.indices.push([2, 6, 5]);\n\n    // top\n    va.indices.push([6, 2, 3]);\n    va.indices.push([7, 6, 3]);\n\n    //bottom\n    va.indices.push([1, 5, 0]);\n    va.indices.push([5, 4, 0]);\n    return va;\n  }\n  boundBounds(b) {\n    let corners = b.corners;\n    for (let c of corners) {\n      this.boundPoint(c);\n    }\n  }\n  static FromBoundingBox2D(bounds2D) {\n    let b = new BoundingBox3D();\n    let corners = bounds2D.corners;\n    for (let c of corners) {\n      b.boundPoint(Vec3.FromVec2(c));\n    }\n    return b;\n  }\n  getBoundsXY() {\n    let b = new BoundingBox2D();\n    let corners = this.corners;\n    for (let c of corners) {\n      b.boundPoint(V2(c.x, c.y));\n    }\n    return b;\n  }\n}","map":{"version":3,"names":["THREE","V3","Vec3","Vec4","V2","Mat4","BoundingBox","BoundingBox2D","VertexArray3D","VertexArray2D","VertexIndexArray","BoundingBox3D","constructor","transform","clone","cfunc","minPoint","maxPoint","FromVec3s","verts","va","FromVec3List","FromVertexArray3D","BoxAtLocationWithSize","location","size","box","hsize","boundPoint","Translation3D","rval","boundVertexPositionArrray","position","nverts","nVerts","vi","getAt","FromTHREEJSObject","obj","threebox","Box3","setFromObject","bounds","min","x","y","z","max","randomPointObjectSpace","rand1","Math","random","rand2","rand3","randomTransformedPoint","getMatrix","times","Point3DH","Point3D","center","plus","localWidth","localHeight","localDepth","p","pcl","From2DHPoint","ndim","nDimensions","elements","length","c","corners","tmat","GetBoundaryLinesVertexArray2D","addVertex","XY","GetBoundaryLinesVertexArray","Point2D","console","warn","GetBoxTriangleMeshVerts","indices","push","boundBounds","b","FromBoundingBox2D","bounds2D","FromVec2","getBoundsXY"],"sources":["/Users/home/Desktop/cs4620-final-project/src/anigraph/geometry/BoundingBox3D.ts"],"sourcesContent":["/***\n * The BoundingBox3D class\n * This class represents a 3D bounding box using\n * - minPoint (Vec3): the point defined by the minimum x, y, and z coordinates being bound.\n * - maxPoint (Vec3): the point defined by the maximum x, y, and z coordinates being bound.\n * - transform (NodeTransform3D): a transformation associated with the bounding box. This allows for\n *   oriented bounding boxes.\n */\n\nimport * as THREE from \"three\";\nimport {V3, Vec3, Vec4, Vec2, V2, Mat4} from \"../math\";\nimport { BoundingBox } from \"./BoundingBox\";\nimport { BoundingBox2D } from \"./BoundingBox2D\";\nimport { VertexArray3D } from \"./VertexArray3D\";\nimport { VertexAttributeArray } from \"./VertexAttributeArray\";\nimport { VertexArray2D } from \"./VertexArray2D\";\nimport { VertexIndexArray } from \"./VertexIndexArray\";\n\n// export class BoundingBox3D extends BoundingBox<Vec3, Mat4>\nexport class BoundingBox3D extends BoundingBox<Vec3, Mat4> {\n  constructor() {\n    super();\n    // this.transform = new Mat4();\n    this.transform = new Mat4();\n  }\n\n  clone(): this {\n    let cfunc: any = this.constructor as any;\n    let clone = new cfunc();\n    clone.minPoint = this.minPoint?.clone();\n    clone.maxPoint = this.maxPoint?.clone();\n    clone.transform = this.transform.clone();\n    return clone;\n  }\n\n  static FromVec3s(verts: Vec3[]) {\n    let va = VertexArray3D.FromVec3List(verts);\n    return BoundingBox3D.FromVertexArray3D(va);\n  }\n\n  /**\n   * Get a bounding box at a specified location with a specified side length\n   * @param location\n   * @param size\n   * @returns {BoundingBox3D}\n   * @constructor\n   */\n  static BoxAtLocationWithSize(location: Vec3, size: number = 100) {\n    let box = new BoundingBox3D();\n    let hsize = size * 0.5;\n    box.boundPoint(V3(hsize, hsize, hsize));\n    box.boundPoint(V3(-hsize, -hsize, -hsize));\n    box.transform = Mat4.Translation3D(location);\n    // box.transform = new Mat4();\n    // box.transform.c3 = new Vec4(location.x, location.y, location.z, 1.0);\n\n    return box;\n  }\n\n  /**\n   * Get a bounding box 3D that bounds points from the given VertexArray3D\n   * @param verts\n   * @returns {BoundingBox3D}\n   * @constructor\n   */\n  static FromVertexArray3D(verts: VertexArray3D) {\n    let rval = new BoundingBox3D();\n    rval.boundVertexPositionArrray(verts.position);\n    return rval;\n  }\n\n  /**\n   * Adjusts the current bounding box to bound all of the points specified in va.\n   * @param va\n   */\n  boundVertexPositionArrray(va: VertexAttributeArray<any>) {\n    let nverts = va.nVerts;\n    for (let vi = 0; vi < nverts; vi++) {\n      this.boundPoint(va.getAt(vi));\n    }\n  }\n\n  /**\n   * Gets the ThreeJS bounds and converts them to a BoundingBox3D object.\n   * @param obj\n   * @returns {BoundingBox3D}\n   * @constructor\n   */\n  static FromTHREEJSObject(obj: THREE.Object3D) {\n    let threebox = new THREE.Box3().setFromObject(obj);\n    let bounds = new BoundingBox3D();\n    bounds.minPoint = V3(threebox.min.x, threebox.min.y, threebox.min.z);\n    bounds.maxPoint = V3(threebox.max.x, threebox.max.y, threebox.max.z);\n    return bounds;\n  }\n\n  /**\n   * Get a random point in the object space (not transformed by this.transform) of the bounding box\n   * @returns {Vec3}\n   */\n  randomPointObjectSpace() {\n    let rand1 = Math.random();\n    let rand2 = Math.random();\n    let rand3 = Math.random();\n    if (!this.minPoint || !this.maxPoint) {\n      return V3();\n    }\n    return V3(\n      this.minPoint.x * rand1 + this.maxPoint.x * (1 - rand1),\n      this.minPoint.y * rand2 + this.maxPoint.y * (1 - rand2),\n      this.minPoint.z * rand3 + this.maxPoint.z * (1 - rand3)\n    );\n  }\n\n  /**\n   * Get a random point from the region bounded by the oriented bounding box\n   * (i.e., the box after transforming by this.transform)\n   * @returns {Vec3}\n   */\n  randomTransformedPoint() {\n    return this.transform\n      .getMatrix()\n      .times(this.randomPointObjectSpace().Point3DH).Point3D;\n  }\n\n  /**\n   * Center of box\n   * @returns {Vec3}\n   */\n  get center() {\n    if (!this.minPoint || !this.maxPoint) {\n      return;\n    }\n    return this.transform\n      .getMatrix()\n      .times(this.minPoint.plus(this.maxPoint).times(0.5).Point3DH).Point3D;\n  }\n\n  /**\n   * The width in object space\n   * @returns {number}\n   */\n  get localWidth() {\n    // @ts-ignore\n    return this.maxPoint.x - this.minPoint.x;\n  }\n\n  /**\n   * The height in object space\n   * @returns {number}\n   */\n  get localHeight() {\n    // @ts-ignore\n    return this.maxPoint.y - this.minPoint.y;\n  }\n\n  /**\n   * The depth in object space\n   * @returns {number}\n   */\n  get localDepth() {\n    // @ts-ignore\n    return this.maxPoint.z - this.minPoint.z;\n  }\n\n  /**\n   * Adjust the bounds to contrain the given point (if adjustment is necessary).\n   * @param p\n   */\n  public boundPoint(p: Vec2 | Vec3 | Vec4): void {\n    if (!this.minPoint || !this.maxPoint) {\n      let pcl =\n        p instanceof Vec3\n          ? p\n          : p instanceof Vec4\n          ? p.Point3D\n          : Vec3.From2DHPoint(p);\n      this.minPoint = pcl.clone();\n      this.maxPoint = pcl.clone();\n      return;\n    }\n    let ndim: number = Math.min(this.minPoint.nDimensions, p.elements.length);\n    for (let c = 0; c < ndim; c++) {\n      if (p.elements[c] < this.minPoint.elements[c]) {\n        this.minPoint.elements[c] = p.elements[c];\n      }\n      if (p.elements[c] > this.maxPoint.elements[c]) {\n        this.maxPoint.elements[c] = p.elements[c];\n      }\n    }\n  }\n\n  /**\n   * [-1, -1, -1]\n   * [1,  -1, -1]\n   * [1,   1, -1]\n   * [-1,  1, -1]\n   * [-1, -1,  1]\n   * [1,  -1,  1]\n   * [1,   1,  1]\n   * [-1,  1,  1]\n   *\n   * near face far face order\n   * @returns {any[] | Vec3[]}\n   */\n  get corners() {\n    let tmat = this.transform.getMatrix();\n    if (!this.minPoint || !this.maxPoint) {\n      return [];\n    }\n    return [\n      tmat.times(this.minPoint.Point3DH).Point3D,\n      tmat.times(V3(this.maxPoint.x, this.minPoint.y, this.minPoint.z).Point3DH)\n        .Point3D,\n      tmat.times(V3(this.maxPoint.x, this.maxPoint.y, this.minPoint.z).Point3DH)\n        .Point3D,\n      tmat.times(V3(this.minPoint.x, this.maxPoint.y, this.minPoint.z).Point3DH)\n        .Point3D,\n      tmat.times(V3(this.minPoint.x, this.minPoint.y, this.maxPoint.z).Point3DH)\n        .Point3D,\n      tmat.times(V3(this.maxPoint.x, this.minPoint.y, this.maxPoint.z).Point3DH)\n        .Point3D,\n      tmat.times(this.maxPoint.Point3DH).Point3D,\n      tmat.times(V3(this.minPoint.x, this.maxPoint.y, this.maxPoint.z).Point3DH)\n        .Point3D,\n    ];\n  }\n\n  /**\n   * gets minpoint, far bottom right, maxpoint, near top left, minpoint\n   * @returns {VertexArray2D}\n   * @constructor\n   */\n  GetBoundaryLinesVertexArray2D() {\n    let va = new VertexArray2D();\n    let corners = this.corners;\n    if (!corners.length) {\n      return va;\n    }\n\n    va.addVertex(corners[0].XY);\n    va.addVertex(corners[1].XY);\n    va.addVertex(corners[2].XY);\n    va.addVertex(corners[3].XY);\n    va.addVertex(corners[0].XY);\n    return va;\n  }\n\n  GetBoundaryLinesVertexArray() {\n    let va = new VertexArray2D();\n    let corners = this.corners;\n    if (!corners.length) {\n      return va;\n    }\n\n    va.addVertex(corners[0].Point2D);\n    va.addVertex(corners[1].Point2D);\n    va.addVertex(corners[2].Point2D);\n    va.addVertex(corners[3].Point2D);\n    va.addVertex(corners[4].Point2D);\n    va.addVertex(corners[5].Point2D);\n    va.addVertex(corners[6].Point2D);\n    va.addVertex(corners[7].Point2D);\n    console.warn(\"have not specified indices for 3d boundary lines array\");\n    // indices should be defined.\n    return va;\n  }\n\n  GetBoxTriangleMeshVerts() {\n    let va = new VertexArray3D();\n    let corners = this.corners;\n    if (!corners.length) {\n      return va;\n    }\n\n    va.addVertex(corners[0]);\n    va.addVertex(corners[1]);\n    va.addVertex(corners[2]);\n    va.addVertex(corners[3]);\n    va.addVertex(corners[4]);\n    va.addVertex(corners[5]);\n    va.addVertex(corners[6]);\n    va.addVertex(corners[7]);\n\n    va.indices = new VertexIndexArray(3);\n\n    va.indices.push([2, 1, 0]);\n    va.indices.push([3, 2, 0]);\n\n    //back\n    va.indices.push([5, 6, 4]);\n    va.indices.push([6, 7, 4]);\n\n    // left\n    va.indices.push([3, 0, 4]);\n    va.indices.push([7, 3, 4]);\n\n    //right\n    va.indices.push([1, 2, 5]);\n    va.indices.push([2, 6, 5]);\n\n    // top\n    va.indices.push([6, 2, 3]);\n    va.indices.push([7, 6, 3]);\n\n    //bottom\n    va.indices.push([1, 5, 0]);\n    va.indices.push([5, 4, 0]);\n\n    return va;\n  }\n\n  boundBounds(b: BoundingBox<any, any>) {\n    let corners = b.corners;\n    for (let c of corners) {\n      this.boundPoint(c);\n    }\n  }\n\n  static FromBoundingBox2D(bounds2D: BoundingBox2D) {\n    let b = new BoundingBox3D();\n    let corners = bounds2D.corners;\n    for (let c of corners) {\n      b.boundPoint(Vec3.FromVec2(c));\n    }\n    return b;\n  }\n\n  getBoundsXY():BoundingBox2D{\n    let b = new BoundingBox2D();\n    let corners = this.corners;\n    for (let c of corners) {\n      b.boundPoint(V2(c.x, c.y));\n    }\n    return b;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}