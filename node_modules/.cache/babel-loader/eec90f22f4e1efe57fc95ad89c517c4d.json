{"ast":null,"code":"var _dec, _class, _class2;\nimport { ATerrainModel } from \"../../../../anigraph/scene/nodes/terrain/ATerrainModel\";\nimport { ASerializable } from \"../../../../anigraph\";\nimport { TerrainShaderModel } from \"./TerrainShaderModel\";\nimport { ATexture } from \"../../../../anigraph/rendering/ATexture\";\nimport { ADataTextureFloat1D } from \"../../../../anigraph/rendering/image\";\nimport * as THREE from \"three\";\nimport { AppConfigs } from \"../../../AppConfigs\";\nexport let TerrainModel = (_dec = ASerializable(\"TerrainModel\"), _dec(_class = (_class2 = class TerrainModel extends ATerrainModel {\n  /**\n   * The shader model class\n   */\n\n  /**\n   * Reusable instance of the shader model, which is a factory for creating shader materials\n   */\n\n  /**\n   * Function to load the shader\n   */\n  static async LoadShader() {\n    this.ShaderModel = await this.ShaderModelClass.CreateModel(\"terrain\");\n  }\n  constructor(width, height, widthSegments, heightSegments, transform, textureWrapX, textureWrapY) {\n    super(width, height, widthSegments, heightSegments, transform);\n    this.textureWrapX = 5;\n    this.textureWrapY = 5;\n    if (textureWrapX !== undefined) {\n      this.textureWrapX = textureWrapX;\n    }\n    if (textureWrapY !== undefined) {\n      this.textureWrapY = textureWrapY;\n    }\n  }\n  getTerrainHeightAtPoint(p) {\n    //you can access height map pixels using something like this:\n    /**\n     *  you can access height map pixels using something like this:\n     *  this.heightMap.pixelData.getPixelNN(5, 5);\n     */\n    return 0;\n  }\n  static async Create(diffuseMap, width, height, widthSegments, heightSegments, transform, wrapTextureX, wrapTextureY) {\n    /**\n     * If the terrain shader isn't loaded, load it...\n     */\n    if (TerrainModel.ShaderModel === undefined) {\n      await TerrainModel.LoadShader();\n    }\n\n    /**\n     * Create and initialize the terrain with the provided texture\n     */\n    let terrain = new this(width, height, widthSegments, heightSegments, transform, wrapTextureX, wrapTextureY);\n    await terrain.init(diffuseMap);\n    return terrain;\n  }\n  async init(diffuseMap, useDataTexture) {\n    /**\n     * Set the diffuse color map if provided with a texture, or load it if provided with the path of a texture\n     */\n    if (diffuseMap instanceof ATexture) {\n      this.diffuseMap = diffuseMap;\n    } else {\n      this.diffuseMap = await ATexture.LoadAsync(diffuseMap);\n    }\n\n    /**\n     * If you want to use a data texture to implement displacement map terrain, create a heightMap data texture.\n     * Most recent machines should support this feature, but I haven't verified on all platforms.\n     * If it seems to fail, you might set useDataTexture to false by default.\n     */\n    if (useDataTexture !== null && useDataTexture !== void 0 ? useDataTexture : AppConfigs.UseTerrainDataTexture) {\n      this.heightMap = ADataTextureFloat1D.CreateSolid(this.widthSegments, this.heightSegments, 0.5);\n      this.heightMap.setMinFilter(THREE.LinearFilter);\n      this.heightMap.setMagFilter(THREE.LinearFilter);\n      this.reRollHeightMap();\n    }\n    this.setMaterial(TerrainModel.ShaderModel.CreateMaterial(this.diffuseMap, this.heightMap));\n  }\n\n  /**\n   * Can be used to re-randomize height map\n   * You may find the code:\n   * ```\n   * let simplexNoise = makeNoise2D(randomgen.rand);\n   * let noiseAtXY = simplexNoise(x, y)\n   * ```\n   * Useful for generating simplex noise\n   *\n   * @param seed\n   * @param gridResX\n   * @param gridResY\n   */\n  reRollHeightMap(seed) {\n    let gridResX = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n    let gridResY = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n    for (let y = 0; y < this.heightMap.height; y++) {\n      for (let x = 0; x < this.heightMap.width; x++) {\n        /**\n         * For the starter code, we are just setting the map to 0\n         */\n        this.heightMap.setPixelNN(x, y, 0);\n        // this.heightMap.setPixelNN(x, y, Math.sin(2*x)*0.2+Math.sin(2*y)*0.2);\n      }\n    }\n\n    this.heightMap.setTextureNeedsUpdate();\n  }\n}, _class2.ShaderModelClass = TerrainShaderModel, _class2.ShaderModel = void 0, _class2)) || _class);","map":{"version":3,"names":["ATerrainModel","ASerializable","TerrainShaderModel","ATexture","ADataTextureFloat1D","THREE","AppConfigs","TerrainModel","LoadShader","ShaderModel","ShaderModelClass","CreateModel","constructor","width","height","widthSegments","heightSegments","transform","textureWrapX","textureWrapY","undefined","getTerrainHeightAtPoint","p","Create","diffuseMap","wrapTextureX","wrapTextureY","terrain","init","useDataTexture","LoadAsync","UseTerrainDataTexture","heightMap","CreateSolid","setMinFilter","LinearFilter","setMagFilter","reRollHeightMap","setMaterial","CreateMaterial","seed","gridResX","gridResY","y","x","setPixelNN","setTextureNeedsUpdate"],"sources":["/Users/home/Desktop/cs4620-final-project/src/app/main/Nodes/Terrain/TerrainModel.ts"],"sourcesContent":["import {ATerrainModel} from \"../../../../anigraph/scene/nodes/terrain/ATerrainModel\";\nimport {\n    ASerializable,\n    CreatesShaderModels, SeededRandom, Vec2\n} from \"../../../../anigraph\";\nimport {TerrainShaderModel} from \"./TerrainShaderModel\";\nimport type {TransformationInterface} from \"../../../../anigraph\";\nimport {ATexture} from \"../../../../anigraph/rendering/ATexture\";\nimport {ADataTextureFloat1D} from \"../../../../anigraph/rendering/image\";\nimport * as THREE from \"three\";\nimport {makeNoise2D} from \"fast-simplex-noise\";\nimport {AppConfigs} from \"../../../AppConfigs\";\n\n@ASerializable(\"TerrainModel\")\nexport class TerrainModel extends ATerrainModel{\n    /**\n     * The shader model class\n     */\n    static ShaderModelClass:CreatesShaderModels=TerrainShaderModel;\n\n    /**\n     * Reusable instance of the shader model, which is a factory for creating shader materials\n     */\n    static ShaderModel:TerrainShaderModel;\n\n    /**\n     * Function to load the shader\n     */\n    static async LoadShader(...args:any[]){\n        this.ShaderModel = await this.ShaderModelClass.CreateModel(\"terrain\")\n    }\n\n\n    textureWrapX:number=5;\n    textureWrapY:number=5;\n\n    constructor(\n        width?:number,\n        height?:number,\n        widthSegments?:number,\n        heightSegments?:number,\n        transform?:TransformationInterface,\n        textureWrapX?:number,\n        textureWrapY?:number\n        ) {\n        super(width, height, widthSegments, heightSegments, transform);\n        if(textureWrapX!==undefined){this.textureWrapX = textureWrapX;}\n        if(textureWrapY!==undefined){this.textureWrapY=textureWrapY;}\n    }\n\n    getTerrainHeightAtPoint(p:Vec2){\n        //you can access height map pixels using something like this:\n        /**\n         *  you can access height map pixels using something like this:\n         *  this.heightMap.pixelData.getPixelNN(5, 5);\n         */\n        return 0;\n    }\n\n    static async Create(\n        diffuseMap:string|ATexture,\n        width?:number,\n        height?:number,\n        widthSegments?:number,\n        heightSegments?:number,\n        transform?:TransformationInterface,\n        wrapTextureX?:number,\n        wrapTextureY?:number,\n        ...args:any[]){\n\n        /**\n         * If the terrain shader isn't loaded, load it...\n         */\n        if(TerrainModel.ShaderModel === undefined){\n            await TerrainModel.LoadShader();\n        }\n\n        /**\n         * Create and initialize the terrain with the provided texture\n         */\n        let terrain = new this(width, height, widthSegments, heightSegments, transform, wrapTextureX,wrapTextureY);\n        await terrain.init(diffuseMap);\n        return terrain;\n    }\n\n    async init(diffuseMap:string|ATexture, useDataTexture?:boolean){\n\n        /**\n         * Set the diffuse color map if provided with a texture, or load it if provided with the path of a texture\n         */\n        if(diffuseMap instanceof ATexture){\n            this.diffuseMap = diffuseMap;\n        }else{\n            this.diffuseMap = await ATexture.LoadAsync(diffuseMap);\n        }\n\n\n        /**\n         * If you want to use a data texture to implement displacement map terrain, create a heightMap data texture.\n         * Most recent machines should support this feature, but I haven't verified on all platforms.\n         * If it seems to fail, you might set useDataTexture to false by default.\n         */\n        if(useDataTexture??AppConfigs.UseTerrainDataTexture){\n            this.heightMap = ADataTextureFloat1D.CreateSolid(this.widthSegments, this.heightSegments, 0.5)\n            this.heightMap.setMinFilter(THREE.LinearFilter);\n            this.heightMap.setMagFilter(THREE.LinearFilter);\n            this.reRollHeightMap();\n        }\n\n        this.setMaterial(TerrainModel.ShaderModel.CreateMaterial(\n            this.diffuseMap,\n            this.heightMap,\n        ));\n    }\n\n    /**\n     * Can be used to re-randomize height map\n     * You may find the code:\n     * ```\n     * let simplexNoise = makeNoise2D(randomgen.rand);\n     * let noiseAtXY = simplexNoise(x, y)\n     * ```\n     * Useful for generating simplex noise\n     *\n     * @param seed\n     * @param gridResX\n     * @param gridResY\n     */\n    reRollHeightMap(seed?:number, gridResX:number=5, gridResY:number=5){\n        for(let y=0;y<this.heightMap.height;y++){\n            for(let x=0;x<this.heightMap.width;x++) {\n                /**\n                 * For the starter code, we are just setting the map to 0\n                 */\n                this.heightMap.setPixelNN(x, y, 0);\n                // this.heightMap.setPixelNN(x, y, Math.sin(2*x)*0.2+Math.sin(2*y)*0.2);\n            }\n        }\n        this.heightMap.setTextureNeedsUpdate();\n    }\n\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}