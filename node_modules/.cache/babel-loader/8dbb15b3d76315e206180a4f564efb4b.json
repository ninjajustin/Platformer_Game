{"ast":null,"code":"var _dec, _class;\n/**\n * # ASelection\n * Template class for selections of things. Allows for functions that are called upon 2d and deselection.\n */\n// import objectHash from \"object-hash\";\nimport { ASerializable } from \"../aserial\";\nexport let SelectionEvents;\n(function (SelectionEvents) {\n  SelectionEvents[\"SelectionChanged\"] = \"SelectionChanged\";\n  SelectionEvents[\"SelectionItemEnter\"] = \"SelectionItemEnter\";\n  SelectionEvents[\"SelectionItemUpdate\"] = \"SelectionItemUpdate\";\n  SelectionEvents[\"SelectionItemExit\"] = \"SelectionItemExit\";\n})(SelectionEvents || (SelectionEvents = {}));\nexport let ASelection = (_dec = ASerializable(\"ASelection\"), _dec(_class = class ASelection {\n  // protected abstract _selectionMap:{[key:string]:T};\n\n  items() {\n    return Object.values(this._selectionMap);\n  }\n  get nSelected() {\n    return Object.keys(this._selectionMap).length;\n  }\n\n  /**\n   * This function takes an object of type T and returns the key used for storing that object in this._selectionMap.\n   * The key should be unique to a given object, so things like hashes on uids.\n   * By default, it uses a hash, but this can be overwritten for specific 2d types.\n   * @param item\n   * @returns {any}\n   * @private\n   */\n  static _calcKey(item) {\n    if (typeof item == \"object\" && \"uid\" in item) {\n      return item.uid;\n    } else {\n      // return objectHash(item);\n      throw new Error(`Not sure how to hash ${item} in ASelection!`);\n    }\n  }\n\n  /**\n   * The constructor optionally takes a list of items to select.\n   * @param items\n   */\n  constructor(items, enterCallback, updateCallback, exitCallback) {\n    this._selectionMap = void 0;\n    this._enterCallback = void 0;\n    this._updateCallback = void 0;\n    this._exitCallback = void 0;\n    this._selectionMap = {};\n    if (items !== undefined) {\n      this.set(items);\n    }\n    this._enterCallback = enterCallback ? enterCallback : a => {\n      return;\n    };\n    this._updateCallback = updateCallback ? updateCallback : a => {\n      return;\n    };\n    this._exitCallback = exitCallback ? exitCallback : a => {\n      return;\n    };\n  }\n  mapOverElements(func) {\n    let rval = [];\n    let items = this.items();\n    for (let i of items) {\n      rval.push(func(i));\n    }\n    return rval;\n  }\n\n  /**\n   * like mapOverElements, but doesn't add an entry for an element if func(a) doesn't return anything.\n   * @param func\n   * @returns {any[]}\n   */\n  getFilteredList(func) {\n    let rval = [];\n    let items = this.items();\n    for (let i of items) {\n      let ival = func(i);\n      if (ival !== undefined) {\n        rval.push(ival);\n      }\n    }\n    return rval;\n  }\n\n  /**\n   * Returns the 2d in simple list form.\n   * @returns {T[]}\n   */\n  list() {\n    const rval = new Array();\n    for (let key in this._selectionMap) {\n      rval.push(this._selectionMap[key]);\n    }\n    return rval;\n  }\n\n  /**\n   * Keys for selected objects\n   * @returns {string[]}\n   */\n  keys() {\n    return Object.keys(this._selectionMap);\n  }\n\n  /**\n   * deselect an item\n   * @param item\n   */\n  deselect(item) {\n    let triggerCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this._deselectKey(this._getKeyForItem(item));\n    if (triggerCallbacks) {\n      this._exitCallback(item, this);\n    }\n  }\n\n  /**\n   * deselect the item with a specified key\n   * @param key\n   * @private\n   */\n  _deselectKey(key) {\n    delete this._selectionMap[key];\n  }\n\n  /**\n   * deselect everything\n   */\n  _deselectAll() {\n    if (this.nSelected === 0) {\n      return;\n    }\n    this._selectionMap = {};\n    // for(let key in this._selectionMap){\n    //     this._deselectKey(key);\n    // }\n  }\n\n  select(item) {\n    let triggerCallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    this._selectKey(this._getKeyForItem(item), item);\n    if (triggerCallback) {\n      this._enterCallback(item, this);\n    }\n  }\n  _selectKey(key, item) {\n    this._selectionMap[key] = item;\n  }\n  toggleSelected(item) {\n    let triggerCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let key = this._getKeyForItem(item);\n    if (this._selectionMap[key]) {\n      this._deselectKey(key);\n      if (triggerCallbacks) {\n        this._exitCallback(item, this);\n      }\n    } else {\n      this._selectionMap[key] = item;\n      if (triggerCallbacks) {\n        this._enterCallback(item, this);\n      }\n    }\n  }\n\n  //\n  // /**\n  //  * Select item\n  //  * @param item\n  //  */\n  // select(item:T){\n  //     this._selectionMap[this._getKeyForItem(item)]=item;\n  // }\n\n  /**\n   * Get key for a specified item\n   * @param item\n   * @returns {any}\n   * @private\n   */\n  _getKeyForItem(item) {\n    return this.constructor._calcKey(item);\n  }\n\n  /**\n   * Set the 2d\n   * @param items - What the 2d should be after the operation is complete\n   * @param exitCallback - a function to run on items that leave the 2d\n   * @param enterCallback - a function to run on items that enter the 2d\n   * @param updateCallback - a function to run on items that stay in the 2d\n   */\n  set(items) {\n    let triggerCallbacks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let exitCallback = arguments.length > 2 ? arguments[2] : undefined;\n    let enterCallback = arguments.length > 3 ? arguments[3] : undefined;\n    let updateCallback = arguments.length > 4 ? arguments[4] : undefined;\n    exitCallback = exitCallback ? exitCallback : this._exitCallback;\n    enterCallback = enterCallback ? enterCallback : this._enterCallback;\n    updateCallback = updateCallback ? updateCallback : this._updateCallback;\n    if (items === undefined || items.length === 0) {\n      if (exitCallback !== undefined) {\n        const exiting = Object.values(this._selectionMap);\n        this._deselectAll();\n        for (let leaving of exiting) {\n          exitCallback(leaving, this);\n        }\n      } else {\n        this._deselectAll();\n      }\n      return;\n    } else {\n      const newkeys = [];\n      const enter = [];\n      const exit = [];\n      const update = [];\n      for (let item of items) {\n        let nkey = this._getKeyForItem(item);\n        newkeys.push(nkey);\n        if (nkey in this._selectionMap) {\n          update.push(item);\n        } else {\n          enter.push(item);\n        }\n      }\n      for (let oldkey in this._selectionMap) {\n        if (!(newkeys.indexOf(oldkey) > -1)) {\n          exit.push(this._selectionMap[oldkey]);\n        }\n      }\n\n      // for (let ex of exit) {\n      //     this.deselect(ex);\n      // }\n      // for(let en of enter){\n      //     this.select(en);\n      // }\n\n      // if the 2d is exactly the same, return without changing anything\n      if (update.length === items.length && update.length === this.nSelected) {\n        if (updateCallback) {\n          for (let up of update) {\n            updateCallback(up, this);\n          }\n        }\n        return;\n      }\n      let newmap = {};\n      for (let up of update) {\n        newmap[this._getKeyForItem(up)] = up;\n      }\n      for (let n of enter) {\n        newmap[this._getKeyForItem(n)] = n;\n      }\n      this._selectionMap = newmap;\n      if (exitCallback) {\n        for (let ex of exit) {\n          exitCallback(ex, this);\n        }\n      }\n      if (enterCallback) {\n        for (let en of enter) {\n          enterCallback(en, this);\n        }\n      }\n      if (updateCallback) {\n        for (let up of update) {\n          updateCallback(up, this);\n        }\n      }\n      return;\n    }\n  }\n}) || _class);","map":{"version":3,"names":["ASerializable","SelectionEvents","ASelection","items","Object","values","_selectionMap","nSelected","keys","length","_calcKey","item","uid","Error","constructor","enterCallback","updateCallback","exitCallback","_enterCallback","_updateCallback","_exitCallback","undefined","set","a","mapOverElements","func","rval","i","push","getFilteredList","ival","list","Array","key","deselect","triggerCallbacks","_deselectKey","_getKeyForItem","_deselectAll","select","triggerCallback","_selectKey","toggleSelected","exiting","leaving","newkeys","enter","exit","update","nkey","oldkey","indexOf","up","newmap","n","ex","en"],"sources":["/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/src/anigraph/base/aobject/ASelection.ts"],"sourcesContent":["/**\n * # ASelection\n * Template class for selections of things. Allows for functions that are called upon 2d and deselection.\n */\n// import objectHash from \"object-hash\";\nimport { ASerializable } from \"../aserial\";\n\nexport enum SelectionEvents {\n  SelectionChanged = \"SelectionChanged\",\n  SelectionItemEnter = \"SelectionItemEnter\",\n  SelectionItemUpdate = \"SelectionItemUpdate\",\n  SelectionItemExit = \"SelectionItemExit\",\n}\n\n@ASerializable(\"ASelection\")\nexport class ASelection<T> {\n  protected _selectionMap: { [key: string]: T };\n\n  public _enterCallback!: (enteringSelection: T, selection?: this) => void;\n  public _updateCallback!: (remainingInSelection: T, selection?: this) => void;\n  public _exitCallback!: (leavingSelection: T, selection?: this) => void;\n\n  // protected abstract _selectionMap:{[key:string]:T};\n\n  items() {\n    return Object.values(this._selectionMap);\n  }\n\n  get nSelected() {\n    return Object.keys(this._selectionMap).length;\n  }\n\n  /**\n   * This function takes an object of type T and returns the key used for storing that object in this._selectionMap.\n   * The key should be unique to a given object, so things like hashes on uids.\n   * By default, it uses a hash, but this can be overwritten for specific 2d types.\n   * @param item\n   * @returns {any}\n   * @private\n   */\n  static _calcKey(item: any) {\n    if (typeof item == \"object\" && \"uid\" in item) {\n      return item.uid;\n    } else {\n      // return objectHash(item);\n      throw new Error(`Not sure how to hash ${item} in ASelection!`);\n    }\n  }\n\n  /**\n   * The constructor optionally takes a list of items to select.\n   * @param items\n   */\n  constructor(\n    items?: T[],\n    enterCallback?: (enteringSelection: T, selection?: ASelection<T>) => void,\n    updateCallback?: (\n      remainingInSelection: T,\n      selection?: ASelection<T>\n    ) => void,\n    exitCallback?: (leavingSelection: T, selection?: ASelection<T>) => void\n  ) {\n    this._selectionMap = {};\n    if (items !== undefined) {\n      this.set(items);\n    }\n    this._enterCallback = enterCallback\n      ? enterCallback\n      : (a: T) => {\n          return;\n        };\n    this._updateCallback = updateCallback\n      ? updateCallback\n      : (a: T) => {\n          return;\n        };\n    this._exitCallback = exitCallback\n      ? exitCallback\n      : (a: T) => {\n          return;\n        };\n  }\n\n  mapOverElements(func: (a: T) => any) {\n    let rval = [];\n    let items = this.items();\n    for (let i of items) {\n      rval.push(func(i));\n    }\n    return rval;\n  }\n\n  /**\n   * like mapOverElements, but doesn't add an entry for an element if func(a) doesn't return anything.\n   * @param func\n   * @returns {any[]}\n   */\n  getFilteredList(func: (a: T) => any) {\n    let rval = [];\n    let items = this.items();\n    for (let i of items) {\n      let ival = func(i);\n      if (ival !== undefined) {\n        rval.push(ival);\n      }\n    }\n    return rval;\n  }\n\n  /**\n   * Returns the 2d in simple list form.\n   * @returns {T[]}\n   */\n  list() {\n    const rval = new Array<T>();\n    for (let key in this._selectionMap) {\n      rval.push(this._selectionMap[key]);\n    }\n    return rval;\n  }\n\n  /**\n   * Keys for selected objects\n   * @returns {string[]}\n   */\n  keys() {\n    return Object.keys(this._selectionMap);\n  }\n\n  /**\n   * deselect an item\n   * @param item\n   */\n  deselect(item: T, triggerCallbacks = true) {\n    this._deselectKey(this._getKeyForItem(item));\n    if (triggerCallbacks) {\n      this._exitCallback(item, this);\n    }\n  }\n\n  /**\n   * deselect the item with a specified key\n   * @param key\n   * @private\n   */\n  _deselectKey(key: string) {\n    delete this._selectionMap[key];\n  }\n\n  /**\n   * deselect everything\n   */\n  _deselectAll() {\n    if (this.nSelected === 0) {\n      return;\n    }\n    this._selectionMap = {};\n    // for(let key in this._selectionMap){\n    //     this._deselectKey(key);\n    // }\n  }\n\n  select(item: T, triggerCallback: boolean = true) {\n    this._selectKey(this._getKeyForItem(item), item);\n    if (triggerCallback) {\n      this._enterCallback(item, this);\n    }\n  }\n\n  _selectKey(key: string, item: T) {\n    this._selectionMap[key] = item;\n  }\n\n  toggleSelected(item: T, triggerCallbacks = true) {\n    let key = this._getKeyForItem(item);\n    if (this._selectionMap[key]) {\n      this._deselectKey(key);\n      if (triggerCallbacks) {\n        this._exitCallback(item, this);\n      }\n    } else {\n      this._selectionMap[key] = item;\n      if (triggerCallbacks) {\n        this._enterCallback(item, this);\n      }\n    }\n  }\n\n  //\n  // /**\n  //  * Select item\n  //  * @param item\n  //  */\n  // select(item:T){\n  //     this._selectionMap[this._getKeyForItem(item)]=item;\n  // }\n\n  /**\n   * Get key for a specified item\n   * @param item\n   * @returns {any}\n   * @private\n   */\n  _getKeyForItem(item: T) {\n    return (this.constructor as typeof ASelection)._calcKey(item);\n  }\n\n  /**\n   * Set the 2d\n   * @param items - What the 2d should be after the operation is complete\n   * @param exitCallback - a function to run on items that leave the 2d\n   * @param enterCallback - a function to run on items that enter the 2d\n   * @param updateCallback - a function to run on items that stay in the 2d\n   */\n  public set(\n    items?: T[],\n    triggerCallbacks = true,\n    exitCallback?: (item: T, selection?: this) => void,\n    enterCallback?: (item: T, selection?: this) => void,\n    updateCallback?: (item: T, selection?: this) => void\n  ) {\n    exitCallback = exitCallback ? exitCallback : this._exitCallback;\n    enterCallback = enterCallback ? enterCallback : this._enterCallback;\n    updateCallback = updateCallback ? updateCallback : this._updateCallback;\n\n    if (items === undefined || items.length === 0) {\n      if (exitCallback !== undefined) {\n        const exiting = Object.values(this._selectionMap);\n        this._deselectAll();\n        for (let leaving of exiting) {\n          exitCallback(leaving, this);\n        }\n      } else {\n        this._deselectAll();\n      }\n      return;\n    } else {\n      const newkeys = [];\n      const enter = [];\n      const exit = [];\n      const update = [];\n\n      for (let item of items) {\n        let nkey = this._getKeyForItem(item);\n        newkeys.push(nkey);\n        if (nkey in this._selectionMap) {\n          update.push(item);\n        } else {\n          enter.push(item);\n        }\n      }\n      for (let oldkey in this._selectionMap) {\n        if (!(newkeys.indexOf(oldkey) > -1)) {\n          exit.push(this._selectionMap[oldkey]);\n        }\n      }\n\n      // for (let ex of exit) {\n      //     this.deselect(ex);\n      // }\n      // for(let en of enter){\n      //     this.select(en);\n      // }\n\n      // if the 2d is exactly the same, return without changing anything\n      if (update.length === items.length && update.length === this.nSelected) {\n        if (updateCallback) {\n          for (let up of update) {\n            updateCallback(up, this);\n          }\n        }\n        return;\n      }\n\n      let newmap: { [key: string]: T } = {};\n      for (let up of update) {\n        newmap[this._getKeyForItem(up)] = up;\n      }\n      for (let n of enter) {\n        newmap[this._getKeyForItem(n)] = n;\n      }\n      this._selectionMap = newmap;\n\n      if (exitCallback) {\n        for (let ex of exit) {\n          exitCallback(ex, this);\n        }\n      }\n      if (enterCallback) {\n        for (let en of enter) {\n          enterCallback(en, this);\n        }\n      }\n      if (updateCallback) {\n        for (let up of update) {\n          updateCallback(up, this);\n        }\n      }\n      return;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}