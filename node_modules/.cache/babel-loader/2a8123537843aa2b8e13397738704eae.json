{"ast":null,"code":"import _initializerDefineProperty from \"/Users/home/Desktop/cs4620-final-project/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js\";\nimport _applyDecoratedDescriptor from \"/Users/home/Desktop/cs4620-final-project/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js\";\nimport _initializerWarningHelper from \"/Users/home/Desktop/cs4620-final-project/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js\";\nvar _dec, _class, _class2, _descriptor, _class3;\nimport { AModel } from \"../base/amvc/AModel\";\nimport { AObjectNodeEvents, AObjectState } from \"../base/aobject\";\nimport { ASerializable } from \"../base/aserial\";\nimport { AMaterialManager } from \"../rendering/material\";\nimport { AInteractionModeMap, BasicInteractionModes } from \"../interaction\";\nimport { AClock } from \"../time\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { Mutex } from 'async-mutex';\nexport let SceneEvents;\n(function (SceneEvents) {\n  SceneEvents[\"SceneNodeModelAdded\"] = \"SceneNodeModelAdded\";\n  SceneEvents[\"NodeAdded\"] = \"NodeAdded\";\n  SceneEvents[\"NodeRemoved\"] = \"NodeRemoved\";\n  SceneEvents[\"NodeMoved\"] = \"NodeMoved\";\n  SceneEvents[\"UpdateComponent\"] = \"UpdateComponent\";\n})(SceneEvents || (SceneEvents = {}));\nvar ASCENEMODEL_EVENT_HANDLES;\n(function (ASCENEMODEL_EVENT_HANDLES) {\n  ASCENEMODEL_EVENT_HANDLES[\"SCENE_NODE_ADDED\"] = \"SCENE_NODE_ADDED\";\n  ASCENEMODEL_EVENT_HANDLES[\"SCENE_NODE_REMOVED\"] = \"SCENE_NODE_REMOVED\";\n})(ASCENEMODEL_EVENT_HANDLES || (ASCENEMODEL_EVENT_HANDLES = {}));\nexport let ASceneModel = (_dec = ASerializable(\"ASceneModel\"), _dec(_class = (_class2 = (_class3 = class ASceneModel extends AModel {\n  get materials() {\n    return this._materials;\n  }\n  get initializedPromise() {\n    return this._initializedPromise;\n  }\n  get camera() {\n    return this.cameraModel.camera;\n  }\n  get eventTarget() {\n    return this._interactionDOMElement;\n  }\n\n  /**\n   * Interaction mode map. Has a .modes property that maps mode names to AInteractionModes.\n   * @type {AInteractionModeMap}\n   * @protected\n   */\n\n  get clock() {\n    return this._clock;\n  }\n  // abstract initShaders():Promise<void>;\n  async initShaders() {\n    this._materials = new AMaterialManager();\n  }\n  /**\n   * # Initialization:\n   * Scene models are initialized asynchronously, and initialization may be triggered lazily by the first controller\n   * that tries to access the model (it can also be triggered more proactively, depending on the application).\n   * The scene model has a state variable `isInitialized` that is set to false in the constructor, but flipped to true\n   * after initialization is performed.\n   *\n   * To trigger initialization, the function `confirmInitialized` must be called at least once.\n   *\n   *\n   */\n  async confirmInitialized() {\n    await this.initMutex.runExclusive(async () => {\n      if (!this._isInitialized) {\n        this._isInitialized = await this._asyncInitScene();\n        this._isInitialized = true;\n        this._clock.play();\n      }\n    });\n  }\n  async _asyncInitScene() {\n    await this.initShaders();\n    await this.PreloadAssets();\n    await this.initScene();\n    return true;\n  }\n  async PreloadAssets() {\n    // this.materials.setMaterialModel()\n    // await this.materials.materialsLoadedPromise;\n  }\n  get modelMap() {\n    return this._modelMap;\n  }\n  get isInitialized() {\n    return this._isInitialized;\n  }\n  addIsInitializedListener(callback, handle) {\n    let synchronous = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return this.addStateKeyListener('_isInitialized', callback, handle, synchronous);\n  }\n  addComponentUpdateListener(callback, handle) {\n    return this.addEventListener(ASceneModel.SceneEvents.UpdateComponent, callback, handle);\n  }\n  signalComponentUpdate() {\n    this.signalEvent(ASceneModel.SceneEvents.UpdateComponent);\n  }\n  _addModel(model) {\n    if (this.hasModel(model)) {\n      throw new Error(`Model ${model} with uid ${model.uid} already in ${this.serializationLabel}`);\n    }\n    this.modelMap[model.uid] = model;\n    this.signalEvent(SceneEvents.NodeAdded, model);\n  }\n  _removeModel(model) {\n    delete this._modelMap[model.uid];\n    this.signalEvent(SceneEvents.NodeRemoved, model);\n  }\n  hasModel(model) {\n    return model.uid in this.modelMap;\n  }\n  hasModelID(modelID) {\n    return modelID in this.modelMap;\n  }\n  constructor(name) {\n    super(name);\n    _initializerDefineProperty(this, \"_isInitialized\", _descriptor, this);\n    this.cameraModel = void 0;\n    this._materials = void 0;\n    this._clock = void 0;\n    this._interactionDOMElement = void 0;\n    this._initializedPromise = void 0;\n    this.initMutex = void 0;\n    this._interactions = void 0;\n    this._currentInteractionModeName = void 0;\n    this._modelMap = {};\n    this.initMutex = new Mutex();\n    this._clock = new AClock();\n    this._interactionDOMElement = document;\n    this._interactions = new AInteractionModeMap(this);\n    this._currentInteractionModeName = BasicInteractionModes.Default;\n    this._isInitialized = false;\n    // this._materials = new AMaterialManager();\n\n    this._initSceneGraphSubscriptions();\n    // this.materials = new AMaterialManager();\n    // appstate assigns this when model is created\n    // this.appState = GetAppState();\n  }\n\n  _initSceneGraphSubscriptions() {\n    const self = this;\n    this.subscribe(this.addEventListener(AObjectNodeEvents.NewDescendant, descendant => {\n      self._addModel(descendant);\n    }), ASCENEMODEL_EVENT_HANDLES.SCENE_NODE_ADDED);\n    this.subscribe(this.addEventListener(AObjectNodeEvents.DescendantRemoved, descendant => {\n      self._removeModel(descendant);\n    }), ASCENEMODEL_EVENT_HANDLES.SCENE_NODE_REMOVED);\n  }\n  async loadShader(name) {\n    return this.materials.loadShaderModel(name);\n  }\n  async loadLineShader(name) {\n    return this.materials.loadLineShaderModel(name);\n  }\n  getDescendantList() {\n    return super.getDescendantList();\n  }\n  addTimedAction(callback, duration, actionOverCallback, tween, handle) {\n    if (handle && handle in this._subscriptions) {\n      return;\n    }\n    const self = this;\n    const subscriptionHandle = handle !== null && handle !== void 0 ? handle : uuidv4();\n    this.subscribe(this._clock.CreateTimedAction(callback, duration, () => {\n      self.unsubscribe(subscriptionHandle);\n      if (actionOverCallback) {\n        actionOverCallback();\n      }\n    }, tween), subscriptionHandle);\n  }\n\n  /**\n   * Getter for the current interaction mode.\n   * @returns {AInteractionMode}\n   */\n  get interactionMode() {\n    return this._interactions.modes[this._currentInteractionModeName];\n  }\n\n  /**\n   * Add an interaction to the current mode.\n   * @param interaction\n   */\n  addInteraction(interaction) {\n    this.interactionMode.addInteraction(interaction);\n    // interaction.owner = this;\n    return interaction;\n  }\n  activateInteractions() {\n    this.interactionMode.activate();\n  }\n  setCurrentInteractionMode(name) {\n    this.interactionMode.deactivate();\n    let activeMode = name ? name : BasicInteractionModes.Default;\n    this._interactions.setActiveMode(activeMode);\n    this._currentInteractionModeName = activeMode;\n  }\n  defineInteractionMode(name, mode) {\n    this._interactions.defineMode(name, mode);\n  }\n  clearInteractionMode(name) {\n    this._interactions.undefineMode(name);\n  }\n  isInteractionModeDefined(name) {\n    return this._interactions.modeIsDefined(name);\n  }\n}, _class3.SceneEvents = SceneEvents, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"_isInitialized\", [AObjectState], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);","map":{"version":3,"names":["AModel","AObjectNodeEvents","AObjectState","ASerializable","AMaterialManager","AInteractionModeMap","BasicInteractionModes","AClock","v4","uuidv4","Mutex","SceneEvents","ASCENEMODEL_EVENT_HANDLES","ASceneModel","materials","_materials","initializedPromise","_initializedPromise","camera","cameraModel","eventTarget","_interactionDOMElement","clock","_clock","initShaders","confirmInitialized","initMutex","runExclusive","_isInitialized","_asyncInitScene","play","PreloadAssets","initScene","modelMap","_modelMap","isInitialized","addIsInitializedListener","callback","handle","synchronous","addStateKeyListener","addComponentUpdateListener","addEventListener","UpdateComponent","signalComponentUpdate","signalEvent","_addModel","model","hasModel","Error","uid","serializationLabel","NodeAdded","_removeModel","NodeRemoved","hasModelID","modelID","constructor","name","_interactions","_currentInteractionModeName","document","Default","_initSceneGraphSubscriptions","self","subscribe","NewDescendant","descendant","SCENE_NODE_ADDED","DescendantRemoved","SCENE_NODE_REMOVED","loadShader","loadShaderModel","loadLineShader","loadLineShaderModel","getDescendantList","addTimedAction","duration","actionOverCallback","tween","_subscriptions","subscriptionHandle","CreateTimedAction","unsubscribe","interactionMode","modes","addInteraction","interaction","activateInteractions","activate","setCurrentInteractionMode","deactivate","activeMode","setActiveMode","defineInteractionMode","mode","defineMode","clearInteractionMode","undefineMode","isInteractionModeDefined","modeIsDefined"],"sources":["/Users/home/Desktop/cs4620-final-project/src/anigraph/scene/ASceneModel.ts"],"sourcesContent":["import {AModel, AModelInterface} from \"../base/amvc/AModel\";\nimport {AObject, AObjectNodeEvents, AObjectState} from \"../base/aobject\";\nimport {ASerializable} from \"../base/aserial\";\nimport {ANodeModel} from \"./nodeModel\";\nimport {HasModelMap, MVMModelMap} from \"../base/amvc/AModelViewMap\";\nimport {ACameraModel} from \"./camera\";\nimport {Vec2, Vec3, Vector} from \"../math\";\nimport {BezierTween} from \"../geometry\";\nimport {AMaterialManager} from \"../rendering/material\";\nimport {CallbackType} from \"../basictypes\";\nimport {ACallbackSwitch} from \"../base\";\nimport {AInteraction, AInteractionEvent,\n    AInteractionMode,\n    AInteractionModeMap,\n    BasicInteractionModes} from \"../interaction\";\n\nimport {AClock} from \"../time\";\nimport {v4 as uuidv4} from \"uuid\";\nimport {HasInteractions} from \"../base/amvc/HasInteractions\";\n\nimport {Mutex} from 'async-mutex';\n\nexport enum SceneEvents{\n    SceneNodeModelAdded=\"SceneNodeModelAdded\", // this event should trigger the creation of a view\n    NodeAdded=\"NodeAdded\", // This does not directly trigger the creation of a view\n    NodeRemoved=\"NodeRemoved\",\n    NodeMoved=\"NodeMoved\",\n    UpdateComponent=\"UpdateComponent\"\n}\n\nenum ASCENEMODEL_EVENT_HANDLES{\n    SCENE_NODE_ADDED=\"SCENE_NODE_ADDED\",\n    SCENE_NODE_REMOVED=\"SCENE_NODE_REMOVED\"\n}\n\n@ASerializable(\"ASceneModel\")\nexport abstract class ASceneModel extends AModel implements HasModelMap, HasInteractions{\n    static SceneEvents=SceneEvents;\n    @AObjectState protected _isInitialized!:boolean;\n    cameraModel!:ACameraModel;\n    protected _materials!:AMaterialManager;\n    get materials(){\n        return this._materials;\n    }\n    protected _clock: AClock;\n    protected _interactionDOMElement:EventTarget;\n    protected _initializedPromise!:Promise<boolean>;\n    protected initMutex:Mutex;\n\n    get initializedPromise(){return this._initializedPromise;}\n\n    get camera(){\n        return this.cameraModel.camera;\n    }\n\n    abstract getCoordinatesForCursorEvent(event:AInteractionEvent):Vec2;\n\n    get eventTarget(){\n        return this._interactionDOMElement;\n    }\n\n    /**\n     * Interaction mode map. Has a .modes property that maps mode names to AInteractionModes.\n     * @type {AInteractionModeMap}\n     * @protected\n     */\n    protected _interactions!: AInteractionModeMap;\n    /**\n     * Right now, controllers are restricted to having one or zero active modes at a time. The name of the current mode, which can be active or inactive, is stored here.\n     * @type {string}\n     * @protected\n     */\n    protected _currentInteractionModeName: string;\n\n    get clock() {\n        return this._clock;\n    }\n\n    protected abstract initScene():Promise<void>;\n\n\n    // abstract initShaders():Promise<void>;\n    async initShaders(){\n        this._materials = new AMaterialManager();\n    }\n\n    abstract initCamera():void;\n\n    /**\n     * # Initialization:\n     * Scene models are initialized asynchronously, and initialization may be triggered lazily by the first controller\n     * that tries to access the model (it can also be triggered more proactively, depending on the application).\n     * The scene model has a state variable `isInitialized` that is set to false in the constructor, but flipped to true\n     * after initialization is performed.\n     *\n     * To trigger initialization, the function `confirmInitialized` must be called at least once.\n     *\n     *\n     */\n    async confirmInitialized(){\n        await this.initMutex.runExclusive(async () => {\n            if(!this._isInitialized){\n                this._isInitialized = await this._asyncInitScene();\n                this._isInitialized = true;\n                this._clock.play();\n            }\n        });\n    }\n\n    protected async _asyncInitScene():Promise<boolean>{\n        await this.initShaders();\n        await this.PreloadAssets()\n        await this.initScene();\n        return true;\n    }\n\n    async PreloadAssets(){\n        // this.materials.setMaterialModel()\n        // await this.materials.materialsLoadedPromise;\n    }\n\n\n    protected _modelMap:MVMModelMap={};\n    get modelMap(){\n        return this._modelMap;\n    }\n\n\n    get isInitialized(){\n        return this._isInitialized;\n    }\n\n    addIsInitializedListener(callback:(self:AObject)=>void, handle?:string, synchronous:boolean=true):ACallbackSwitch{\n        return this.addStateKeyListener('_isInitialized', callback, handle, synchronous);\n    }\n\n    addComponentUpdateListener(callback:(self:AObject)=>void, handle?:string):ACallbackSwitch{\n        return this.addEventListener(ASceneModel.SceneEvents.UpdateComponent, callback, handle);\n    }\n\n    signalComponentUpdate(){\n        this.signalEvent(ASceneModel.SceneEvents.UpdateComponent);\n    }\n\n\n    protected _addModel(model:AModelInterface){\n        if(this.hasModel(model)){\n            throw new Error(`Model ${model} with uid ${model.uid} already in ${this.serializationLabel}`)\n        }\n        this.modelMap[model.uid]=model;\n        this.signalEvent(SceneEvents.NodeAdded, model);\n    }\n    protected _removeModel(model:AModelInterface){\n        delete this._modelMap[model.uid];\n        this.signalEvent(SceneEvents.NodeRemoved, model);\n    }\n\n    hasModel(model:AModelInterface){\n        return (model.uid in this.modelMap);\n    }\n\n    hasModelID(modelID:string){\n        return (modelID in this.modelMap);\n    }\n\n    constructor(name?:string) {\n        super(name);\n        this.initMutex = new Mutex();\n        this._clock = new AClock();\n        this._interactionDOMElement = document;\n        this._interactions = new AInteractionModeMap(this);\n        this._currentInteractionModeName = BasicInteractionModes.Default;\n        this._isInitialized = false;\n        // this._materials = new AMaterialManager();\n\n\n\n        this._initSceneGraphSubscriptions();\n        // this.materials = new AMaterialManager();\n        // appstate assigns this when model is created\n        // this.appState = GetAppState();\n    }\n\n    protected _initSceneGraphSubscriptions(){\n        const self = this;\n        this.subscribe(this.addEventListener(AObjectNodeEvents.NewDescendant, (descendant:ANodeModel)=>{\n            self._addModel(descendant);\n        }), ASCENEMODEL_EVENT_HANDLES.SCENE_NODE_ADDED);\n\n        this.subscribe(this.addEventListener(AObjectNodeEvents.DescendantRemoved, (descendant:ANodeModel)=>{\n            self._removeModel(descendant);\n        }), ASCENEMODEL_EVENT_HANDLES.SCENE_NODE_REMOVED);\n    }\n\n    async loadShader(name:string){\n        return this.materials.loadShaderModel(name);\n    }\n    async loadLineShader(name:string){\n        return this.materials.loadLineShaderModel(name);\n    }\n\n    getDescendantList(){\n        return super.getDescendantList() as ANodeModel[];\n    }\n\n    addTimedAction(callback: (actionProgress: number) => any, duration: number, actionOverCallback?: CallbackType, tween?: BezierTween, handle?: string) {\n        if (handle && (handle in this._subscriptions)) {\n            return;\n        }\n        const self = this;\n        const subscriptionHandle = handle ?? uuidv4();\n        this.subscribe(this._clock.CreateTimedAction(callback, duration, () => {\n                self.unsubscribe(subscriptionHandle);\n                if (actionOverCallback) {\n                    actionOverCallback();\n                }\n            }, tween),\n            subscriptionHandle);\n    }\n\n\n    /**\n     * Getter for the current interaction mode.\n     * @returns {AInteractionMode}\n     */\n    get interactionMode() {\n        return this._interactions.modes[this._currentInteractionModeName];\n    }\n\n\n    /**\n     * Add an interaction to the current mode.\n     * @param interaction\n     */\n    addInteraction(interaction: AInteraction) {\n        this.interactionMode.addInteraction(interaction);\n        // interaction.owner = this;\n        return interaction;\n    }\n\n    activateInteractions() {\n        this.interactionMode.activate();\n    }\n\n    setCurrentInteractionMode(name?: string) {\n        this.interactionMode.deactivate();\n        let activeMode = name ? name : BasicInteractionModes.Default;\n        this._interactions.setActiveMode(activeMode);\n        this._currentInteractionModeName = activeMode;\n    }\n\n    defineInteractionMode(name: string, mode?: AInteractionMode) {\n        this._interactions.defineMode(name, mode);\n    }\n\n    clearInteractionMode(name: string) {\n        this._interactions.undefineMode(name)\n    }\n\n    isInteractionModeDefined(name: string):boolean {\n        return this._interactions.modeIsDefined(name);\n    }\n\n\n\n}\n\n\n\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}