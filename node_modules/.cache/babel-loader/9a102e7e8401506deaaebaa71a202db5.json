{"ast":null,"code":"// import objectHash from \"object-hash\";\n// const SerializableClassNameKey: string = \"ASerializableClassName\";\n\n// function GetSerializableHash(obj:any){\n//     return objectHash(obj);\n// }\n\nconst ASerializableClassesDict = {};\n// const ASerializableRefMap:{[name:string]:ASerializableClass}\n\nexport function GETSERIALIZABLES() {\n  return ASerializableClassesDict;\n}\n_c = GETSERIALIZABLES;\nexport function CHECKSERIALIZABLES() {\n  console.log(GETSERIALIZABLES());\n  let serializables = GETSERIALIZABLES();\n  console.log(serializables);\n}\n\n/**\n * Serializable classes must either be able to safely call new() with no parameters (for assignment to serialized version)\n * or implement toJSON():serialized_form and static fromJSON(data:serialized_form), the latter of which returns a new instance\n * of the class.\n * @param constructorFunction\n * @constructor\n */\n_c2 = CHECKSERIALIZABLES;\nexport function ASerializable(serializationName) {\n  return function (constructorFunction) {\n    // console.log(`-- decorator function invoked -- for ${constructorFunction.name}`);\n\n    // @ts-ignore\n    constructorFunction._serializationLabel = serializationName;\n    let classname = serializationName ? serializationName : constructorFunction.name;\n    let counter = 0;\n    let cfunc = constructorFunction;\n    while (classname === \"\" && counter < 10) {\n      // @ts-ignore\n      cfunc = cfunc.__proto__;\n      classname = cfunc.name;\n      counter = counter + 1;\n      if (counter === 10) {\n        throw new Error(`trying to make class serializable with >10 decorators??? ${constructorFunction}`);\n      }\n    }\n    let incrementCounter = 1;\n    while (classname in ASerializableClassesDict) {\n      classname = constructorFunction.name + incrementCounter.toString();\n      incrementCounter = incrementCounter + 1;\n    }\n    // @ts-ignore\n    constructorFunction.ASerializationClassID = classname;\n    ASerializableClassesDict[classname] = constructorFunction;\n  };\n}\n_c3 = ASerializable;\nexport function ASerializableToJSON(obj) {\n  return JSON.stringify(obj, function (key, value) {\n    if (this[key] && typeof this[key] === \"object\" && this[key].constructor.ASerializationClassID !== undefined) {\n      return {\n        _aserial_class_id: this[key].constructor.ASerializationClassID,\n        data: value\n      };\n    } else {\n      return value;\n    }\n  }, \" \");\n}\n_c4 = ASerializableToJSON;\nfunction ReviveASerializable(key, value) {\n  if (typeof value !== \"object\" || value === null) {\n    return value; // Return the value if not an object\n  }\n\n  if (value && value._aserial_class_id) {\n    var ASClass = ASerializableClassesDict[value._aserial_class_id];\n    if (typeof ASClass.fromJSON === \"function\") {\n      return ASClass.fromJSON(value.data);\n    } else {\n      return Object.assign(new ASClass(), value.data);\n    }\n  } else {\n    return value;\n  }\n}\n_c5 = ReviveASerializable;\nexport function ASerializableFromJSON(jsonText) {\n  let obj = JSON.parse(jsonText, (key, value) => {\n    return ReviveASerializable(key, value);\n  });\n  return obj;\n}\n\n//##################//--Recursive index copy circular--\\\\##################\n//<editor-fold desc=\"Recursive intdex copy\">\n// export function GetIndexedCopyRecursive(obj:anym, ref_map?:{[uid:string]:any}){\n//     let ohash_map = ref_map? ref_map:{};\n//     //##################//--recursive function--\\\\##################\n//     //<editor-fold desc=\"recursive function\">\n//     const deepIndexedCopy = (inObject:any) => {\n//         if (typeof inObject !== \"object\" || inObject === null) {\n//             return inObject; // Return the value if inObject is not an object\n//         }\n//\n//         let outObject:any;\n//         let value:any;\n//         let key:any;\n//         if(inObject.constructor.ASerializationClassID!==undefined){\n//             let ohash = (inObject._ASerializationID!==undefined && typeof inObject._ASerializationID === 'function')?inObject._ASerializationID():GetSerializableHash(inObject);\n//             if(ohash_map[ohash]===undefined){\n//                 var data:any;\n//                 if(typeof inObject.ASerialize === 'function'){\n//                     // If there is a derived serialize function, use it\n//                     data = inObject.ASerialize(ohash_map);\n//                 }else{\n//                     // otherwise, just return a dictionary of deepIndexCopy values for each key\n//                     data = {};\n//                     for(let key in inObject){\n//                         data[key]=deepIndexedCopy(inObject[key]);\n//                     }\n//                 }\n//                 ohash_map[ohash]={\n//                     _aserial_class_id: inObject.constructor.ASerializationClassID,\n//                     data: data\n//                 };\n//             }\n//             return {\n//                 _SERIALIZABLE_REF: ohash\n//             };\n//         }\n//\n//         // Create an array or object to hold the values\n//         outObject = Array.isArray(inObject) ? [] : {}\n//         for (key in inObject) {\n//             value = inObject[key]\n//             // Recursively (deep) copy for nested objects, including arrays\n//             outObject[key] = deepIndexedCopy(value);\n//         }\n//         return outObject\n//     }\n//     //</editor-fold>\n//     //##################\\\\--recursive function--//##################\n//\n//     return deepIndexedCopy(obj);\n//\n//     // return Object.assign(\n//     //     Object.create(\n//     //         // Set the prototype of the new object to the prototype of the instance.\n//     //         // Used to allow new object behave like class instance.\n//     //         Object.getPrototypeOf(obj),\n//     //     ),\n//     //     // Prevent shallow copies of nested structures like arrays, etc\n//     //     deepIndexedCopy(obj)\n//     // );\n// }\n//</editor-fold>\n//##################\\\\--Recursive index copy circular--//##################\n_c6 = ASerializableFromJSON;\nexport function GetIndexedCopy(obj) {\n  //##################//--recursive function--\\\\##################\n  //<editor-fold desc=\"recursive function\">\n  const deepIndexedCopy = inObject => {\n    if (typeof inObject !== \"object\" || inObject === null) {\n      return inObject; // Return the value if inObject is not an object\n    }\n\n    let outObject;\n    let value;\n    let key;\n    if (inObject.constructor.ASerializationClassID !== undefined) {\n      if (typeof inObject.ASerialize === \"function\") {\n        return {\n          _aserial_class_id: inObject.constructor.ASerializationClassID,\n          data: inObject.ASerialize()\n        };\n      } else {\n        return {\n          _aserial_class_id: inObject.constructor.ASerializationClassID,\n          data: inObject\n        };\n      }\n    }\n    // Create an array or object to hold the values\n    outObject = Array.isArray(inObject) ? [] : {};\n    for (key in inObject) {\n      value = inObject[key];\n      // Recursively (deep) copy for nested objects, including arrays\n      outObject[key] = deepIndexedCopy(value);\n    }\n    return outObject;\n  };\n  return deepIndexedCopy(obj);\n}\n_c7 = GetIndexedCopy;\nexport function GetASerializableClassByName(className) {\n  return ASerializableClassesDict[className];\n}\n_c8 = GetASerializableClassByName;\nvar _c, _c2, _c3, _c4, _c5, _c6, _c7, _c8;\n$RefreshReg$(_c, \"GETSERIALIZABLES\");\n$RefreshReg$(_c2, \"CHECKSERIALIZABLES\");\n$RefreshReg$(_c3, \"ASerializable\");\n$RefreshReg$(_c4, \"ASerializableToJSON\");\n$RefreshReg$(_c5, \"ReviveASerializable\");\n$RefreshReg$(_c6, \"ASerializableFromJSON\");\n$RefreshReg$(_c7, \"GetIndexedCopy\");\n$RefreshReg$(_c8, \"GetASerializableClassByName\");","map":{"version":3,"names":["ASerializableClassesDict","GETSERIALIZABLES","CHECKSERIALIZABLES","console","log","serializables","ASerializable","serializationName","constructorFunction","_serializationLabel","classname","name","counter","cfunc","__proto__","Error","incrementCounter","toString","ASerializationClassID","ASerializableToJSON","obj","JSON","stringify","key","value","constructor","undefined","_aserial_class_id","data","ReviveASerializable","ASClass","fromJSON","Object","assign","ASerializableFromJSON","jsonText","parse","GetIndexedCopy","deepIndexedCopy","inObject","outObject","ASerialize","Array","isArray","GetASerializableClassByName","className"],"sources":["/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/src/anigraph/base/aserial/ASerializable.ts"],"sourcesContent":["// import objectHash from \"object-hash\";\n// const SerializableClassNameKey: string = \"ASerializableClassName\";\n\n// function GetSerializableHash(obj:any){\n//     return objectHash(obj);\n// }\n\nconst ASerializableClassesDict: { [name: string]: any } = {};\nexport interface ASerializableClass {\n  // ASerialize():{[name:string]:any};\n  // ADeserialize(d:{[name:string]:any},recurse_func:(...args:any[])=>any):ASerializableClass;\n}\n// const ASerializableRefMap:{[name:string]:ASerializableClass}\n\nexport function GETSERIALIZABLES() {\n  return ASerializableClassesDict;\n}\n\nexport function CHECKSERIALIZABLES() {\n  console.log(GETSERIALIZABLES());\n  let serializables = GETSERIALIZABLES();\n  console.log(serializables);\n}\n\n/**\n * Serializable classes must either be able to safely call new() with no parameters (for assignment to serialized version)\n * or implement toJSON():serialized_form and static fromJSON(data:serialized_form), the latter of which returns a new instance\n * of the class.\n * @param constructorFunction\n * @constructor\n */\n\nexport function ASerializable(serializationName?: string) {\n  return function (constructorFunction: Function) {\n    // console.log(`-- decorator function invoked -- for ${constructorFunction.name}`);\n\n    // @ts-ignore\n    constructorFunction._serializationLabel = serializationName;\n\n    let classname = serializationName\n      ? serializationName\n      : constructorFunction.name;\n    let counter = 0;\n    let cfunc = constructorFunction;\n    while (classname === \"\" && counter < 10) {\n      // @ts-ignore\n      cfunc = cfunc.__proto__;\n      classname = cfunc.name;\n      counter = counter + 1;\n      if (counter === 10) {\n        throw new Error(\n          `trying to make class serializable with >10 decorators??? ${constructorFunction}`\n        );\n      }\n    }\n    let incrementCounter = 1;\n    while (classname in ASerializableClassesDict) {\n      classname = constructorFunction.name + incrementCounter.toString();\n      incrementCounter = incrementCounter + 1;\n    }\n    // @ts-ignore\n    constructorFunction.ASerializationClassID = classname;\n    ASerializableClassesDict[classname] = constructorFunction;\n  };\n}\n\nexport function ASerializableToJSON(obj: any) {\n  return JSON.stringify(\n    obj,\n    function (key, value) {\n      if (\n        this[key] &&\n        typeof this[key] === \"object\" &&\n        this[key].constructor.ASerializationClassID !== undefined\n      ) {\n        return {\n          _aserial_class_id: this[key].constructor.ASerializationClassID,\n          data: value,\n        };\n      } else {\n        return value;\n      }\n    },\n    \" \"\n  );\n}\n\nfunction ReviveASerializable(key: string, value: any) {\n  if (typeof value !== \"object\" || value === null) {\n    return value; // Return the value if not an object\n  }\n  if (value && value._aserial_class_id) {\n    var ASClass: any = ASerializableClassesDict[value._aserial_class_id];\n    if (typeof ASClass.fromJSON === \"function\") {\n      return ASClass.fromJSON(value.data);\n    } else {\n      return Object.assign(new ASClass(), value.data);\n    }\n  } else {\n    return value;\n  }\n}\n\nexport function ASerializableFromJSON(jsonText: string) {\n  let obj = JSON.parse(jsonText, (key, value) => {\n    return ReviveASerializable(key, value);\n  });\n  return obj;\n}\n\n//##################//--Recursive index copy circular--\\\\##################\n//<editor-fold desc=\"Recursive intdex copy\">\n// export function GetIndexedCopyRecursive(obj:anym, ref_map?:{[uid:string]:any}){\n//     let ohash_map = ref_map? ref_map:{};\n//     //##################//--recursive function--\\\\##################\n//     //<editor-fold desc=\"recursive function\">\n//     const deepIndexedCopy = (inObject:any) => {\n//         if (typeof inObject !== \"object\" || inObject === null) {\n//             return inObject; // Return the value if inObject is not an object\n//         }\n//\n//         let outObject:any;\n//         let value:any;\n//         let key:any;\n//         if(inObject.constructor.ASerializationClassID!==undefined){\n//             let ohash = (inObject._ASerializationID!==undefined && typeof inObject._ASerializationID === 'function')?inObject._ASerializationID():GetSerializableHash(inObject);\n//             if(ohash_map[ohash]===undefined){\n//                 var data:any;\n//                 if(typeof inObject.ASerialize === 'function'){\n//                     // If there is a derived serialize function, use it\n//                     data = inObject.ASerialize(ohash_map);\n//                 }else{\n//                     // otherwise, just return a dictionary of deepIndexCopy values for each key\n//                     data = {};\n//                     for(let key in inObject){\n//                         data[key]=deepIndexedCopy(inObject[key]);\n//                     }\n//                 }\n//                 ohash_map[ohash]={\n//                     _aserial_class_id: inObject.constructor.ASerializationClassID,\n//                     data: data\n//                 };\n//             }\n//             return {\n//                 _SERIALIZABLE_REF: ohash\n//             };\n//         }\n//\n//         // Create an array or object to hold the values\n//         outObject = Array.isArray(inObject) ? [] : {}\n//         for (key in inObject) {\n//             value = inObject[key]\n//             // Recursively (deep) copy for nested objects, including arrays\n//             outObject[key] = deepIndexedCopy(value);\n//         }\n//         return outObject\n//     }\n//     //</editor-fold>\n//     //##################\\\\--recursive function--//##################\n//\n//     return deepIndexedCopy(obj);\n//\n//     // return Object.assign(\n//     //     Object.create(\n//     //         // Set the prototype of the new object to the prototype of the instance.\n//     //         // Used to allow new object behave like class instance.\n//     //         Object.getPrototypeOf(obj),\n//     //     ),\n//     //     // Prevent shallow copies of nested structures like arrays, etc\n//     //     deepIndexedCopy(obj)\n//     // );\n// }\n//</editor-fold>\n//##################\\\\--Recursive index copy circular--//##################\n\nexport function GetIndexedCopy(obj: any) {\n  //##################//--recursive function--\\\\##################\n  //<editor-fold desc=\"recursive function\">\n  const deepIndexedCopy = (inObject: any) => {\n    if (typeof inObject !== \"object\" || inObject === null) {\n      return inObject; // Return the value if inObject is not an object\n    }\n\n    let outObject: any;\n    let value: any;\n    let key: any;\n    if (inObject.constructor.ASerializationClassID !== undefined) {\n      if (typeof inObject.ASerialize === \"function\") {\n        return {\n          _aserial_class_id: inObject.constructor.ASerializationClassID,\n          data: inObject.ASerialize(),\n        };\n      } else {\n        return {\n          _aserial_class_id: inObject.constructor.ASerializationClassID,\n          data: inObject,\n        };\n      }\n    }\n    // Create an array or object to hold the values\n    outObject = Array.isArray(inObject) ? [] : {};\n    for (key in inObject) {\n      value = inObject[key];\n      // Recursively (deep) copy for nested objects, including arrays\n      outObject[key] = deepIndexedCopy(value);\n    }\n    return outObject;\n  };\n  return deepIndexedCopy(obj);\n}\n\nexport function GetASerializableClassByName(className: string) {\n  return ASerializableClassesDict[className];\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}