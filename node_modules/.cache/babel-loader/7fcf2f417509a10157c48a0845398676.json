{"ast":null,"code":"import _initializerDefineProperty from \"/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js\";\nimport _applyDecoratedDescriptor from \"/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js\";\nimport _initializerWarningHelper from \"/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js\";\nvar _class, _descriptor, _descriptor2, _descriptor3, _class2;\nimport { AObjectState } from \"../../base\";\nimport { AModel } from \"../../base\";\nimport { AGeometrySet } from \"../../geometry\";\nimport { AMaterial } from \"../../rendering\";\nconst MATERIAL_UPDATE_SUBSCRIPTION_HANDLE = 'MATERIAL_UPDATE_SUBSCRIPTION_NodeModel';\nvar ANodeModelEvents;\n(function (ANodeModelEvents) {\n  ANodeModelEvents[\"GEOMETRY_UPDATE\"] = \"GEOMETRY_UPDATE\";\n  ANodeModelEvents[\"TRANSFORM_UPDATE\"] = \"TRANSFORM_UPDATE\";\n})(ANodeModelEvents || (ANodeModelEvents = {}));\nexport let ANodeModel = (_class = (_class2 = class ANodeModel extends AModel {\n  /**\n   * Transform of the node model. This is generally its model matrix in the scene graph.\n   */\n\n  /** Get set visible */\n  set visible(value) {\n    this._visible = value;\n  }\n  get visible() {\n    return this._visible;\n  }\n  get geometry() {\n    return this._geometry;\n  }\n  get material() {\n    return this._material;\n  }\n\n  //###############################################//--Tags--\\\\###############################################\n  //<editor-fold desc=\"Tags\">\n\n  getNodeTags() {\n    return this._nodeTags;\n  }\n  addTag(tagName) {\n    this._nodeTags[tagName] = true;\n  }\n  setTagValue(tagName, value) {\n    this._nodeTags[tagName] = value;\n  }\n  hasTag(tagName) {\n    return tagName in this._nodeTags;\n  }\n  getTagValue(tagName) {\n    return this._nodeTags[tagName];\n  }\n  removeTag(tagName) {\n    delete this._nodeTags[tagName];\n  }\n  //</editor-fold>\n  //###############################################\\\\--Tags--//###############################################\n\n  constructor() {\n    super();\n    _initializerDefineProperty(this, \"_transform\", _descriptor, this);\n    _initializerDefineProperty(this, \"_visible\", _descriptor2, this);\n    this._geometry = void 0;\n    this._material = void 0;\n    _initializerDefineProperty(this, \"_nodeTags\", _descriptor3, this);\n    this._nodeTags = [];\n    this._geometry = new AGeometrySet();\n    this.signalGeometryUpdate = this.signalGeometryUpdate.bind(this);\n    this.signalTransformUpdate = this.signalTransformUpdate.bind(this);\n    const self = this;\n    this.subscribe(this.addStateKeyListener(\"_transform\", () => {\n      self.signalTransformUpdate();\n    }), \"NODE_TRANSFORM_UPDATE\");\n  }\n\n  //##################//--Listeners--\\\\##################\n  //<editor-fold desc=\"Listeners\">\n  /*\n          this.subscribe(this.addStateKeyListener(\"_transform\", ()=>{\n              self.signalTransformUpdate();\n          }), \"NODE_TRANSFORM_UPDATE\");\n      addTransformListener(callback:(self:AObject)=>void, handle?:string, synchronous:boolean=true):ACallbackSwitch{\n          return this.addStateKeyListener(\"_transform\", callback, handle, synchronous);\n  \n      }\n      signalTransformUpdate(){\n          this.signalEvent(ANodeModel.NodeModelEvents.TRANSFORM_UPDATE, this);\n      }\n   */\n\n  /**\n   * Implemented as event listener that triggers whenever state key changes. This is so that the transform can be delegated to some other object, like in the case of a ACameraModel delegating it to a camera\n   * @param callback\n   * @param handle\n   * @param synchronous\n   * @returns {AEventCallbackSwitch}\n   */\n  addTransformListener(callback, handle) {\n    let synchronous = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return this.addEventListener(ANodeModel.NodeModelEvents.TRANSFORM_UPDATE, callback, handle);\n  }\n  signalTransformUpdate() {\n    this.signalEvent(ANodeModel.NodeModelEvents.TRANSFORM_UPDATE, this);\n  }\n  addGeometryListener(callback, handle) {\n    let synchronous = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return this.addEventListener(ANodeModel.NodeModelEvents.GEOMETRY_UPDATE, callback, handle);\n  }\n  signalGeometryUpdate() {\n    this.signalEvent(ANodeModel.NodeModelEvents.GEOMETRY_UPDATE, this);\n  }\n  addVisibilityListener(callback, handle) {\n    let synchronous = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return this.addStateKeyListener(\"_visible\", callback, handle, synchronous);\n  }\n\n  // signalMaterialUpdate(){\n  //     this.signalEvent(ANodeModel.NodeModelEvents.MATERIAL_UPDATE, this);\n  // }\n  //</editor-fold>\n  //##################\\\\--Listeners--//##################\n\n  //###############################################//--Material Updates--\\\\###############################################\n  //<editor-fold desc=\"Material Updates\">\n  /**\n   * These are designed so that you can have the same material used for multiple objects. For this reason, we listen\n   * to the material directly for updates, which will trigger updates even if we change the material elsewhere in code.\n   */\n  addMaterialUpdateListener(callback, handle) {\n    return this.addEventListener(AMaterial.Events.UPDATE, callback, handle);\n  }\n  addMaterialChangeListener(callback, handle) {\n    return this.addEventListener(AMaterial.Events.CHANGE, callback, handle);\n  }\n  setMaterialUpdateSubscriptions() {\n    const self = this;\n    this.subscribe(this.material.addEventListener(AMaterial.Events.UPDATE, function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      self.onMaterialUpdate(AMaterial.Events.UPDATE, ...args);\n    }), MATERIAL_UPDATE_SUBSCRIPTION_HANDLE);\n  }\n  onMaterialUpdate() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    this.signalEvent(AMaterial.Events.UPDATE, ...args);\n  }\n  setMaterial(material) {\n    if (this.material === material) {\n      return;\n    } else {\n      let amaterial;\n      if (material instanceof AMaterial) {\n        amaterial = material;\n      } else {\n        throw new Error(\"Material from string not implemented yet. Should look up in MaterialManager.\");\n      }\n      if (this.material) {\n        this._disposeMaterial();\n      }\n      this._material = amaterial;\n      this.setMaterialUpdateSubscriptions();\n    }\n    this.signalEvent(AMaterial.Events.CHANGE);\n  }\n  _disposeMaterial() {\n    this.unsubscribe(MATERIAL_UPDATE_SUBSCRIPTION_HANDLE);\n    this.material.release();\n  }\n  //</editor-fold>\n  //###############################################\\\\--Material Updates--//###############################################\n\n  timeUpdate(t) {}\n}, _class2.NodeModelEvents = ANodeModelEvents, _class2), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"_transform\", [AObjectState], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"_visible\", [AObjectState], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"_nodeTags\", [AObjectState], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class);","map":{"version":3,"names":["AObjectState","AModel","AGeometrySet","AMaterial","MATERIAL_UPDATE_SUBSCRIPTION_HANDLE","ANodeModelEvents","ANodeModel","visible","value","_visible","geometry","_geometry","material","_material","getNodeTags","_nodeTags","addTag","tagName","setTagValue","hasTag","getTagValue","removeTag","constructor","signalGeometryUpdate","bind","signalTransformUpdate","self","subscribe","addStateKeyListener","addTransformListener","callback","handle","synchronous","addEventListener","NodeModelEvents","TRANSFORM_UPDATE","signalEvent","addGeometryListener","GEOMETRY_UPDATE","addVisibilityListener","addMaterialUpdateListener","Events","UPDATE","addMaterialChangeListener","CHANGE","setMaterialUpdateSubscriptions","args","onMaterialUpdate","setMaterial","amaterial","Error","_disposeMaterial","unsubscribe","release","timeUpdate","t"],"sources":["/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/src/anigraph/scene/nodeModel/ANodeModel.ts"],"sourcesContent":["import {AObjectState, AObject, ACallbackSwitch, HasTags} from \"../../base\";\nimport {AModel} from \"../../base\";\nimport {AGeometrySet,\n    VertexArray\n} from \"../../geometry\";\nimport type {TransformationInterface} from \"../../math\";\nimport {AMaterial, AShaderMaterial} from \"../../rendering\";\n\n\nconst MATERIAL_UPDATE_SUBSCRIPTION_HANDLE = 'MATERIAL_UPDATE_SUBSCRIPTION_NodeModel';\nenum ANodeModelEvents{\n    GEOMETRY_UPDATE = \"GEOMETRY_UPDATE\",\n    TRANSFORM_UPDATE = \"TRANSFORM_UPDATE\"\n}\n\nexport abstract class ANodeModel extends AModel implements HasTags{\n    static NodeModelEvents = ANodeModelEvents;\n    /**\n     * Transform of the node model. This is generally its model matrix in the scene graph.\n     */\n    @AObjectState protected _transform!:TransformationInterface;\n    @AObjectState _visible!:boolean;\n    /** Get set visible */\n    set visible(value:boolean){this._visible = value;}\n    get visible(){return this._visible;}\n    abstract get transform():TransformationInterface;\n    abstract setTransform(transform:TransformationInterface):void;\n\n\n    protected _geometry!:AGeometrySet;\n    get geometry(){return this._geometry;}\n    abstract get verts():VertexArray<any>;\n    abstract setVerts(verts:VertexArray<any>):void;\n    protected _material!:AMaterial;\n    get material():AShaderMaterial{return this._material as AShaderMaterial;}\n\n    //###############################################//--Tags--\\\\###############################################\n    //<editor-fold desc=\"Tags\">\n    @AObjectState _nodeTags!:{[tagName:string]:any};\n    protected getNodeTags(){return this._nodeTags;}\n    addTag(tagName:string){this._nodeTags[tagName]=true;}\n    setTagValue(tagName:string, value:any){this._nodeTags[tagName]=value;}\n    hasTag(tagName:string){return (tagName in this._nodeTags);}\n    getTagValue(tagName:string){return this._nodeTags[tagName];}\n    removeTag(tagName:string){delete this._nodeTags[tagName];}\n    //</editor-fold>\n    //###############################################\\\\--Tags--//###############################################\n\n\n    constructor(...args:any[]) {\n        super();\n        this._nodeTags = [];\n        this._geometry = new AGeometrySet();\n        this.signalGeometryUpdate = this.signalGeometryUpdate.bind(this);\n        this.signalTransformUpdate = this.signalTransformUpdate.bind(this);\n        const self = this;\n        this.subscribe(this.addStateKeyListener(\"_transform\", ()=>{\n            self.signalTransformUpdate();\n        }), \"NODE_TRANSFORM_UPDATE\");\n    }\n\n\n    //##################//--Listeners--\\\\##################\n    //<editor-fold desc=\"Listeners\">\n/*\n        this.subscribe(this.addStateKeyListener(\"_transform\", ()=>{\n            self.signalTransformUpdate();\n        }), \"NODE_TRANSFORM_UPDATE\");\n    addTransformListener(callback:(self:AObject)=>void, handle?:string, synchronous:boolean=true):ACallbackSwitch{\n        return this.addStateKeyListener(\"_transform\", callback, handle, synchronous);\n\n    }\n    signalTransformUpdate(){\n        this.signalEvent(ANodeModel.NodeModelEvents.TRANSFORM_UPDATE, this);\n    }\n */\n\n    /**\n     * Implemented as event listener that triggers whenever state key changes. This is so that the transform can be delegated to some other object, like in the case of a ACameraModel delegating it to a camera\n     * @param callback\n     * @param handle\n     * @param synchronous\n     * @returns {AEventCallbackSwitch}\n     */\n    addTransformListener(callback:(self:AObject)=>void, handle?:string, synchronous:boolean=true):ACallbackSwitch{\n        return this.addEventListener(ANodeModel.NodeModelEvents.TRANSFORM_UPDATE, callback, handle);\n    }\n    signalTransformUpdate(){\n        this.signalEvent(ANodeModel.NodeModelEvents.TRANSFORM_UPDATE, this);\n    }\n    addGeometryListener(callback:(self:AObject)=>void, handle?:string, synchronous:boolean=true){\n        return this.addEventListener(ANodeModel.NodeModelEvents.GEOMETRY_UPDATE, callback, handle);\n    }\n    signalGeometryUpdate(){\n        this.signalEvent(ANodeModel.NodeModelEvents.GEOMETRY_UPDATE, this);\n    }\n\n\n    addVisibilityListener(callback:(self:AObject)=>void, handle?:string, synchronous:boolean=true){\n        return this.addStateKeyListener(\"_visible\", callback, handle, synchronous);\n    }\n\n    // signalMaterialUpdate(){\n    //     this.signalEvent(ANodeModel.NodeModelEvents.MATERIAL_UPDATE, this);\n    // }\n    //</editor-fold>\n    //##################\\\\--Listeners--//##################\n\n    //###############################################//--Material Updates--\\\\###############################################\n    //<editor-fold desc=\"Material Updates\">\n    /**\n     * These are designed so that you can have the same material used for multiple objects. For this reason, we listen\n     * to the material directly for updates, which will trigger updates even if we change the material elsewhere in code.\n     */\n    addMaterialUpdateListener(callback:(...args:any[])=>void, handle?:string){\n        return this.addEventListener(AMaterial.Events.UPDATE, callback, handle);\n    }\n    addMaterialChangeListener(callback:(...args:any[])=>void, handle?:string){\n        return this.addEventListener(AMaterial.Events.CHANGE, callback, handle);\n    }\n\n    setMaterialUpdateSubscriptions(){\n        const self = this;\n        this.subscribe(this.material.addEventListener(AMaterial.Events.UPDATE, (...args:any[])=>{\n            self.onMaterialUpdate(AMaterial.Events.UPDATE, ...args)\n        }), MATERIAL_UPDATE_SUBSCRIPTION_HANDLE);\n    }\n    onMaterialUpdate(...args:any[]){\n        this.signalEvent(AMaterial.Events.UPDATE, ...args);\n    }\n\n    setMaterial(material:AMaterial|string){\n        if(this.material === material){\n            return;\n        }else{\n            let amaterial:AMaterial;\n            if(material instanceof AMaterial){\n                amaterial=material;\n            }else{\n                throw new Error(\"Material from string not implemented yet. Should look up in MaterialManager.\")\n            }\n\n            if(this.material){\n                this._disposeMaterial()\n            }\n            this._material = amaterial;\n            this.setMaterialUpdateSubscriptions();\n        }\n        this.signalEvent(AMaterial.Events.CHANGE)\n    }\n\n    _disposeMaterial(){\n        this.unsubscribe(MATERIAL_UPDATE_SUBSCRIPTION_HANDLE);\n        this.material.release();\n    }\n    //</editor-fold>\n    //###############################################\\\\--Material Updates--//###############################################\n\n    timeUpdate(t:number, ...args:any[]){\n\n    }\n\n\n\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}