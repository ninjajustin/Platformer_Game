{"ast":null,"code":"/**\n * @file Main scene model\n * @description Scene model for your application\n */\n\nimport { ACameraModel, Color, GetAppState, NodeTransform3D, V3, Vec2, Vec3 } from \"../../../anigraph\";\nimport { BaseSceneModel } from \"../../BaseClasses\";\nimport { ATexture } from \"src/anigraph/rendering/ATexture\";\nimport { APointLightModel } from \"../../../anigraph/scene/lights\";\nimport { AppConfigs } from \"../../AppConfigs\";\nimport { PlayerModel } from \"../Nodes/PlayerNode\";\nimport { GameTerrainModel } from \"../Nodes/GameTerrain/GameTerrainModel\";\nimport { EMPTY_LEVEL } from \"../../Backend/DefaultLevels\";\nlet appState = GetAppState();\nexport class MainSceneModel extends BaseSceneModel {\n  constructor() {\n    super(...arguments);\n    this.playerTexture = void 0;\n    this.bots = [];\n    this.gameTerrains = {};\n    this.lastTerrains = [];\n    this.currentLevel = EMPTY_LEVEL;\n    this.passedCheckpoints = 0;\n    this.lastT = void 0;\n    this._player = void 0;\n  }\n  get player() {\n    return this._player;\n  }\n  set player(v) {\n    this._player = v;\n  }\n  async PreloadAssets() {\n    await super.PreloadAssets();\n    await GameTerrainModel.LoadShader();\n    await PlayerModel.LoadShader();\n    // this.materials.setMaterialModel(\"textured\", await ABasicShaderModel.CreateModel(\"basic\"));\n  }\n\n  initCamera() {\n    this.cameraModel = ACameraModel.CreatePerspectiveFOV(90, 1, 0.01, 100);\n    this.cameraModel.setPose(NodeTransform3D.LookAt(V3(0.0, 0, 5), V3(0, 0, 0), V3(0, 1, 0)));\n  }\n\n  /**\n   * The view light is a light that is attached to the camera.\n   */\n  initViewLight() {\n    if (this.viewLight) return;\n\n    /**\n     * Create a point light\n     * You can have up to 16 point lights in the scene at once by default\n     */\n    this.viewLight = new APointLightModel(this.camera.pose, Color.FromString(\"#ffffff\"), 0.5, AppConfigs.ViewLightRange, 1);\n\n    /**\n     * Add it as a child of the camera model so that it will move with the camera\n     */\n    this.cameraModel.addChild(this.viewLight);\n  }\n  async initGameTerrain() {\n    if (this.lastTerrains == this.gameTerrains[this.currentLevel.name]) return;\n    for (let t of this.lastTerrains) {\n      t.position.y -= 500;\n    }\n    if (this.gameTerrains[this.currentLevel.name]) {\n      this.lastTerrains = this.gameTerrains[this.currentLevel.name];\n      for (let t of this.lastTerrains) {\n        t.position.y += 500;\n      }\n      debugger;\n    } else {\n      const t = [];\n      for (let [x1, y1, w, h] of this.currentLevel.terrains) {\n        let terrain = await GameTerrainModel.Create(w, h);\n        terrain.position.x = x1 + w / 2;\n        terrain.position.y = y1 + h / 2;\n        t.push(terrain);\n        this.addChild(terrain);\n      }\n      this.gameTerrains[this.currentLevel.name] = t;\n      this.lastTerrains = t;\n    }\n  }\n  async initGameHero() {\n    if (!this.player) {\n      this.playerTexture = await ATexture.LoadAsync(\"./images/tanktexburngreen.jpeg\");\n      this.player = await PlayerModel.Create(this.playerTexture);\n      this.addChild(this.player);\n    }\n    this.player.position = new Vec3(...this.currentLevel.player, 0);\n  }\n  async initScene() {\n    await this.initGameTerrain();\n    await this.initGameHero();\n    this.passedCheckpoints = 0;\n\n    /**\n     * Now let's initialize the view light\n     */\n    this.initViewLight();\n  }\n  timeUpdate(t) {\n    let paused = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    /**\n     * We can call timeUpdate on all of the model nodes in the scene here, which will trigger any updates that they\n     * individually define.\n     */\n    for (let c of this.getDescendantList()) {\n      c.timeUpdate(t);\n    }\n    if (!paused) {\n      this.player.update(t - this.lastT, this.gameTerrains[this.currentLevel.name] || []);\n      if (this.player.position.y < -10 || t <= 0.5) {\n        this.player.position = new Vec3(...(this.passedCheckpoints === 0 ? this.currentLevel.player : this.currentLevel.checkpoints[this.passedCheckpoints - 1][1]), 0);\n        this.player.velocity = new Vec3();\n        const playerPos = this.player.position;\n        const cameraPos = playerPos.clone();\n        cameraPos.z = 10;\n        this.cameraModel.setPose(NodeTransform3D.LookAt(cameraPos, playerPos, new Vec3(0, 1, 0)));\n      }\n      for (let i = this.passedCheckpoints, j = this.currentLevel.checkpoints.length; i < j; i++) {\n        if (Math.abs(this.player.velocity.y) < 0.01 && this.player.position.x >= this.currentLevel.checkpoints[i][0]) {\n          this.passedCheckpoints = Math.max(i + 1, this.passedCheckpoints);\n        }\n      }\n      if (Math.abs(this.cameraModel.pose.position.x - this.player.position.x) >= 0.01 || Math.abs(this.cameraModel.pose.position.y - this.player.position.y) >= 0.01) {\n        const cameraPos = this.cameraModel.pose.position.clone();\n        const playerPos = this.player.position.clone();\n        const playerVel = this.player.velocity.clone();\n        // higher gravity will look like player falling down harder\n        const g = AppConfigs.Gravity > 10 ? (AppConfigs.Gravity - 10) / 10 : 0;\n        playerVel.y = playerVel.y < g * playerVel.y ? 0 : playerVel.y;\n        // rate of camera movement, with 1 being camera on player at all times\n        const rate = this.cameraModel.pose.position.y < this.player.position.y ? 0.04 : 0.05;\n        // 1.5 is how much screen moves with player\n        const velocityCamera = cameraPos.clone().plus(playerVel.clone().times(1.5));\n        const new_camera_pos = velocityCamera.clone().plus(playerPos.clone().minus(velocityCamera).times(rate));\n        new_camera_pos.z = 10;\n        const new_target_pos = new_camera_pos.clone();\n        new_target_pos.z = 0;\n        this.cameraModel.setPose(NodeTransform3D.LookAt(new_camera_pos, new_target_pos, new Vec3(0, 1, 0)));\n      }\n      this.cameraModel.signalCameraProjectionUpdate();\n    }\n    this.lastT = t;\n\n    // /**\n    //  * For interactions between models, we can trigger logic here. For example, if you want characters to walk on\n    //  * uneven terrain, you can make that happen by completing the functions used here:\n    //  */\n    // const self = this;\n    // function adjustHeight(character:Particle3D){\n    //     let height = self.terrain.getTerrainHeightAtPoint(character.position.xy);\n    //     if(character.position.z<height){character.position.z = height;}\n    // }\n    //\n    // /**\n    //  * Here we would apply our adjust height function to the player\n    //  */\n    // adjustHeight(this.player);\n    //\n    // /**\n    //  * Now lets update bots\n    //  */\n    // let orbitradius = 0.25;\n    // for(let ei=0;ei<this.bots.length;ei++){\n    //     let e = this.bots[ei];\n    //\n    //     /**\n    //      * Characters have velocity and mass properties in case you want to implement particle physics\n    //      * But for now we will just have them orbit each other.\n    //      */\n    //     e.position = new Vec3(Math.cos(t*(ei+1)), Math.sin(t*(ei+1)),0).times(orbitradius);\n    //\n    //     /**\n    //      * adjust their height\n    //      */\n    //     adjustHeight(e);\n    // }\n  }\n\n  async updateLevel(level) {\n    this.currentLevel = level;\n    await this.initScene();\n  }\n  getCoordinatesForCursorEvent(event) {\n    var _event$ndcCursor;\n    return (_event$ndcCursor = event.ndcCursor) !== null && _event$ndcCursor !== void 0 ? _event$ndcCursor : new Vec2();\n  }\n}","map":{"version":3,"names":["ACameraModel","Color","GetAppState","NodeTransform3D","V3","Vec2","Vec3","BaseSceneModel","ATexture","APointLightModel","AppConfigs","PlayerModel","GameTerrainModel","EMPTY_LEVEL","appState","MainSceneModel","playerTexture","bots","gameTerrains","lastTerrains","currentLevel","passedCheckpoints","lastT","_player","player","v","PreloadAssets","LoadShader","initCamera","cameraModel","CreatePerspectiveFOV","setPose","LookAt","initViewLight","viewLight","camera","pose","FromString","ViewLightRange","addChild","initGameTerrain","name","t","position","y","x1","y1","w","h","terrains","terrain","Create","x","push","initGameHero","LoadAsync","initScene","timeUpdate","paused","c","getDescendantList","update","checkpoints","velocity","playerPos","cameraPos","clone","z","i","j","length","Math","abs","max","playerVel","g","Gravity","rate","velocityCamera","plus","times","new_camera_pos","minus","new_target_pos","signalCameraProjectionUpdate","updateLevel","level","getCoordinatesForCursorEvent","event","ndcCursor"],"sources":["/Users/home/Desktop/cs4620-final-project/src/app/main/Scene/MainSceneModel.ts"],"sourcesContent":["/**\n * @file Main scene model\n * @description Scene model for your application\n */\n\nimport {ACameraModel, AInteractionEvent, Color, GetAppState, NodeTransform3D, V3, Vec2, Vec3} from \"../../../anigraph\";\nimport {BaseSceneModel} from \"../../BaseClasses\";\nimport {ATexture} from \"src/anigraph/rendering/ATexture\";\nimport {APointLightModel} from \"../../../anigraph/scene/lights\";\nimport {AppConfigs} from \"../../AppConfigs\";\nimport {PlayerModel} from \"../Nodes/PlayerNode\";\nimport {BotModel} from \"../Nodes/CharacterNodes/BotModel\";\nimport {GameTerrainModel} from \"../Nodes/GameTerrain/GameTerrainModel\";\nimport {LevelDefinition} from \"../../Backend/Level\";\nimport {EMPTY_LEVEL} from \"../../Backend/DefaultLevels\";\n\nlet appState = GetAppState();\n\nexport class MainSceneModel extends BaseSceneModel {\n  playerTexture!: ATexture;\n  /**\n   * An array of bots. Your\n   */\n  bots: BotModel[] = [];\n  gameTerrains: { [name: string]: GameTerrainModel[] } = {};\n  lastTerrains: GameTerrainModel[] = [];\n  currentLevel: LevelDefinition = EMPTY_LEVEL;\n  passedCheckpoints: number = 0;\n  private lastT: number;\n\n  /**\n   * Our custom player model, and a texture to use for our player\n   */\n  _player!: PlayerModel;\n\n  get player(): PlayerModel {\n    return this._player as PlayerModel;\n  }\n\n  set player(v: PlayerModel) {\n    this._player = v;\n  }\n\n  async PreloadAssets() {\n    await super.PreloadAssets();\n    await GameTerrainModel.LoadShader();\n    await PlayerModel.LoadShader();\n    // this.materials.setMaterialModel(\"textured\", await ABasicShaderModel.CreateModel(\"basic\"));\n\n  }\n\n  initCamera() {\n    this.cameraModel = ACameraModel.CreatePerspectiveFOV(90, 1, 0.01, 100);\n    this.cameraModel.setPose(\n      NodeTransform3D.LookAt(\n        V3(0.0, 0, 5), V3(0, 0, 0),\n        V3(0, 1, 0)\n      )\n    )\n  }\n\n  /**\n   * The view light is a light that is attached to the camera.\n   */\n  initViewLight() {\n\n    if (this.viewLight) return;\n\n    /**\n     * Create a point light\n     * You can have up to 16 point lights in the scene at once by default\n     */\n    this.viewLight = new APointLightModel(\n      this.camera.pose,\n      Color.FromString(\"#ffffff\"),\n      0.5,\n      AppConfigs.ViewLightRange,\n      1\n    );\n\n    /**\n     * Add it as a child of the camera model so that it will move with the camera\n     */\n    this.cameraModel.addChild(this.viewLight);\n  }\n\n  async initGameTerrain() {\n    if (this.lastTerrains == this.gameTerrains[this.currentLevel.name])\n      return;\n    for (let t of this.lastTerrains) {\n      t.position.y -= 500;\n    }\n    if (this.gameTerrains[this.currentLevel.name]) {\n      this.lastTerrains = this.gameTerrains[this.currentLevel.name];\n      for (let t of this.lastTerrains) {\n        t.position.y += 500;\n      }\n      debugger;\n    } else {\n      const t = [];\n      for (let [x1, y1, w, h] of this.currentLevel.terrains) {\n        let terrain = await GameTerrainModel.Create(w, h);\n        terrain.position.x = x1 + w / 2;\n        terrain.position.y = y1 + h / 2;\n        t.push(terrain);\n        this.addChild(terrain);\n      }\n      this.gameTerrains[this.currentLevel.name] = t;\n      this.lastTerrains = t;\n    }\n  }\n\n  async initGameHero() {\n    if (!this.player) {\n      this.playerTexture = await ATexture.LoadAsync(\"./images/tanktexburngreen.jpeg\")\n      this.player = await PlayerModel.Create(this.playerTexture);\n      this.addChild(this.player);\n    }\n    this.player.position = new Vec3(...this.currentLevel.player, 0);\n  }\n\n  async initScene() {\n    await this.initGameTerrain();\n    await this.initGameHero();\n    this.passedCheckpoints = 0;\n\n    /**\n     * Now let's initialize the view light\n     */\n    this.initViewLight();\n  }\n\n  timeUpdate(t: number, paused: boolean = false, ...args: any[]) {\n\n    /**\n     * We can call timeUpdate on all of the model nodes in the scene here, which will trigger any updates that they\n     * individually define.\n     */\n    for (let c of this.getDescendantList()) {\n      c.timeUpdate(t);\n    }\n\n    if (!paused) {\n      this.player.update(t - this.lastT, this.gameTerrains[this.currentLevel.name] || []);\n\n      if (this.player.position.y < -10 || t <= 0.5) {\n        this.player.position = new Vec3(...(\n          this.passedCheckpoints === 0 ? this.currentLevel.player : this.currentLevel.checkpoints[this.passedCheckpoints - 1][1]\n        ), 0);\n        this.player.velocity = new Vec3();\n        const playerPos = this.player.position;\n        const cameraPos = playerPos.clone();\n        cameraPos.z = 10;\n        this.cameraModel.setPose(\n          NodeTransform3D.LookAt(\n            cameraPos, playerPos,\n            new Vec3(0, 1, 0)\n          )\n        );\n      }\n\n      for (let i = this.passedCheckpoints, j = this.currentLevel.checkpoints.length; i < j; i++) {\n        if (Math.abs(this.player.velocity.y) < 0.01 && this.player.position.x >= this.currentLevel.checkpoints[i][0]) {\n          this.passedCheckpoints = Math.max(i + 1, this.passedCheckpoints);\n        }\n      }\n\n      if (Math.abs(this.cameraModel.pose.position.x - this.player.position.x) >= 0.01 ||\n        Math.abs(this.cameraModel.pose.position.y - this.player.position.y) >= 0.01) {\n\n        const cameraPos = this.cameraModel.pose.position.clone()\n        const playerPos = this.player.position.clone();\n        const playerVel = this.player.velocity.clone();\n        // higher gravity will look like player falling down harder\n        const g = AppConfigs.Gravity > 10 ? (AppConfigs.Gravity - 10) / 10 : 0\n        playerVel.y = playerVel.y < g * playerVel.y ? 0 : playerVel.y\n        // rate of camera movement, with 1 being camera on player at all times\n        const rate = (this.cameraModel.pose.position.y < this.player.position.y ? 0.04 : 0.05);\n        // 1.5 is how much screen moves with player\n        const velocityCamera = cameraPos.clone().plus(playerVel.clone().times(1.5))\n        const new_camera_pos = velocityCamera.clone().plus(playerPos.clone().minus(velocityCamera).times(rate))\n        new_camera_pos.z = 10;\n\n        const new_target_pos = new_camera_pos.clone()\n        new_target_pos.z = 0;\n\n        this.cameraModel.setPose(\n          NodeTransform3D.LookAt(\n            new_camera_pos, new_target_pos,\n            new Vec3(0, 1, 0)\n          )\n        );\n      }\n      this.cameraModel.signalCameraProjectionUpdate();\n    }\n\n    this.lastT = t;\n\n\n    // /**\n    //  * For interactions between models, we can trigger logic here. For example, if you want characters to walk on\n    //  * uneven terrain, you can make that happen by completing the functions used here:\n    //  */\n    // const self = this;\n    // function adjustHeight(character:Particle3D){\n    //     let height = self.terrain.getTerrainHeightAtPoint(character.position.xy);\n    //     if(character.position.z<height){character.position.z = height;}\n    // }\n    //\n    // /**\n    //  * Here we would apply our adjust height function to the player\n    //  */\n    // adjustHeight(this.player);\n    //\n    // /**\n    //  * Now lets update bots\n    //  */\n    // let orbitradius = 0.25;\n    // for(let ei=0;ei<this.bots.length;ei++){\n    //     let e = this.bots[ei];\n    //\n    //     /**\n    //      * Characters have velocity and mass properties in case you want to implement particle physics\n    //      * But for now we will just have them orbit each other.\n    //      */\n    //     e.position = new Vec3(Math.cos(t*(ei+1)), Math.sin(t*(ei+1)),0).times(orbitradius);\n    //\n    //     /**\n    //      * adjust their height\n    //      */\n    //     adjustHeight(e);\n    // }\n  }\n\n  async updateLevel(level: LevelDefinition) {\n    this.currentLevel = level;\n    await this.initScene();\n  }\n\n  getCoordinatesForCursorEvent(event: AInteractionEvent) {\n    return event.ndcCursor ?? new Vec2();\n  }\n}\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}