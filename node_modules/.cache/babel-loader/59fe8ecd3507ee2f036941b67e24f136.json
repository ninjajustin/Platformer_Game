{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport { E_CANCELED } from './errors';\nvar Semaphore = /** @class */function () {\n  function Semaphore(_maxConcurrency, _cancelError) {\n    if (_cancelError === void 0) {\n      _cancelError = E_CANCELED;\n    }\n    this._maxConcurrency = _maxConcurrency;\n    this._cancelError = _cancelError;\n    this._queue = [];\n    this._waiters = [];\n    if (_maxConcurrency <= 0) {\n      throw new Error('semaphore must be initialized to a positive value');\n    }\n    this._value = _maxConcurrency;\n  }\n  Semaphore.prototype.acquire = function () {\n    var _this = this;\n    var locked = this.isLocked();\n    var ticketPromise = new Promise(function (resolve, reject) {\n      return _this._queue.push({\n        resolve: resolve,\n        reject: reject\n      });\n    });\n    if (!locked) this._dispatch();\n    return ticketPromise;\n  };\n  Semaphore.prototype.runExclusive = function (callback) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, value, release;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            return [4 /*yield*/, this.acquire()];\n          case 1:\n            _a = _b.sent(), value = _a[0], release = _a[1];\n            _b.label = 2;\n          case 2:\n            _b.trys.push([2,, 4, 5]);\n            return [4 /*yield*/, callback(value)];\n          case 3:\n            return [2 /*return*/, _b.sent()];\n          case 4:\n            release();\n            return [7 /*endfinally*/];\n          case 5:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  Semaphore.prototype.waitForUnlock = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var waitPromise;\n      var _this = this;\n      return __generator(this, function (_a) {\n        if (!this.isLocked()) {\n          return [2 /*return*/, Promise.resolve()];\n        }\n        waitPromise = new Promise(function (resolve) {\n          return _this._waiters.push({\n            resolve: resolve\n          });\n        });\n        return [2 /*return*/, waitPromise];\n      });\n    });\n  };\n  Semaphore.prototype.isLocked = function () {\n    return this._value <= 0;\n  };\n  /** @deprecated Deprecated in 0.3.0, will be removed in 0.4.0. Use runExclusive instead. */\n  Semaphore.prototype.release = function () {\n    if (this._maxConcurrency > 1) {\n      throw new Error('this method is unavailable on semaphores with concurrency > 1; use the scoped release returned by acquire instead');\n    }\n    if (this._currentReleaser) {\n      var releaser = this._currentReleaser;\n      this._currentReleaser = undefined;\n      releaser();\n    }\n  };\n  Semaphore.prototype.cancel = function () {\n    var _this = this;\n    this._queue.forEach(function (ticket) {\n      return ticket.reject(_this._cancelError);\n    });\n    this._queue = [];\n  };\n  Semaphore.prototype._dispatch = function () {\n    var _this = this;\n    var nextTicket = this._queue.shift();\n    if (!nextTicket) return;\n    var released = false;\n    this._currentReleaser = function () {\n      if (released) return;\n      released = true;\n      _this._value++;\n      _this._resolveWaiters();\n      _this._dispatch();\n    };\n    nextTicket.resolve([this._value--, this._currentReleaser]);\n  };\n  Semaphore.prototype._resolveWaiters = function () {\n    this._waiters.forEach(function (waiter) {\n      return waiter.resolve();\n    });\n    this._waiters = [];\n  };\n  return Semaphore;\n}();\nexport default Semaphore;","map":null,"metadata":{},"sourceType":"module"}