{"ast":null,"code":"import { ASceneController, Color, GetAppState } from \"../../anigraph\";\nimport { ASceneInteractionMode } from \"../../anigraph/scene/interactionmodes/ASceneInteractionMode\";\nconst INTERACTION_MODE_APP_STATE = \"InteractionMode\";\nexport class BaseSceneController extends ASceneController {\n  get model() {\n    return this._model;\n  }\n  async initScene() {\n    this.view.setBackgroundColor(Color.FromString(\"#000000\"));\n    // this.view.loadSkyBox();\n  }\n\n  onAnimationFrameCallback(context) {\n    this.model.timeUpdate(this.model.clock.time);\n    context.renderer.clear();\n    // this.renderer.clear(false, true);\n\n    // render the scene view\n    context.renderer.render(this.view.threejs, this._threeCamera);\n  }\n  createViewForNodeModel(nodeModel) {\n    return super.createViewForNodeModel(nodeModel);\n  }\n\n  //###############################################//--Defining Interaction Modes--\\\\###############################################\n  //<editor-fold desc=\"Defining Interaction Modes\">\n\n  _setCurrentInteractionMode(name) {\n    super.setCurrentInteractionMode(name);\n  }\n  setCurrentInteractionMode(name) {\n    this._setCurrentInteractionMode(name);\n    this._updateInteractionModeOptions();\n  }\n  initInteractions() {\n    const self = this;\n    this.subscribeToAppState(INTERACTION_MODE_APP_STATE, v => {\n      /**\n       * Call _setCurrentInteractionMode here, which just calls the parent version of the function.\n       * This is to avoid an infinite loop caused by calling _updateInteractionModeOptions\n       */\n      self._setCurrentInteractionMode(v);\n    }, INTERACTION_MODE_APP_STATE);\n  }\n  defineInteractionMode(name, mode) {\n    super.defineInteractionMode(name, mode);\n    this._updateInteractionModeOptions();\n  }\n  _updateInteractionModeOptions() {\n    let appState = GetAppState();\n    appState.setSelectionControl(INTERACTION_MODE_APP_STATE, this._currentInteractionModeName, this._interactions.getGUISelectableModesList());\n    appState.updateControlPanel();\n  }\n  createNewInteractionMode(name, interactionCallbacks) {\n    if (this._interactions.modes[name]) {\n      throw new Error(`Tried to create interaction mode \"${name}\", but mode with this name is already defined!`);\n    }\n    let newInteractionMode = new ASceneInteractionMode(name, this, interactionCallbacks);\n    this.defineInteractionMode(name, newInteractionMode);\n  }\n}","map":{"version":3,"names":["ASceneController","Color","GetAppState","ASceneInteractionMode","INTERACTION_MODE_APP_STATE","BaseSceneController","model","_model","initScene","view","setBackgroundColor","FromString","onAnimationFrameCallback","context","timeUpdate","clock","time","renderer","clear","render","threejs","_threeCamera","createViewForNodeModel","nodeModel","_setCurrentInteractionMode","name","setCurrentInteractionMode","_updateInteractionModeOptions","initInteractions","self","subscribeToAppState","v","defineInteractionMode","mode","appState","setSelectionControl","_currentInteractionModeName","_interactions","getGUISelectableModesList","updateControlPanel","createNewInteractionMode","interactionCallbacks","modes","Error","newInteractionMode"],"sources":["/Users/home/Desktop/cs4620-final-project/src/app/BaseClasses/BaseSceneController.ts"],"sourcesContent":["import {\n    AGLContext,\n    AInteractionMode,\n    ANodeModel, ASceneController, Color,\n    GetAppState, HasInteractionModeCallbacks,\n} from \"../../anigraph\";\nimport {BaseSceneModel} from \"./BaseSceneModel\";\nimport {ASceneInteractionMode} from \"../../anigraph/scene/interactionmodes/ASceneInteractionMode\";\n\nconst INTERACTION_MODE_APP_STATE = \"InteractionMode\";\n\nexport abstract class BaseSceneController extends ASceneController {\n    get model(): BaseSceneModel {\n        return this._model as BaseSceneModel;\n    }\n    async initScene(): Promise<void> {\n        this.view.setBackgroundColor(Color.FromString(\"#000000\"));\n        // this.view.loadSkyBox();\n    }\n    abstract initModelViewSpecs():void;\n\n    onAnimationFrameCallback(context: AGLContext) {\n        this.model.timeUpdate(this.model.clock.time);\n\n        context.renderer.clear();\n        // this.renderer.clear(false, true);\n\n        // render the scene view\n        context.renderer.render(this.view.threejs, this._threeCamera);\n    }\n\n    createViewForNodeModel(nodeModel: ANodeModel) {\n        return super.createViewForNodeModel(nodeModel)\n    }\n\n    //###############################################//--Defining Interaction Modes--\\\\###############################################\n    //<editor-fold desc=\"Defining Interaction Modes\">\n\n\n\n    _setCurrentInteractionMode(name?:string){\n        super.setCurrentInteractionMode(name);\n    }\n\n    setCurrentInteractionMode(name?: string) {\n        this._setCurrentInteractionMode(name);\n        this._updateInteractionModeOptions();\n    }\n\n\n    initInteractions(){\n        const self = this;\n        this.subscribeToAppState(INTERACTION_MODE_APP_STATE, (v:string)=>{\n            /**\n             * Call _setCurrentInteractionMode here, which just calls the parent version of the function.\n             * This is to avoid an infinite loop caused by calling _updateInteractionModeOptions\n             */\n            self._setCurrentInteractionMode(v);\n        }, INTERACTION_MODE_APP_STATE)\n    }\n\n    defineInteractionMode(name: string, mode?: AInteractionMode) {\n        super.defineInteractionMode(name, mode);\n        this._updateInteractionModeOptions();\n    }\n\n    _updateInteractionModeOptions(){\n        let appState = GetAppState();\n        appState.setSelectionControl(\n            INTERACTION_MODE_APP_STATE,\n            this._currentInteractionModeName,\n            this._interactions.getGUISelectableModesList()\n        )\n        appState.updateControlPanel();\n    }\n\n    createNewInteractionMode(\n        name:string,\n        interactionCallbacks?:HasInteractionModeCallbacks\n    ){\n        if(this._interactions.modes[name]){\n            throw new Error(`Tried to create interaction mode \"${name}\", but mode with this name is already defined!`)\n        }\n        let newInteractionMode = new ASceneInteractionMode(name, this, interactionCallbacks);\n        this.defineInteractionMode(name, newInteractionMode);\n    }\n\n}\n"],"mappings":"AAAA,SAGgBA,gBAAgB,EAAEC,KAAK,EACnCC,WAAW,QACR,gBAAgB;AAEvB,SAAQC,qBAAqB,QAAO,6DAA6D;AAEjG,MAAMC,0BAA0B,GAAG,iBAAiB;AAEpD,OAAO,MAAeC,mBAAmB,SAASL,gBAAgB,CAAC;EAC/D,IAAIM,KAAK,GAAmB;IACxB,OAAO,IAAI,CAACC,MAAM;EACtB;EACA,MAAMC,SAAS,GAAkB;IAC7B,IAAI,CAACC,IAAI,CAACC,kBAAkB,CAACT,KAAK,CAACU,UAAU,CAAC,SAAS,CAAC,CAAC;IACzD;EACJ;;EAGAC,wBAAwB,CAACC,OAAmB,EAAE;IAC1C,IAAI,CAACP,KAAK,CAACQ,UAAU,CAAC,IAAI,CAACR,KAAK,CAACS,KAAK,CAACC,IAAI,CAAC;IAE5CH,OAAO,CAACI,QAAQ,CAACC,KAAK,EAAE;IACxB;;IAEA;IACAL,OAAO,CAACI,QAAQ,CAACE,MAAM,CAAC,IAAI,CAACV,IAAI,CAACW,OAAO,EAAE,IAAI,CAACC,YAAY,CAAC;EACjE;EAEAC,sBAAsB,CAACC,SAAqB,EAAE;IAC1C,OAAO,KAAK,CAACD,sBAAsB,CAACC,SAAS,CAAC;EAClD;;EAEA;EACA;;EAIAC,0BAA0B,CAACC,IAAY,EAAC;IACpC,KAAK,CAACC,yBAAyB,CAACD,IAAI,CAAC;EACzC;EAEAC,yBAAyB,CAACD,IAAa,EAAE;IACrC,IAAI,CAACD,0BAA0B,CAACC,IAAI,CAAC;IACrC,IAAI,CAACE,6BAA6B,EAAE;EACxC;EAGAC,gBAAgB,GAAE;IACd,MAAMC,IAAI,GAAG,IAAI;IACjB,IAAI,CAACC,mBAAmB,CAAC1B,0BAA0B,EAAG2B,CAAQ,IAAG;MAC7D;AACZ;AACA;AACA;MACYF,IAAI,CAACL,0BAA0B,CAACO,CAAC,CAAC;IACtC,CAAC,EAAE3B,0BAA0B,CAAC;EAClC;EAEA4B,qBAAqB,CAACP,IAAY,EAAEQ,IAAuB,EAAE;IACzD,KAAK,CAACD,qBAAqB,CAACP,IAAI,EAAEQ,IAAI,CAAC;IACvC,IAAI,CAACN,6BAA6B,EAAE;EACxC;EAEAA,6BAA6B,GAAE;IAC3B,IAAIO,QAAQ,GAAGhC,WAAW,EAAE;IAC5BgC,QAAQ,CAACC,mBAAmB,CACxB/B,0BAA0B,EAC1B,IAAI,CAACgC,2BAA2B,EAChC,IAAI,CAACC,aAAa,CAACC,yBAAyB,EAAE,CACjD;IACDJ,QAAQ,CAACK,kBAAkB,EAAE;EACjC;EAEAC,wBAAwB,CACpBf,IAAW,EACXgB,oBAAiD,EACpD;IACG,IAAG,IAAI,CAACJ,aAAa,CAACK,KAAK,CAACjB,IAAI,CAAC,EAAC;MAC9B,MAAM,IAAIkB,KAAK,CAAE,qCAAoClB,IAAK,gDAA+C,CAAC;IAC9G;IACA,IAAImB,kBAAkB,GAAG,IAAIzC,qBAAqB,CAACsB,IAAI,EAAE,IAAI,EAAEgB,oBAAoB,CAAC;IACpF,IAAI,CAACT,qBAAqB,CAACP,IAAI,EAAEmB,kBAAkB,CAAC;EACxD;AAEJ"},"metadata":{},"sourceType":"module"}