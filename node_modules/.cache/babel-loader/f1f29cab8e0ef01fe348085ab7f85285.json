{"ast":null,"code":"import { ANodeModel2D } from \"../../../nodeModel\";\nimport { ALineMaterialModel } from \"../../../../rendering\";\nvar CurveInterpolationModes;\n(function (CurveInterpolationModes) {\n  CurveInterpolationModes[\"Linear\"] = \"Linear\";\n})(CurveInterpolationModes || (CurveInterpolationModes = {}));\nvar CurveCreationInteractionModeStateKeys;\n(function (CurveCreationInteractionModeStateKeys) {\n  CurveCreationInteractionModeStateKeys[\"CurrentCurve\"] = \"CurrentCurve\";\n})(CurveCreationInteractionModeStateKeys || (CurveCreationInteractionModeStateKeys = {}));\nexport class Curve2DModel extends ANodeModel2D {\n  /**\n   * Width/thickness of the spline\n   * @type {number}\n   */\n\n  /**\n   * We will have two interpolation modes: Linear, and CubicBezier.\n   * These are set to the enum declared at the top of this file.\n   * @type {SplineInterpolationModes}\n   */\n\n  /**\n   * Getter and setter for `interpolationMode`, which wraps the protected variable _interpolationMode holding the\n   * current interpolation mode for the spline.\n   * */\n\n  /**\n   * When the interpolation mode changes, we need to signal an update of the geometry.\n   * @param value\n   */\n  set interpolationMode(value) {\n    this._interpolationMode = value;\n    this.signalGeometryUpdate();\n  }\n  get interpolationMode() {\n    return this._interpolationMode;\n  }\n  getStrokeMaterial() {\n    return ALineMaterialModel.GlobalInstance.CreateMaterial();\n  }\n  getFrameMaterial() {\n    return ALineMaterialModel.GlobalInstance.CreateMaterial();\n  }\n  constructor() {\n    super();\n    this.lineWidth = 0.05;\n    this._interpolationMode = CurveInterpolationModes.Linear;\n    this.verts.initColorAttribute();\n  }\n\n  // static DefineCustomInteractionMode(controller:ASceneController, interactionModeName:string) {\n  //     function onKeyDown(\n  //         event: AInteractionEvent,\n  //         interaction: AKeyboardInteraction\n  //     ): void {\n  //     }\n  //\n  //     const self = this;\n  //\n  //     function onKeyUp(event: AInteractionEvent, interaction: AKeyboardInteraction): void {\n  //         if (event.key === \"N\") {\n  //             let newCurve = new self()\n  //             controller.model.addChild(newCurve);\n  //             controller.interactionMode.setModeState(CurveCreationInteractionModeStateKeys.CurrentCurve, newCurve);\n  //         }\n  //     }\n  //\n  //     //\n  //     // function dragStartCallback(\n  //     //     event: AInteractionEvent,\n  //     //     interaction: ADragInteraction\n  //     // ): any {\n  //     //     /**\n  //     //      * Get the world coordinates of the cursor\n  //     //      */\n  //     //     let cursorWorldCoordinates = controller.getCoordinatesForCursorEvent(event);\n  //     //     let currentCurve = controller.interactionMode.getModeState(CurveCreationInteractionModeStateKeys.CurrentCurve) as Curve2DModel;\n  //     //     if(!currentCurve){\n  //     //         return;\n  //     //     }\n  //     //\n  //     //     let newvert = currentCurve.getWorldTransform().getInverse().times(cursorWorldCoordinates);\n  //     //     currentCurve.verts.addVertex(newvert, Color.Random());\n  //     // }\n  //     //\n  //     // function dragMoveCallback(\n  //     //     event: AInteractionEvent,\n  //     //     interaction: ADragInteraction\n  //     // ): any {\n  //     //     let cursorWorldCoordinates:Vec2 = controller.get2DWorldCoordinatesForCursorEvent(event);\n  //     //     let dragStartWorldCoordinates:Vec2 = controller.get2DWorldCoordinatesForCursorEvent(interaction.dragStartEvent);\n  //     //     let currentCurve = controller.interactionMode.getModeState(CurveCreationInteractionModeStateKeys.CurrentCurve) as Curve2DModel;\n  //     //     if(!currentCurve){\n  //     //         return;\n  //     //     }\n  //     //     let newVert = currentCurve.getWorldTransform().getInverse().times(cursorWorldCoordinates);\n  //     //     if(currentCurve.verts.nVerts>0){\n  //     //\n  //     //         currentCurve.verts.position.setAt(currentCurve.verts.nVerts-1, newVert);\n  //     //     }\n  //     // }\n  //     //\n  //     // function dragEndCallback(\n  //     //     event: AInteractionEvent,\n  //     //     interaction: ADragInteraction\n  //     // ): any {\n  //     //     let cursorWorldCoordinates:Vec2 = controller.get2DWorldCoordinatesForCursorEvent(event);\n  //     //     let dragStartWorldCoordinates:Vec2 = controller.get2DWorldCoordinatesForCursorEvent(interaction.dragStartEvent);\n  //     // }\n  //\n  //     // function onClick(event: AInteractionEvent): void {\n  //     //     let cursorWorldCoordinates:Vec2 = controller.get2DWorldCoordinatesForCursorEvent(event);\n  //     // }\n  //\n  //     let currentInteractionMode = controller.interactionMode.name;\n  //     controller.defineInteractionMode(interactionModeName);\n  //     controller.setCurrentInteractionMode(interactionModeName);\n  //\n  //     controller.addInteraction(\n  //         AKeyboardInteraction.Create(\n  //             controller.eventTarget.ownerDocument,\n  //             onKeyDown,\n  //             onKeyUp,\n  //         )\n  //     );\n  //\n  //     controller.addInteraction(\n  //         AClickInteraction.Create(\n  //             controller.eventTarget,\n  //             onClick\n  //         )\n  //     )\n  //\n  //     controller.addInteraction(\n  //         ADragInteraction.Create(\n  //             controller.eventTarget,\n  //             dragStartCallback,\n  //             dragMoveCallback,\n  //             dragEndCallback\n  //         )\n  //     )\n  //\n  //     controller.setCurrentInteractionMode(currentInteractionMode);\n  //\n  // }\n\n  // abstract getPointForProgress(progress: number): Vec2;\n  //\n  // abstract getDerivativeForProgress(progress: number): Vec2;\n  //\n  // abstract getColorForProgress(progress: number): Color;\n}\nCurve2DModel.InterpolationModes = CurveInterpolationModes;","map":{"version":3,"names":["ANodeModel2D","ALineMaterialModel","CurveInterpolationModes","CurveCreationInteractionModeStateKeys","Curve2DModel","interpolationMode","value","_interpolationMode","signalGeometryUpdate","getStrokeMaterial","GlobalInstance","CreateMaterial","getFrameMaterial","constructor","lineWidth","Linear","verts","initColorAttribute","InterpolationModes"],"sources":["/Users/home/Desktop/cs4620-final-project/src/anigraph/scene/nodes/2d/curves/Curve2DModel.ts"],"sourcesContent":["import {ANodeModel2D} from \"../../../nodeModel\";\nimport {ALineMaterialModel} from \"../../../../rendering\";\n\nenum CurveInterpolationModes{\n    Linear=\"Linear\",\n}\n\nenum CurveCreationInteractionModeStateKeys{\n    CurrentCurve=\"CurrentCurve\"\n}\n\nexport class Curve2DModel extends ANodeModel2D {\n    /**\n     * Width/thickness of the spline\n     * @type {number}\n     */\n    lineWidth: number = 0.05;\n\n    /**\n     * We will have two interpolation modes: Linear, and CubicBezier.\n     * These are set to the enum declared at the top of this file.\n     * @type {SplineInterpolationModes}\n     */\n    static InterpolationModes=CurveInterpolationModes;\n\n    /**\n     * Getter and setter for `interpolationMode`, which wraps the protected variable _interpolationMode holding the\n     * current interpolation mode for the spline.\n     * */\n    protected _interpolationMode:CurveInterpolationModes=CurveInterpolationModes.Linear;\n    /**\n     * When the interpolation mode changes, we need to signal an update of the geometry.\n     * @param value\n     */\n    set interpolationMode(value){\n        this._interpolationMode = value;\n        this.signalGeometryUpdate();\n    }\n    get interpolationMode(){return this._interpolationMode;}\n\n    getStrokeMaterial() {\n        return ALineMaterialModel.GlobalInstance.CreateMaterial();\n    }\n\n    getFrameMaterial() {\n        return ALineMaterialModel.GlobalInstance.CreateMaterial();\n    }\n\n    constructor() {\n        super();\n        this.verts.initColorAttribute()\n    }\n\n    // static DefineCustomInteractionMode(controller:ASceneController, interactionModeName:string) {\n    //     function onKeyDown(\n    //         event: AInteractionEvent,\n    //         interaction: AKeyboardInteraction\n    //     ): void {\n    //     }\n    //\n    //     const self = this;\n    //\n    //     function onKeyUp(event: AInteractionEvent, interaction: AKeyboardInteraction): void {\n    //         if (event.key === \"N\") {\n    //             let newCurve = new self()\n    //             controller.model.addChild(newCurve);\n    //             controller.interactionMode.setModeState(CurveCreationInteractionModeStateKeys.CurrentCurve, newCurve);\n    //         }\n    //     }\n    //\n    //     //\n    //     // function dragStartCallback(\n    //     //     event: AInteractionEvent,\n    //     //     interaction: ADragInteraction\n    //     // ): any {\n    //     //     /**\n    //     //      * Get the world coordinates of the cursor\n    //     //      */\n    //     //     let cursorWorldCoordinates = controller.getCoordinatesForCursorEvent(event);\n    //     //     let currentCurve = controller.interactionMode.getModeState(CurveCreationInteractionModeStateKeys.CurrentCurve) as Curve2DModel;\n    //     //     if(!currentCurve){\n    //     //         return;\n    //     //     }\n    //     //\n    //     //     let newvert = currentCurve.getWorldTransform().getInverse().times(cursorWorldCoordinates);\n    //     //     currentCurve.verts.addVertex(newvert, Color.Random());\n    //     // }\n    //     //\n    //     // function dragMoveCallback(\n    //     //     event: AInteractionEvent,\n    //     //     interaction: ADragInteraction\n    //     // ): any {\n    //     //     let cursorWorldCoordinates:Vec2 = controller.get2DWorldCoordinatesForCursorEvent(event);\n    //     //     let dragStartWorldCoordinates:Vec2 = controller.get2DWorldCoordinatesForCursorEvent(interaction.dragStartEvent);\n    //     //     let currentCurve = controller.interactionMode.getModeState(CurveCreationInteractionModeStateKeys.CurrentCurve) as Curve2DModel;\n    //     //     if(!currentCurve){\n    //     //         return;\n    //     //     }\n    //     //     let newVert = currentCurve.getWorldTransform().getInverse().times(cursorWorldCoordinates);\n    //     //     if(currentCurve.verts.nVerts>0){\n    //     //\n    //     //         currentCurve.verts.position.setAt(currentCurve.verts.nVerts-1, newVert);\n    //     //     }\n    //     // }\n    //     //\n    //     // function dragEndCallback(\n    //     //     event: AInteractionEvent,\n    //     //     interaction: ADragInteraction\n    //     // ): any {\n    //     //     let cursorWorldCoordinates:Vec2 = controller.get2DWorldCoordinatesForCursorEvent(event);\n    //     //     let dragStartWorldCoordinates:Vec2 = controller.get2DWorldCoordinatesForCursorEvent(interaction.dragStartEvent);\n    //     // }\n    //\n    //     // function onClick(event: AInteractionEvent): void {\n    //     //     let cursorWorldCoordinates:Vec2 = controller.get2DWorldCoordinatesForCursorEvent(event);\n    //     // }\n    //\n    //     let currentInteractionMode = controller.interactionMode.name;\n    //     controller.defineInteractionMode(interactionModeName);\n    //     controller.setCurrentInteractionMode(interactionModeName);\n    //\n    //     controller.addInteraction(\n    //         AKeyboardInteraction.Create(\n    //             controller.eventTarget.ownerDocument,\n    //             onKeyDown,\n    //             onKeyUp,\n    //         )\n    //     );\n    //\n    //     controller.addInteraction(\n    //         AClickInteraction.Create(\n    //             controller.eventTarget,\n    //             onClick\n    //         )\n    //     )\n    //\n    //     controller.addInteraction(\n    //         ADragInteraction.Create(\n    //             controller.eventTarget,\n    //             dragStartCallback,\n    //             dragMoveCallback,\n    //             dragEndCallback\n    //         )\n    //     )\n    //\n    //     controller.setCurrentInteractionMode(currentInteractionMode);\n    //\n    // }\n\n\n\n    // abstract getPointForProgress(progress: number): Vec2;\n    //\n    // abstract getDerivativeForProgress(progress: number): Vec2;\n    //\n    // abstract getColorForProgress(progress: number): Color;\n\n}\n"],"mappings":"AAAA,SAAQA,YAAY,QAAO,oBAAoB;AAC/C,SAAQC,kBAAkB,QAAO,uBAAuB;AAAC,IAEpDC,uBAAuB;AAAA,WAAvBA,uBAAuB;EAAvBA,uBAAuB;AAAA,GAAvBA,uBAAuB,KAAvBA,uBAAuB;AAAA,IAIvBC,qCAAqC;AAAA,WAArCA,qCAAqC;EAArCA,qCAAqC;AAAA,GAArCA,qCAAqC,KAArCA,qCAAqC;AAI1C,OAAO,MAAMC,YAAY,SAASJ,YAAY,CAAC;EAC3C;AACJ;AACA;AACA;;EAGI;AACJ;AACA;AACA;AACA;;EAGI;AACJ;AACA;AACA;;EAEI;AACJ;AACA;AACA;EACI,IAAIK,iBAAiB,CAACC,KAAK,EAAC;IACxB,IAAI,CAACC,kBAAkB,GAAGD,KAAK;IAC/B,IAAI,CAACE,oBAAoB,EAAE;EAC/B;EACA,IAAIH,iBAAiB,GAAE;IAAC,OAAO,IAAI,CAACE,kBAAkB;EAAC;EAEvDE,iBAAiB,GAAG;IAChB,OAAOR,kBAAkB,CAACS,cAAc,CAACC,cAAc,EAAE;EAC7D;EAEAC,gBAAgB,GAAG;IACf,OAAOX,kBAAkB,CAACS,cAAc,CAACC,cAAc,EAAE;EAC7D;EAEAE,WAAW,GAAG;IACV,KAAK,EAAE;IAAC,KAjCZC,SAAS,GAAW,IAAI;IAAA,KAadP,kBAAkB,GAAyBL,uBAAuB,CAACa,MAAM;IAqB/E,IAAI,CAACC,KAAK,CAACC,kBAAkB,EAAE;EACnC;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAIA;EACA;EACA;EACA;EACA;AAEJ;AAlJab,YAAY,CAYdc,kBAAkB,GAAChB,uBAAuB"},"metadata":{},"sourceType":"module"}