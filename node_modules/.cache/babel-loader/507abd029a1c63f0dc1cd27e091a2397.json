{"ast":null,"code":"import { A3DModelLoader, ACameraModel, APointLightModel, Color, GetAppState, NodeTransform3D, Quaternion, V3, Vec2, Vec3 } from \"../../../../../anigraph\";\nimport { CharacterModel } from \"../../../../BaseClasses\";\nimport { ExampleParticleSystemModel, SphereParticle, TerrainModel } from \"../../../Nodes\";\nimport { AppConfigs } from \"../../../../AppConfigs\";\nimport { ExampleLoadedCharacterModel } from \"../../../Nodes/Loaded/ExampleLoadedCharacterModel\";\nimport { ABasicShaderModel } from \"../../../../../anigraph/rendering/shadermodels/ABasicShaderModel\";\nimport { AddStandardUniforms } from \"../HowToAddUniformToControlPanel\";\nimport { MainSceneModel } from \"../../MainSceneModel\";\nlet appState = GetAppState();\n\n/**\n * Here we will define some enums that are simple strings.\n * These will be what we call different shader model instances. Note that we could just type these strings directly into\n * the code when we use them, but defining them as an enum will help avoid bugs caused by typos, and it will let you use\n * refactoring features of your IDE if you want to change these variables later.\n */\nvar MyMaterialNames;\n(function (MyMaterialNames) {\n  MyMaterialNames[\"basicshader1\"] = \"basicshader1\";\n  MyMaterialNames[\"mymaterial2\"] = \"mymaterial2\";\n  MyMaterialNames[\"ExampleImageDisplay\"] = \"exampleimagedisplay\";\n})(MyMaterialNames || (MyMaterialNames = {}));\nexport class Example3SceneModel extends MainSceneModel {\n  constructor() {\n    super(...arguments);\n    this.loaded3DModel = void 0;\n    this.playerMaterial = void 0;\n  }\n  async loadModelFromFile(path, transform) {\n    /**\n     * Here we need to load the .ply file into an AObject3DModelWrapper instance\n     */\n    let meshObject = await A3DModelLoader.LoadFromPath(path);\n    meshObject.sourceTransform = transform !== null && transform !== void 0 ? transform : new NodeTransform3D();\n    return meshObject;\n  }\n  async PreloadAssets() {\n    await super.PreloadAssets();\n    await TerrainModel.LoadShader();\n    await CharacterModel.LoadShader();\n    await ExampleParticleSystemModel.LoadShader();\n    const self = this;\n\n    /**\n     * Here we will create a shader model and name it with the string defined in `MyMaterialNames.basicshader1`.\n     * The shaderName argument to CreateModel is the name used in the shader folder and glsl files under\n     * `public/shaders/`\n     */\n    let basicshader1ShaderMaterialModel = await ABasicShaderModel.CreateModel(\"customexample1\");\n    await this.materials.setMaterialModel(MyMaterialNames.basicshader1, basicshader1ShaderMaterialModel);\n\n    /**\n     * If we want to use vertex colors in our shader, we need to set useVertexColors to true.\n     * This will turn vertex colors on by default for materials created with this model.\n     * Each time you create a material, you can turn off vertex colors for that material if you want.\n     */\n    basicshader1ShaderMaterialModel.usesVertexColors = true;\n\n    /**\n     * Once a shader model is set like this, we can access it with the material name we assigned it to like so:\n     */\n    this.playerMaterial = this.materials.CreateShaderMaterial(MyMaterialNames.basicshader1);\n\n    /**\n     * Ok, now let's load a 3D model to use for our player.\n     */\n\n    /**\n     * We could use a dragon with vertex colors specified in a .ply file\n     */\n    let dragonTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ(), Vec3.UnitX().times(-1), 0.005);\n    this.loaded3DModel = await this.loadModelFromFile(\"./models/ply/dragon_color_onground.ply\", dragonTransform);\n  }\n  initCamera() {\n    this.cameraModel = ACameraModel.CreatePerspectiveFOV(90, 1, 0.01, 10);\n    this.cameraModel.setPose(NodeTransform3D.LookAt(V3(-0.2, 0.8, 0.75), V3(0, 0, 0.5), V3(0, 0, 0.4)));\n  }\n\n  /**\n   * The view light is a light that is attached to the camera.\n   */\n  initViewLight() {\n    /**\n     * Create a point light\n     * You can have up to 16 point lights in the scene at once by default\n     */\n    this.viewLight = new APointLightModel(this.camera.pose, Color.FromString(\"#ffffff\"), 0.5, AppConfigs.ViewLightRange, 1);\n\n    /**\n     * Add it as a child of the camera model so that it will move with the camera\n     */\n    this.cameraModel.addChild(this.viewLight);\n  }\n  async initTerrain() {\n    this.terrain = await TerrainModel.Create(AppConfigs.GroundTexture,\n    // texture\n    AppConfigs.TerrainScaleX,\n    // scaleX\n    AppConfigs.TerrainScaleY,\n    // scaleY\n    AppConfigs.TerrainDataTextureWidth,\n    // number of vertices wide\n    AppConfigs.TerrainDataTextureHeight,\n    // number of vertices tall\n    undefined,\n    // transform for terrain, identity if left blank\n    AppConfigs.TerrainWrapTextureX,\n    // number of times texture should wrap across surface in X\n    AppConfigs.TerrainWrapTextureY // number of times texture should wrap across surface in Y\n    );\n\n    this.addChild(this.terrain);\n  }\n  async initCharacters() {\n    this.player = new ExampleLoadedCharacterModel(this.loaded3DModel, this.playerMaterial);\n    this.player.transform.rotation = Quaternion.RotationZ(Math.PI * 0.5);\n    AddStandardUniforms(this.player.material);\n    this.addChild(this.player);\n  }\n  async initScene() {\n    await this.initTerrain();\n    await this.initCharacters();\n\n    /**\n     * Now an example particle system.\n     */\n    let particles = new ExampleParticleSystemModel();\n    particles.orbitRadius = 0.3;\n    let radius = 0.05;\n    particles.addParticle(new SphereParticle(undefined, undefined, radius));\n    particles.addParticle(new SphereParticle(undefined, undefined, radius));\n    particles.addParticle(new SphereParticle(undefined, undefined, radius));\n\n    /**\n     * Now let's initialize the view light\n     */\n    this.initViewLight();\n    // this.cameraModel.addChild(this.unitQuad);\n  }\n\n  /**\n   * We update the scene here\n   * @param t\n   * @param args\n   */\n  timeUpdate(t) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    // this.unitQuad.transform.position = V3();\n    // this.unitQuad.transform.rotation = Quaternion.RotationX(t*0.1);\n    this.basicUpdate(t, ...args);\n  }\n\n  /**\n   * Here we will separate out logic that check to see if a particle (characters implement the particle interface, so\n   * this can be used on characters as well) intersects the terrain.\n   * @param particle\n   */\n  adjustParticleHeight(particle) {\n    let height = this.terrain.getTerrainHeightAtPoint(particle.position.xy);\n    if (particle.position.z < height) {\n      particle.position.z = height;\n    }\n  }\n  basicUpdate(t) {\n    /**\n     * We can call timeUpdate on all of the model nodes in the scene here, which will trigger any updates that they\n     * individually define.\n     */\n    for (let c of this.getDescendantList()) {\n      c.timeUpdate(t);\n    }\n  }\n  getCoordinatesForCursorEvent(event) {\n    var _event$ndcCursor;\n    return (_event$ndcCursor = event.ndcCursor) !== null && _event$ndcCursor !== void 0 ? _event$ndcCursor : new Vec2();\n  }\n}","map":{"version":3,"names":["A3DModelLoader","ACameraModel","APointLightModel","Color","GetAppState","NodeTransform3D","Quaternion","V3","Vec2","Vec3","CharacterModel","ExampleParticleSystemModel","SphereParticle","TerrainModel","AppConfigs","ExampleLoadedCharacterModel","ABasicShaderModel","AddStandardUniforms","MainSceneModel","appState","MyMaterialNames","Example3SceneModel","loaded3DModel","playerMaterial","loadModelFromFile","path","transform","meshObject","LoadFromPath","sourceTransform","PreloadAssets","LoadShader","self","basicshader1ShaderMaterialModel","CreateModel","materials","setMaterialModel","basicshader1","usesVertexColors","CreateShaderMaterial","dragonTransform","FromPositionZUpAndScale","UnitZ","UnitX","times","initCamera","cameraModel","CreatePerspectiveFOV","setPose","LookAt","initViewLight","viewLight","camera","pose","FromString","ViewLightRange","addChild","initTerrain","terrain","Create","GroundTexture","TerrainScaleX","TerrainScaleY","TerrainDataTextureWidth","TerrainDataTextureHeight","undefined","TerrainWrapTextureX","TerrainWrapTextureY","initCharacters","player","rotation","RotationZ","Math","PI","material","initScene","particles","orbitRadius","radius","addParticle","timeUpdate","t","args","basicUpdate","adjustParticleHeight","particle","height","getTerrainHeightAtPoint","position","xy","z","c","getDescendantList","getCoordinatesForCursorEvent","event","ndcCursor"],"sources":["/Users/home/Desktop/cs4620-final-project/src/app/main/Scene/ExampleScenes/Example3/Example3SceneModel.ts"],"sourcesContent":["import {\n    A3DModelLoader,\n    ACameraModel, AInteractionEvent,\n    AModel, AObject3DModelWrapper,\n    APointLightModel, ASceneElement, AShaderMaterial, AShaderModel,\n    Color,\n    GetAppState,\n    NodeTransform3D, Quaternion,\n    V3, Vec2,\n    Vec3\n} from \"../../../../../anigraph\";\nimport {CharacterModel} from \"../../../../BaseClasses\";\nimport {\n    ExampleParticleSystemModel,\n    SphereParticle,\n    TerrainModel\n} from \"../../../Nodes\";\nimport {AppConfigs} from \"../../../../AppConfigs\";\nimport {Particle3D} from \"../../../../../anigraph/physics/AParticle3D\";\nimport {ExampleLoadedCharacterModel} from \"../../../Nodes/Loaded/ExampleLoadedCharacterModel\";\nimport {ABasicShaderModel} from \"../../../../../anigraph/rendering/shadermodels/ABasicShaderModel\";\nimport {AddStandardUniforms} from \"../HowToAddUniformToControlPanel\";\nimport {ARenderTarget} from \"../../../../../anigraph/rendering/multipass/ARenderTarget\";\nimport {MainSceneModel} from \"../../MainSceneModel\";\n\nlet appState = GetAppState();\n\n/**\n * Here we will define some enums that are simple strings.\n * These will be what we call different shader model instances. Note that we could just type these strings directly into\n * the code when we use them, but defining them as an enum will help avoid bugs caused by typos, and it will let you use\n * refactoring features of your IDE if you want to change these variables later.\n */\nenum MyMaterialNames{\n    basicshader1=\"basicshader1\",\n    mymaterial2=\"mymaterial2\",\n    ExampleImageDisplay=\"exampleimagedisplay\"\n}\n\n\n\nexport class Example3SceneModel extends MainSceneModel {\n    loaded3DModel!:AObject3DModelWrapper;\n    playerMaterial!:AShaderMaterial;\n\n    async loadModelFromFile(path:string, transform?:NodeTransform3D){\n        /**\n         * Here we need to load the .ply file into an AObject3DModelWrapper instance\n         */\n        let meshObject = await A3DModelLoader.LoadFromPath(path)\n        meshObject.sourceTransform = transform??new NodeTransform3D();\n        return meshObject;\n    }\n\n    async PreloadAssets() {\n        await super.PreloadAssets();\n        await TerrainModel.LoadShader();\n        await CharacterModel.LoadShader();\n        await ExampleParticleSystemModel.LoadShader();\n\n        const self = this;\n\n        /**\n         * Here we will create a shader model and name it with the string defined in `MyMaterialNames.basicshader1`.\n         * The shaderName argument to CreateModel is the name used in the shader folder and glsl files under\n         * `public/shaders/`\n         */\n        let basicshader1ShaderMaterialModel = await ABasicShaderModel.CreateModel(\"customexample1\");\n        await this.materials.setMaterialModel(MyMaterialNames.basicshader1, basicshader1ShaderMaterialModel);\n\n\n\n\n        /**\n         * If we want to use vertex colors in our shader, we need to set useVertexColors to true.\n         * This will turn vertex colors on by default for materials created with this model.\n         * Each time you create a material, you can turn off vertex colors for that material if you want.\n         */\n        basicshader1ShaderMaterialModel.usesVertexColors=true;\n\n        /**\n         * Once a shader model is set like this, we can access it with the material name we assigned it to like so:\n         */\n        this.playerMaterial = this.materials.CreateShaderMaterial(MyMaterialNames.basicshader1);\n\n\n\n        /**\n         * Ok, now let's load a 3D model to use for our player.\n         */\n\n\n        /**\n         * We could use a dragon with vertex colors specified in a .ply file\n         */\n        let dragonTransform = NodeTransform3D.FromPositionZUpAndScale(V3(), Vec3.UnitZ(),Vec3.UnitX().times(-1), 0.005);\n        this.loaded3DModel = await this.loadModelFromFile(\"./models/ply/dragon_color_onground.ply\", dragonTransform);\n    }\n\n\n    initCamera() {\n        this.cameraModel = ACameraModel.CreatePerspectiveFOV(90, 1, 0.01, 10);\n        this.cameraModel.setPose(\n            NodeTransform3D.LookAt(\n                V3(-0.2, 0.8, 0.75), V3(0,0,0.5),\n                V3(0,0,0.4)\n            )\n        )\n    }\n\n    /**\n     * The view light is a light that is attached to the camera.\n     */\n    initViewLight(){\n\n        /**\n         * Create a point light\n         * You can have up to 16 point lights in the scene at once by default\n         */\n        this.viewLight = new APointLightModel(\n            this.camera.pose,\n            Color.FromString(\"#ffffff\"),\n            0.5,\n            AppConfigs.ViewLightRange,\n            1\n        );\n\n        /**\n         * Add it as a child of the camera model so that it will move with the camera\n         */\n        this.cameraModel.addChild(this.viewLight);\n    }\n\n    async initTerrain(){\n        this.terrain = await TerrainModel.Create(\n            AppConfigs.GroundTexture, // texture\n            AppConfigs.TerrainScaleX, // scaleX\n            AppConfigs.TerrainScaleY, // scaleY\n            AppConfigs.TerrainDataTextureWidth, // number of vertices wide\n            AppConfigs.TerrainDataTextureHeight, // number of vertices tall\n            undefined, // transform for terrain, identity if left blank\n            AppConfigs.TerrainWrapTextureX, // number of times texture should wrap across surface in X\n            AppConfigs.TerrainWrapTextureY, // number of times texture should wrap across surface in Y\n        );\n\n        this.addChild(this.terrain);\n    }\n\n\n\n    async initCharacters(){\n        this.player = new ExampleLoadedCharacterModel(\n            this.loaded3DModel,\n            this.playerMaterial\n        );\n        this.player.transform.rotation = Quaternion.RotationZ(Math.PI*0.5);\n        AddStandardUniforms(this.player.material);\n        this.addChild(this.player);\n    }\n\n\n    async initScene() {\n        await this.initTerrain();\n        await this.initCharacters();\n\n        /**\n         * Now an example particle system.\n         */\n        let particles = new ExampleParticleSystemModel();\n        particles.orbitRadius = 0.3;\n        let radius = 0.05;\n        particles.addParticle(new SphereParticle(undefined, undefined, radius));\n        particles.addParticle(new SphereParticle(undefined, undefined, radius));\n        particles.addParticle(new SphereParticle(undefined, undefined, radius));\n\n        /**\n         * Now let's initialize the view light\n         */\n        this.initViewLight();\n        // this.cameraModel.addChild(this.unitQuad);\n\n    }\n\n    /**\n     * We update the scene here\n     * @param t\n     * @param args\n     */\n    timeUpdate(t: number, ...args:any[]) {\n        // this.unitQuad.transform.position = V3();\n        // this.unitQuad.transform.rotation = Quaternion.RotationX(t*0.1);\n        this.basicUpdate(t, ...args);\n    }\n\n    /**\n     * Here we will separate out logic that check to see if a particle (characters implement the particle interface, so\n     * this can be used on characters as well) intersects the terrain.\n     * @param particle\n     */\n    adjustParticleHeight(particle:Particle3D){\n        let height = this.terrain.getTerrainHeightAtPoint(particle.position.xy);\n        if(particle.position.z<height){particle.position.z = height;}\n    }\n\n    basicUpdate(t:number, ...args:any[]){\n        /**\n         * We can call timeUpdate on all of the model nodes in the scene here, which will trigger any updates that they\n         * individually define.\n         */\n        for(let c of this.getDescendantList()){\n            c.timeUpdate(t);\n        }\n    }\n\n    getCoordinatesForCursorEvent(event: AInteractionEvent){\n        return event.ndcCursor??new Vec2();\n    }\n}\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}