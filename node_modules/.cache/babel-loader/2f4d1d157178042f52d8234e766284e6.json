{"ast":null,"code":"import * as THREE from \"three\";\nimport { OBJLoader } from \"three/examples/jsm/loaders/OBJLoader\";\nimport { PLYLoader } from \"three/examples/jsm/loaders/PLYLoader\";\nimport { AObject3DModelWrapper } from \"../geometry\";\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\";\nfunction getDescendantMesh(obj) {\n  if (obj.type === \"Mesh\") {\n    return obj;\n  } else {\n    for (let c of obj.children) {\n      let cm = getDescendantMesh(c);\n      if (cm && cm.type === \"Mesh\") {\n        return cm;\n      }\n    }\n  }\n  return;\n}\nexport class A3DModelLoader {\n  static async _LoadFromPath(path, callback) {\n    let computeVertexNormals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    function handleLoadedObject3D(obj) {\n      if (obj instanceof THREE.BufferGeometry) {\n        if (obj.attributes.normal == undefined) {\n          obj.computeVertexNormals();\n        }\n        let threemesh = new THREE.Mesh(obj);\n        if (computeVertexNormals) {\n          obj.computeVertexNormals();\n        }\n        callback(new AObject3DModelWrapper(threemesh));\n      } else {\n        callback(new AObject3DModelWrapper(obj));\n      }\n    }\n    let extension = path.split('.').pop();\n    let loader;\n    switch (extension) {\n      case 'obj':\n        loader = new OBJLoader();\n        break;\n      case 'ply':\n        loader = new PLYLoader();\n        break;\n      case 'glb':\n        loader = new GLTFLoader();\n        break;\n      default:\n        throw new Error(`Extension \"${extension}\" not recognized`);\n    }\n    loader.setCrossOrigin(\"\");\n    // @ts-ignore\n    loader.load(path, handleLoadedObject3D);\n    // return loader.loadAsync(path, handleLoadedObject3D)\n  }\n\n  static async LoadSceneFromPath(path) {\n    let computeVertexNormals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let extension = path.split('.').pop();\n    let loader;\n    switch (extension) {\n      case 'obj':\n        loader = new OBJLoader();\n        break;\n      case 'ply':\n        loader = new PLYLoader();\n        break;\n      case 'glb':\n        loader = new GLTFLoader();\n        break;\n      default:\n        throw new Error(`Extension \"${extension}\" not recognized`);\n    }\n    loader.setCrossOrigin(\"\");\n    let obj = await loader.loadAsync(path);\n    if (extension === 'glb') {\n      return new AObject3DModelWrapper(obj.scenes[0]);\n    }\n    if (obj instanceof THREE.BufferGeometry) {\n      if (obj.attributes.normal == undefined || computeVertexNormals) {\n        //obj.computeVertexNormals()\n      }\n      let threemesh = new THREE.Mesh(obj);\n      return new AObject3DModelWrapper(threemesh);\n    } else {\n      return new AObject3DModelWrapper(obj);\n    }\n  }\n  static async LoadFromPath(path) {\n    let computeVertexNormals = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let extension = path.split('.').pop();\n    let loader;\n    switch (extension) {\n      case 'obj':\n        loader = new OBJLoader();\n        break;\n      case 'ply':\n        loader = new PLYLoader();\n        break;\n      case 'glb':\n        loader = new GLTFLoader();\n        break;\n      default:\n        throw new Error(`Extension \"${extension}\" not recognized`);\n    }\n    loader.setCrossOrigin(\"\");\n    let obj = await loader.loadAsync(path);\n    if (extension === 'glb') {\n      let mesh = getDescendantMesh(obj.scenes[0]);\n      if (mesh) {\n        return new AObject3DModelWrapper(mesh);\n      } else {\n        return new AObject3DModelWrapper(obj.scenes[0]);\n      }\n    }\n    if (obj instanceof THREE.BufferGeometry) {\n      let threemesh = new THREE.Mesh(obj);\n      return new AObject3DModelWrapper(threemesh);\n    } else {\n      return new AObject3DModelWrapper(obj);\n    }\n  }\n}","map":{"version":3,"names":["THREE","OBJLoader","PLYLoader","AObject3DModelWrapper","GLTFLoader","getDescendantMesh","obj","type","c","children","cm","A3DModelLoader","_LoadFromPath","path","callback","computeVertexNormals","handleLoadedObject3D","BufferGeometry","attributes","normal","undefined","threemesh","Mesh","extension","split","pop","loader","Error","setCrossOrigin","load","LoadSceneFromPath","loadAsync","scenes","LoadFromPath","mesh"],"sources":["/Users/home/Desktop/cs4620-final-project/src/anigraph/fileio/A3DModelLoader.ts"],"sourcesContent":["import {AMaterial} from \"../rendering\";\nimport * as THREE from \"three\";\nimport {Loader, Object3D} from \"three\";\nimport {OBJLoader} from \"three/examples/jsm/loaders/OBJLoader\";\nimport {PLYLoader} from \"three/examples/jsm/loaders/PLYLoader\";\nimport {AObject3DModelWrapper} from \"../geometry\";\nimport {GLTFLoader} from \"three/examples/jsm/loaders/GLTFLoader\";\n\n\nfunction getDescendantMesh(obj:THREE.Object3D):THREE.Mesh|undefined{\n    if(obj.type===\"Mesh\"){\n        return obj as THREE.Mesh;\n    }else{\n        for(let c of obj.children){\n            let cm = getDescendantMesh(c);\n            if(cm && cm.type ===\"Mesh\"){\n                return cm;\n            }\n        }\n    }\n    return;\n}\n\nexport class A3DModelLoader{\n    static async _LoadFromPath(path:string, callback:(model:AObject3DModelWrapper)=>Promise<void>, computeVertexNormals:boolean=false) {\n\n        function handleLoadedObject3D(obj: THREE.Object3D) {\n\n            if (obj instanceof THREE.BufferGeometry) {\n                if (obj.attributes.normal == undefined) {\n                    obj.computeVertexNormals()\n                }\n                let threemesh = new THREE.Mesh(obj);\n                if(computeVertexNormals) {\n                    obj.computeVertexNormals()\n                }\n                callback(new AObject3DModelWrapper(threemesh));\n            } else {\n                callback(new AObject3DModelWrapper(obj));\n            }\n        }\n\n        let extension = path.split('.').pop();\n        let loader: Loader;\n        switch (extension) {\n            case 'obj':\n                loader = new OBJLoader();\n                break;\n            case 'ply':\n                loader = new PLYLoader();\n                break;\n            case 'glb':\n                loader = new GLTFLoader();\n                break;\n            default:\n                throw new Error(`Extension \"${extension}\" not recognized`);\n        }\n        loader.setCrossOrigin(\"\");\n        // @ts-ignore\n        loader.load(path, handleLoadedObject3D);\n        // return loader.loadAsync(path, handleLoadedObject3D)\n    }\n    static async LoadSceneFromPath(path:string, computeVertexNormals:boolean=false) {\n        let extension = path.split('.').pop();\n        let loader: Loader;\n        switch (extension) {\n            case 'obj':\n                loader = new OBJLoader();\n                break;\n            case 'ply':\n                loader = new PLYLoader();\n                break;\n            case 'glb':\n                loader = new GLTFLoader();\n                break;\n            default:\n                throw new Error(`Extension \"${extension}\" not recognized`);\n        }\n        loader.setCrossOrigin(\"\");\n        let obj = await loader.loadAsync(path);\n        if(extension === 'glb'){\n            return new AObject3DModelWrapper(obj.scenes[0]);\n        }\n        if (obj instanceof THREE.BufferGeometry) {\n            if (obj.attributes.normal == undefined || computeVertexNormals) {\n                //obj.computeVertexNormals()\n            }\n            let threemesh = new THREE.Mesh(obj);\n            return new AObject3DModelWrapper(threemesh);\n        } else {\n            return new AObject3DModelWrapper(obj);\n        }\n    }\n\n    static async LoadFromPath(path:string, computeVertexNormals:boolean=false) {\n        let extension = path.split('.').pop();\n        let loader: Loader;\n        switch (extension) {\n            case 'obj':\n                loader = new OBJLoader();\n                break;\n            case 'ply':\n                loader = new PLYLoader();\n                break;\n            case 'glb':\n                loader = new GLTFLoader();\n                break;\n            default:\n                throw new Error(`Extension \"${extension}\" not recognized`);\n        }\n        loader.setCrossOrigin(\"\");\n        let obj = await loader.loadAsync(path);\n        if(extension === 'glb'){\n            let mesh = getDescendantMesh(obj.scenes[0]);\n            if(mesh){\n                return new AObject3DModelWrapper(mesh);\n            }else{\n                return new AObject3DModelWrapper(obj.scenes[0]);\n            }\n        }\n        if (obj instanceof THREE.BufferGeometry) {\n            let threemesh = new THREE.Mesh(obj);\n            return new AObject3DModelWrapper(threemesh);\n        } else {\n            return new AObject3DModelWrapper(obj);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}