{"ast":null,"code":"\"use strict\";\n\n/**\n * Custom JSX module designed specifically for TypeDoc's needs.\n * When overriding a default TypeDoc theme output, your implementation must create valid {@link Element}\n * instances, which can be most easily done by using TypeDoc's JSX implementation. To use it, set up\n * your tsconfig with the following compiler options:\n * ```json\n * {\n *     \"jsx\": \"react\",\n *     \"jsxFactory\": \"JSX.createElement\",\n *     \"jsxFragmentFactory\": \"JSX.Fragment\"\n * }\n * ```\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.renderElement = exports.createElement = exports.Raw = exports.Fragment = void 0;\nconst jsx_elements_1 = require(\"./jsx.elements\");\nvar jsx_elements_2 = require(\"./jsx.elements\");\nObject.defineProperty(exports, \"Fragment\", {\n  enumerable: true,\n  get: function () {\n    return jsx_elements_2.JsxFragment;\n  }\n});\n/**\n * Used to inject HTML directly into the document.\n */\nfunction Raw(_props) {\n  // This is handled specially by the renderElement function. Instead of being\n  // called, the tag is compared to this function and the `html` prop will be\n  // returned directly.\n  return null;\n}\nexports.Raw = Raw;\nfunction escapeHtml(html) {\n  return html.replace(/[&<>'\"]/g, c => ({\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': \"&quot;\",\n    \"'\": \"&#39;\"\n  })[c]);\n}\nconst voidElements = new Set([\"area\", \"base\", \"br\", \"col\", \"embed\", \"hr\", \"img\", \"input\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\"]);\n/**\n * JSX factory function to create an \"element\" that can later be rendered with {@link renderElement}\n * @param tag\n * @param props\n * @param children\n */\nfunction createElement(tag, props) {\n  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n    children[_key - 2] = arguments[_key];\n  }\n  return {\n    tag,\n    props,\n    children\n  };\n}\nexports.createElement = createElement;\nfunction renderElement(element) {\n  if (!element) {\n    return \"\";\n  }\n  const {\n    tag,\n    props,\n    children\n  } = element;\n  if (typeof tag === \"function\") {\n    if (tag === Raw) {\n      return String(props.html);\n    }\n    return renderElement(tag(Object.assign({\n      children\n    }, props)));\n  }\n  const html = [];\n  if (tag !== jsx_elements_1.JsxFragment) {\n    html.push(\"<\", tag);\n    for (const [key, val] of Object.entries(props !== null && props !== void 0 ? props : {})) {\n      if (val == null) continue;\n      if (typeof val == \"boolean\") {\n        if (val) {\n          html.push(\" \", key);\n        }\n      } else {\n        html.push(\" \", key, \"=\", JSON.stringify(val));\n      }\n    }\n  }\n  let hasChildren = false;\n  if (children.length) {\n    hasChildren = true;\n    if (tag !== jsx_elements_1.JsxFragment) html.push(\">\");\n    renderChildren(children);\n  }\n  if (tag !== jsx_elements_1.JsxFragment) {\n    if (!hasChildren) {\n      if (voidElements.has(tag)) {\n        html.push(\"/>\");\n      } else {\n        html.push(\"></\", tag, \">\");\n      }\n    } else {\n      html.push(\"</\", tag, \">\");\n    }\n  }\n  return html.join(\"\");\n  function renderChildren(children) {\n    for (const child of children) {\n      if (!child) continue;\n      if (Array.isArray(child)) {\n        renderChildren(child);\n      } else if (typeof child === \"string\" || typeof child === \"number\") {\n        html.push(escapeHtml(child.toString()));\n      } else {\n        html.push(renderElement(child));\n      }\n    }\n  }\n}\nexports.renderElement = renderElement;","map":null,"metadata":{},"sourceType":"script"}