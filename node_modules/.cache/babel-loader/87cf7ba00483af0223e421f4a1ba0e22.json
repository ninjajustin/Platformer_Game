{"ast":null,"code":"/***\n * This is almost entirely based on the leva implementation\n */\nimport { V2, Vec2 } from \"../math\";\n\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\nconst NEWTON_ITERATIONS = 4;\nconst NEWTON_MIN_SLOPE = 0.001;\nconst SUBDIVISION_PRECISION = 0.0000001;\nconst SUBDIVISION_MAX_ITERATIONS = 10;\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nconst A = (aA1, aA2) => 1.0 - 3.0 * aA2 + 3.0 * aA1;\n_c = A;\nconst B = (aA1, aA2) => 3.0 * aA2 - 6.0 * aA1;\n_c2 = B;\nconst C = aA1 => 3.0 * aA1;\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n_c3 = C;\nconst calcBezier = (aT, aA1, aA2) => {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n};\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nconst getSlope = (aT, aA1, aA2) => {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n};\nconst binarySubdivide = (aX, aA, aB, mX1, mX2) => {\n  let currentX,\n    currentT,\n    i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n};\nconst newtonRaphsonIterate = (aX, aGuessT, mX1, mX2) => {\n  for (let i = 0; i < NEWTON_ITERATIONS; ++i) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n};\nconst LinearEasing = x => {\n  return x;\n};\n_c4 = LinearEasing;\nexport class BezierTween {\n  static get Linear() {\n    return new BezierTween(0.5, 0.5, 0.5, 0.5);\n  }\n  p0() {\n    return V2(this.x1y1x2y2[0], this.x1y1x2y2[1]);\n  }\n  p1() {\n    return V2(this.x1y1x2y2[2], this.x1y1x2y2[3]);\n  }\n  get x0() {\n    return this.x1y1x2y2[0];\n  }\n  get y0() {\n    return this.x1y1x2y2[1];\n  }\n  get x1() {\n    return this.x1y1x2y2[2];\n  }\n  get y1() {\n    return this.x1y1x2y2[3];\n  }\n  get sampleValues() {\n    return this._sampleValues;\n  }\n  constructor() {\n    this.x1y1x2y2 = void 0;\n    this._sampleValues = void 0;\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (args[0] === undefined) {\n      this.x1y1x2y2 = [0.5, 0.5, 0.5, 0.5];\n    } else {\n      this.x1y1x2y2 = [0, 0, 0, 0];\n      if (Array.isArray(args[0])) {\n        if (args[0].length == 4) {\n          // @ts-ignore\n          this.x1y1x2y2 = args[0];\n        } else {\n          this.x1y1x2y2[0] = args[0][0];\n          this.x1y1x2y2[1] = args[0][1];\n          this.x1y1x2y2[2] = args[1][0];\n          this.x1y1x2y2[3] = args[1][1];\n        }\n      } else if (args[0] instanceof Vec2) {\n        this.x1y1x2y2[0] = args[0].x;\n        this.x1y1x2y2[1] = args[0].y;\n        this.x1y1x2y2[2] = args[1].x;\n        this.x1y1x2y2[3] = args[1].y;\n      } else {\n        this.x1y1x2y2[0] = args[0];\n        this.x1y1x2y2[1] = args[1];\n        this.x1y1x2y2[2] = args[2];\n        this.x1y1x2y2[3] = args[3];\n      }\n    }\n    if (!(0 <= this.x0 && this.x0 <= 1 && 0 <= this.x1 && this.x1 <= 1)) {\n      throw new Error(\"bezier x values must be in [0, 1] range\");\n    }\n\n    // Precompute samples table\n    this._sampleValues = new Float32Array(kSplineTableSize);\n    for (let i = 0; i < kSplineTableSize; ++i) {\n      this.sampleValues[i] = calcBezier(i * kSampleStepSize, this.x0, this.x1);\n    }\n  }\n  _getTForX(aX) {\n    let intervalStart = 0.0;\n    let currentSample = 1;\n    let lastSample = kSplineTableSize - 1;\n    for (; currentSample !== lastSample && this.sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    const dist = (aX - this.sampleValues[currentSample]) / (this.sampleValues[currentSample + 1] - this.sampleValues[currentSample]);\n    const guessForT = intervalStart + dist * kSampleStepSize;\n    const initialSlope = getSlope(guessForT, this.x0, this.x1);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, this.x0, this.x1);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, this.x0, this.x1);\n    }\n  }\n  eval(x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0 || x === 1) {\n      return x;\n    }\n    return calcBezier(this._getTForX(x), this.y0, this.y1);\n  }\n}\nvar _c, _c2, _c3, _c4;\n$RefreshReg$(_c, \"A\");\n$RefreshReg$(_c2, \"B\");\n$RefreshReg$(_c3, \"C\");\n$RefreshReg$(_c4, \"LinearEasing\");","map":{"version":3,"names":["V2","Vec2","NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","A","aA1","aA2","B","C","calcBezier","aT","getSlope","binarySubdivide","aX","aA","aB","mX1","mX2","currentX","currentT","i","Math","abs","newtonRaphsonIterate","aGuessT","currentSlope","LinearEasing","x","BezierTween","Linear","p0","x1y1x2y2","p1","x0","y0","x1","y1","sampleValues","_sampleValues","constructor","args","undefined","Array","isArray","length","y","Error","Float32Array","_getTForX","intervalStart","currentSample","lastSample","dist","guessForT","initialSlope","eval"],"sources":["/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/src/anigraph/geometry/BezierTween.ts"],"sourcesContent":["/***\n * This is almost entirely based on the leva implementation\n */\nimport { V2, Vec2} from \"../math\";\n\n/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\nconst NEWTON_ITERATIONS = 4;\nconst NEWTON_MIN_SLOPE = 0.001;\nconst SUBDIVISION_PRECISION = 0.0000001;\nconst SUBDIVISION_MAX_ITERATIONS = 10;\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nconst A = (aA1: number, aA2: number) => 1.0 - 3.0 * aA2 + 3.0 * aA1;\nconst B = (aA1: number, aA2: number) => 3.0 * aA2 - 6.0 * aA1;\nconst C = (aA1: number) => 3.0 * aA1;\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (aT: number, aA1: number, aA2: number) => {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n};\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nconst getSlope = (aT: number, aA1: number, aA2: number) => {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n};\n\nconst binarySubdivide = (\n  aX: number,\n  aA: number,\n  aB: number,\n  mX1: number,\n  mX2: number\n) => {\n  let currentX,\n    currentT,\n    i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (\n    Math.abs(currentX) > SUBDIVISION_PRECISION &&\n    ++i < SUBDIVISION_MAX_ITERATIONS\n  );\n  return currentT;\n};\n\nconst newtonRaphsonIterate = (\n  aX: number,\n  aGuessT: number,\n  mX1: number,\n  mX2: number\n) => {\n  for (let i = 0; i < NEWTON_ITERATIONS; ++i) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2);\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n  return aGuessT;\n};\n\nconst LinearEasing = (x: number) => {\n  return x;\n};\n\nexport class BezierTween {\n  static get Linear() {\n    return new BezierTween(0.5, 0.5, 0.5, 0.5);\n  }\n\n  x1y1x2y2: [number, number, number, number];\n  p0() {\n    return V2(this.x1y1x2y2[0], this.x1y1x2y2[1]);\n  }\n  p1() {\n    return V2(this.x1y1x2y2[2], this.x1y1x2y2[3]);\n  }\n  get x0() {\n    return this.x1y1x2y2[0];\n  }\n  get y0() {\n    return this.x1y1x2y2[1];\n  }\n  get x1() {\n    return this.x1y1x2y2[2];\n  }\n  get y1() {\n    return this.x1y1x2y2[3];\n  }\n\n  protected _sampleValues: Float32Array;\n  get sampleValues() {\n    return this._sampleValues;\n  }\n\n  constructor();\n  constructor(xyxy: [number, number, number, number]);\n  constructor(x1: number, y1: number, x2: number, y2: number);\n  constructor(p0: Vec2, p1: Vec2);\n  constructor(p0: [number, number], p1: [number, number]);\n  constructor(...args: any[]) {\n    if (args[0] === undefined) {\n      this.x1y1x2y2 = [0.5, 0.5, 0.5, 0.5];\n    } else {\n      this.x1y1x2y2 = [0, 0, 0, 0];\n      if (Array.isArray(args[0])) {\n        if (args[0].length == 4) {\n          // @ts-ignore\n          this.x1y1x2y2 = args[0];\n        } else {\n          this.x1y1x2y2[0] = args[0][0];\n          this.x1y1x2y2[1] = args[0][1];\n          this.x1y1x2y2[2] = args[1][0];\n          this.x1y1x2y2[3] = args[1][1];\n        }\n      } else if (args[0] instanceof Vec2) {\n        this.x1y1x2y2[0] = args[0].x;\n        this.x1y1x2y2[1] = args[0].y;\n        this.x1y1x2y2[2] = args[1].x;\n        this.x1y1x2y2[3] = args[1].y;\n      } else {\n        this.x1y1x2y2[0] = args[0];\n        this.x1y1x2y2[1] = args[1];\n        this.x1y1x2y2[2] = args[2];\n        this.x1y1x2y2[3] = args[3];\n      }\n    }\n\n    if (!(0 <= this.x0 && this.x0 <= 1 && 0 <= this.x1 && this.x1 <= 1)) {\n      throw new Error(\"bezier x values must be in [0, 1] range\");\n    }\n\n    // Precompute samples table\n    this._sampleValues = new Float32Array(kSplineTableSize);\n    for (let i = 0; i < kSplineTableSize; ++i) {\n      this.sampleValues[i] = calcBezier(i * kSampleStepSize, this.x0, this.x1);\n    }\n  }\n\n  _getTForX(aX: number) {\n    let intervalStart = 0.0;\n    let currentSample = 1;\n    let lastSample = kSplineTableSize - 1;\n\n    for (\n      ;\n      currentSample !== lastSample && this.sampleValues[currentSample] <= aX;\n      ++currentSample\n    ) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    const dist =\n      (aX - this.sampleValues[currentSample]) /\n      (this.sampleValues[currentSample + 1] - this.sampleValues[currentSample]);\n    const guessForT = intervalStart + dist * kSampleStepSize;\n\n    const initialSlope = getSlope(guessForT, this.x0, this.x1);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, this.x0, this.x1);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(\n        aX,\n        intervalStart,\n        intervalStart + kSampleStepSize,\n        this.x0,\n        this.x1\n      );\n    }\n  }\n\n  eval(x: number) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0 || x === 1) {\n      return x;\n    }\n    return calcBezier(this._getTForX(x), this.y0, this.y1);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}