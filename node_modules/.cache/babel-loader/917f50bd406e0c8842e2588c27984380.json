{"ast":null,"code":"import { VertexArray } from \"./VertexArray\";\nimport { Mat3, V2, Vec2, Vec3 } from \"../math\";\nimport { BoundingBox3D } from \"./BoundingBox3D\";\nimport { Color } from \"../math\";\nimport { VertexAttributeArray2D, VertexAttributeColor3DArray, VertexAttributeColorArray, VertexPositionArray2DH } from \"./VertexAttributeArray\";\nimport { VertexIndexArray } from \"./VertexIndexArray\";\nexport class VertexArray2D extends VertexArray {\n  /** Get set position */\n  set position(value) {\n    this.attributes[\"position\"] = value;\n  }\n  get position() {\n    return this.attributes[\"position\"];\n  }\n  getBounds() {\n    let b = new BoundingBox3D();\n    b.boundVertexPositionArrray(this.position);\n    return b;\n  }\n  get length() {\n    return this.position.elements.length / 3;\n  }\n  getPoint2DAt(i) {\n    return this.position.getPoint2DAt(i);\n  }\n  FillColor(color) {\n    for (let v = 0; v < this.length; v++) {\n      this.color.setAt(v, color);\n    }\n    return this;\n  }\n  RandomizeColor() {\n    for (let v = 0; v < this.length; v++) {\n      this.color.setAt(v, Color.Random());\n    }\n    return this;\n  }\n  static CreateForCurve() {\n    let hasColor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let v = new this();\n    v.initColorAttribute();\n    return v;\n  }\n  static CircleVArray(size) {\n    let nverts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    let verts = new VertexArray2D();\n    for (let v = 0; v < nverts; v++) {\n      let phase = v * (2 * Math.PI) / nverts;\n      verts.addVertex(V2(Math.cos(phase) * size, Math.sin(phase) * size));\n    }\n    return verts;\n  }\n  static BoundingBoxVerts(minxy, maxxy) {\n    let va = new VertexArray2D();\n    va.addVertex(minxy);\n    va.addVertex(V2(maxxy.x, minxy.y));\n    va.addVertex(maxxy);\n    va.addVertex(V2(minxy.x, maxxy.y));\n    return va;\n  }\n  static Anchor() {\n    let outerRadius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 25;\n    let innerRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n    let location = arguments.length > 2 ? arguments[2] : undefined;\n    let verts = [new Vec2(innerRadius, innerRadius), new Vec2(0, outerRadius), new Vec2(-innerRadius, innerRadius), new Vec2(-outerRadius, 0), new Vec2(-innerRadius, -innerRadius), new Vec2(0, -outerRadius), new Vec2(innerRadius, -innerRadius), new Vec2(outerRadius, 0)];\n    if (location) {\n      verts = verts.map(v => {\n        return v.plus(location);\n      });\n    }\n    return VertexArray2D.FromLists(verts);\n  }\n\n  /**\n   * Positions have to be given with homogeneous coordinates!\n   * @param positions\n   * @param colors\n   */\n  constructor(homogeneous_positions, colors) {\n    super();\n    this.attributes = {};\n    if (homogeneous_positions !== undefined) {\n      this.position = new VertexPositionArray2DH(homogeneous_positions);\n    } else {\n      this.position = new VertexPositionArray2DH();\n    }\n    if (colors !== undefined) {\n      this.initColorAttribute();\n      this.color.setElements(colors);\n    }\n  }\n  initColorAttribute() {\n    this.color = new VertexAttributeColorArray();\n  }\n  initColor3DAttribute() {\n    this.color = new VertexAttributeColor3DArray();\n  }\n  initIndices() {\n    let vertsPerElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n    this.indices = new VertexIndexArray(vertsPerElement);\n  }\n  addVertex(v, color) {\n    this.position.push(v);\n    if (color) {\n      var _this$color;\n      (_this$color = this.color) === null || _this$color === void 0 ? void 0 : _this$color.push(color);\n    }\n  }\n  addVertices(positions, colors) {\n    this.position.pushArray(positions);\n    if (colors) {\n      if (colors instanceof Color) {\n        var _this$color2;\n        (_this$color2 = this.color) === null || _this$color2 === void 0 ? void 0 : _this$color2.pushArray(new Array(positions.length).fill(colors));\n      } else {\n        var _this$color3;\n        (_this$color3 = this.color) === null || _this$color3 === void 0 ? void 0 : _this$color3.pushArray(colors);\n      }\n    }\n  }\n  addVertexToFront(v, color) {\n    this.position.unshift(v);\n    if (color) {\n      var _this$color4;\n      (_this$color4 = this.color) === null || _this$color4 === void 0 ? void 0 : _this$color4.unshift(color);\n    }\n  }\n  addVerticesToFront(positions, colors) {\n    this.position.unshiftArray(positions);\n    if (colors) {\n      var _this$color5;\n      (_this$color5 = this.color) === null || _this$color5 === void 0 ? void 0 : _this$color5.unshiftArray(colors);\n    }\n  }\n  toString() {\n    let rstring = `new VertexArray2D([\\n`;\n    for (let e = 0; e < this.position.elements.length - 1; e++) {\n      rstring = rstring + `${this.position.elements[e]},`;\n    }\n    rstring = rstring + `${this.position.elements[this.position.elements.length - 1]}])`;\n    return rstring;\n  }\n  static FromLists(positions, colors) {\n    let v = new this();\n    if (colors === undefined) {\n      v.addVertices(positions);\n    } else {\n      v.initColorAttribute();\n      v.addVertices(positions, colors);\n    }\n    return v;\n  }\n  get _averagePosition() {\n    let average = new Vec3(0, 0, 0);\n    for (let v = 0; v < this.length; v++) {\n      average.addVector(this.position.getAt(v));\n    }\n    return average.Point2D;\n  }\n  static SquareXYUV() {\n    let scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let wraps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let verts = new VertexArray2D();\n    verts.position = new VertexPositionArray2DH();\n    verts.position.push(V2(-0.5, -0.5).times(scale));\n    verts.position.push(V2(0.5, -0.5).times(scale));\n    verts.position.push(V2(0.5, 0.5).times(scale));\n    verts.position.push(V2(-0.5, 0.5).times(scale));\n    verts.uv = new VertexAttributeArray2D();\n    verts.uv.push(V2(0, 0).times(wraps));\n    verts.uv.push(V2(1, 0).times(wraps));\n    verts.uv.push(V2(1, 1).times(wraps));\n    verts.uv.push(V2(0, 1).times(wraps));\n    verts.indices = new VertexIndexArray(3);\n    verts.indices.push([0, 1, 2]);\n    verts.indices.push([0, 2, 3]);\n    return verts;\n  }\n  setUVToPositions(textureTransform) {\n    var _textureTransform;\n    textureTransform = (_textureTransform = textureTransform) !== null && _textureTransform !== void 0 ? _textureTransform : new Mat3();\n    this.uv = new VertexAttributeArray2D();\n    for (let vi = 0; vi < this.length; vi++) {\n      // let pi = this.position.getAt(vi);\n      // let uvval = textureTransform.times(V3(pi.x,pi.y,1).plus(V3(1.5,0.5,0)));\n      // this.uv.push(uvval.Point2D);\n      this.uv.push(V2(0, 0));\n    }\n  }\n}","map":{"version":3,"names":["VertexArray","Mat3","V2","Vec2","Vec3","BoundingBox3D","Color","VertexAttributeArray2D","VertexAttributeColor3DArray","VertexAttributeColorArray","VertexPositionArray2DH","VertexIndexArray","VertexArray2D","position","value","attributes","getBounds","b","boundVertexPositionArrray","length","elements","getPoint2DAt","i","FillColor","color","v","setAt","RandomizeColor","Random","CreateForCurve","hasColor","initColorAttribute","CircleVArray","size","nverts","verts","phase","Math","PI","addVertex","cos","sin","BoundingBoxVerts","minxy","maxxy","va","x","y","Anchor","outerRadius","innerRadius","location","map","plus","FromLists","constructor","homogeneous_positions","colors","undefined","setElements","initColor3DAttribute","initIndices","vertsPerElement","indices","push","addVertices","positions","pushArray","Array","fill","addVertexToFront","unshift","addVerticesToFront","unshiftArray","toString","rstring","e","_averagePosition","average","addVector","getAt","Point2D","SquareXYUV","scale","wraps","times","uv","setUVToPositions","textureTransform","vi"],"sources":["/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/src/anigraph/geometry/VertexArray2D.ts"],"sourcesContent":["import { VertexArray } from \"./VertexArray\";\nimport {Mat3, V2, V3, Vec2, Vec3, Vec4} from \"../math\";\nimport { BoundingBox3D } from \"./BoundingBox3D\";\nimport { Color} from \"../math\";\nimport {\n  VertexAttributeArray, VertexAttributeArray2D, VertexAttributeArray3D,\n  VertexAttributeColor3DArray,\n  VertexAttributeColorArray,\n  VertexPositionArray2DH,\n} from \"./VertexAttributeArray\";\nimport {VertexIndexArray} from \"./VertexIndexArray\";\n\nexport class VertexArray2D extends VertexArray<Vec2> {\n  public attributes: { [name: string]: VertexAttributeArray<any> } = {};\n\n  /** Get set position */\n  set position(value: VertexPositionArray2DH) {\n    this.attributes[\"position\"] = value;\n  }\n  get position(): VertexPositionArray2DH {\n    return this.attributes[\"position\"] as VertexPositionArray2DH;\n  }\n\n  getBounds() {\n    let b = new BoundingBox3D();\n    b.boundVertexPositionArrray(this.position);\n    return b;\n  }\n\n  get length() {\n    return this.position.elements.length / 3;\n  }\n\n  getPoint2DAt(i: number) {\n    return this.position.getPoint2DAt(i);\n  }\n\n  FillColor(color:Color){\n    for (let v = 0; v < this.length; v++) {\n      this.color.setAt(v, color);\n    }\n    return this;\n  }\n\n  RandomizeColor(){\n    for (let v = 0; v < this.length; v++) {\n      this.color.setAt(v, Color.Random());\n    }\n    return this;\n  }\n\n\n  static CreateForCurve(hasColor:boolean=true) {\n    let v = new this();\n    v.initColorAttribute();\n    return v;\n  }\n\n  static CircleVArray(size: number, nverts: number = 16) {\n    let verts = new VertexArray2D();\n    for (let v = 0; v < nverts; v++) {\n      let phase = (v * (2 * Math.PI)) / nverts;\n      verts.addVertex(V2(Math.cos(phase) * size, Math.sin(phase) * size));\n    }\n    return verts;\n  }\n\n  static BoundingBoxVerts(minxy: Vec2, maxxy: Vec2) {\n    let va = new VertexArray2D();\n    va.addVertex(minxy);\n    va.addVertex(V2(maxxy.x, minxy.y));\n    va.addVertex(maxxy);\n    va.addVertex(V2(minxy.x, maxxy.y));\n    return va;\n  }\n\n  static Anchor(\n    outerRadius: number = 25,\n    innerRadius: number = 10,\n    location?: Vec2\n  ) {\n    let verts = [\n      new Vec2(innerRadius, innerRadius),\n      new Vec2(0, outerRadius),\n      new Vec2(-innerRadius, innerRadius),\n      new Vec2(-outerRadius, 0),\n      new Vec2(-innerRadius, -innerRadius),\n      new Vec2(0, -outerRadius),\n      new Vec2(innerRadius, -innerRadius),\n      new Vec2(outerRadius, 0),\n    ];\n    if (location) {\n      verts = verts.map((v) => {\n        return v.plus(location);\n      });\n    }\n    return VertexArray2D.FromLists(verts);\n  }\n\n  /**\n   * Positions have to be given with homogeneous coordinates!\n   * @param positions\n   * @param colors\n   */\n  constructor(homogeneous_positions?: number[], colors?: number[]) {\n    super();\n    if (homogeneous_positions !== undefined) {\n      this.position = new VertexPositionArray2DH(homogeneous_positions);\n    } else {\n      this.position = new VertexPositionArray2DH();\n    }\n    if(colors !== undefined){\n      this.initColorAttribute();\n      this.color.setElements(colors);\n    }\n  }\n\n  initColorAttribute(){\n    this.color = new VertexAttributeColorArray();\n  }\n  initColor3DAttribute(){\n    this.color = new VertexAttributeColor3DArray();\n  }\n  initIndices(vertsPerElement:number=2){\n    this.indices = new VertexIndexArray(vertsPerElement);\n  }\n\n  addVertex(v: Vec2 | Vec3, color?: Color | Vec3 | Vec4) {\n    this.position.push(v);\n    if (color) {\n      this.color?.push(color);\n    }\n  }\n\n  addVertices(positions: Vec2[] | Vec3[], colors?: Color|Color[] | Vec3[] | Vec4[]) {\n    this.position.pushArray(positions);\n    if (colors) {\n      if(colors instanceof Color){\n        this.color?.pushArray(new Array(positions.length).fill(colors));\n      }else {\n        this.color?.pushArray(colors);\n      }\n    }\n  }\n\n  addVertexToFront(v: Vec2 | Vec3, color?: Color | Vec3 | Vec4){\n    this.position.unshift(v);\n    if (color) {\n      this.color?.unshift(color);\n    }\n  }\n\n  addVerticesToFront(positions: Vec2[] | Vec3[], colors?: Color[] | Vec3[] | Vec4[]) {\n    this.position.unshiftArray(positions);\n    if (colors) {\n      this.color?.unshiftArray(colors)\n    }\n  }\n\n\n  toString() {\n    let rstring = `new VertexArray2D([\\n`;\n    for (let e = 0; e < this.position.elements.length - 1; e++) {\n      rstring = rstring + `${this.position.elements[e]},`;\n    }\n    rstring =\n      rstring +\n      `${this.position.elements[this.position.elements.length - 1]}])`;\n    return rstring;\n  }\n\n  static FromLists(positions:Vec2[], colors?:Color[]){\n    let v = new this();\n    if(colors===undefined) {\n      v.addVertices(positions);\n    }else{\n      v.initColorAttribute()\n      v.addVertices(positions, colors);\n    }\n    return v;\n  }\n\n  get _averagePosition() {\n    let average = new Vec3(0, 0, 0);\n    for (let v = 0; v < this.length; v++) {\n      average.addVector(this.position.getAt(v));\n    }\n    return average.Point2D;\n  }\n\n\n  static SquareXYUV(scale:number=1, wraps:number=1){\n    let verts = new VertexArray2D();\n    verts.position= new VertexPositionArray2DH();\n    verts.position.push(V2(-0.5,-0.5).times(scale))\n    verts.position.push(V2(0.5,-0.5).times(scale))\n    verts.position.push(V2(0.5,0.5).times(scale))\n    verts.position.push(V2(-0.5,0.5).times(scale))\n    verts.uv = new VertexAttributeArray2D()\n    verts.uv.push(V2(0,0).times(wraps));\n    verts.uv.push(V2(1,0).times(wraps));\n    verts.uv.push(V2(1,1).times(wraps));\n    verts.uv.push(V2(0,1).times(wraps));\n    verts.indices = new VertexIndexArray(3);\n    verts.indices.push([0,1,2]);\n    verts.indices.push([0,2,3]);\n    return verts;\n  }\n\n  setUVToPositions(textureTransform?:Mat3){\n    textureTransform = textureTransform??new Mat3();\n    this.uv = new VertexAttributeArray2D();\n    for(let vi=0;vi<this.length;vi++){\n      // let pi = this.position.getAt(vi);\n      // let uvval = textureTransform.times(V3(pi.x,pi.y,1).plus(V3(1.5,0.5,0)));\n      // this.uv.push(uvval.Point2D);\n      this.uv.push(V2(0,0));\n    }\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}