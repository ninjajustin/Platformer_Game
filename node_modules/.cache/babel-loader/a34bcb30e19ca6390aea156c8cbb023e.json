{"ast":null,"code":"var _dec, _class;\nimport { AParticleSystemModel } from \"../../../../anigraph/effects/particles/AParticleSystemModel\";\nimport { ASerializable, Color, GetAppState, NodeTransform3D, Quaternion, V3 } from \"../../../../anigraph\";\nimport { BillboardParticle } from \"./BillboardParticle\";\nimport { BillboardParticleSystemView } from \"./BillboardParticleSystemView\";\nlet appState = GetAppState();\nexport let BillboardParticleSystemModel = (_dec = ASerializable(\"BillboardParticleSystemModel\"), _dec(_class = class BillboardParticleSystemModel extends AParticleSystemModel {\n  //particles:ABillboardParticle[]\n\n  // /**\n  //  * This is an example of how you can add particle system controls to the control panel\n  //  * @constructor\n  //  */\n  // static AddParticleSystemControls(){\n  // }\n\n  /**\n   * This will emit a new particle. The starter implementation does this in a round-robin order, so it will recycle\n   * the particle that was emitted least recently.\n   */\n  emit() {\n    let i = (this.lastEmittedIndex + 1) % this.nParticles;\n\n    // set starting position to a random point inside a circle on the xz plane\n    let startingPosition = V3(.5, 0, 0).times(Math.random()).getRotatedByQuaternion(Quaternion.RotationY(Math.random() * 2 * Math.PI));\n    startingPosition = startingPosition.plus(this.myTransform.position);\n    let rotation = Quaternion.RotationY(Math.random() * 2 * Math.PI);\n    let startingVelocity = V3(0, this.initialUpSpeed, 0).getRotatedByQuaternion(rotation);\n    this.particles[i].right = this.particles[i].right.getRotatedByQuaternion(rotation);\n    this.particles[i].position = startingPosition;\n    this.particles[i].velocity = startingVelocity;\n    this.particles[i].sinOffset = Math.random() * 2 * Math.PI;\n    this.particles[i].mass = 3;\n    this.particles[i].size = this.initialSize;\n    this.particles[i].visible = true;\n    this.particles[i].timeSinceEmitted = 0;\n    this.particles[i].color = this.particleColor;\n    this.lastEmittedIndex = i;\n  }\n\n  /**\n   * Here you initialize the particles\n   * @param nParticles\n   */\n  initParticles(nParticles) {\n    for (let i = 0; i < nParticles; i++) {\n      let newp = new BillboardParticle();\n\n      /**\n       * Here we will initialize the particles to be invisible.\n       * This won't do anything on its own, though; you will have to ensure that invisible particles are not visible in your corresponding custom view class.\n       */\n      newp.visible = false;\n\n      /**\n       * Let's add the particle...\n       */\n      newp.initialUpSpeed = this.initialUpSpeed;\n      this.addParticle(newp);\n    }\n  }\n  constructor(transform) {\n    super();\n    this.lastEmittedIndex = 0;\n    this.lastTimeUpdate = -1;\n    this.cameraTransform = new NodeTransform3D();\n    this.myTransform = new NodeTransform3D();\n    this.disabled = false;\n    this.timeSinceEmitted = 0;\n    this.emissionCount = 0;\n    this.initialUpSpeed = .5;\n    this.initialSize = 1;\n    this.particleColor = Color.FromRGBA(222 + (256 - 222) * Math.random() / 256, 106 / 256, 44 / 256, .8);\n    this.initParticles(BillboardParticleSystemView.MAX_PARTICLES);\n    this.signalParticlesUpdated();\n    if (transform != undefined) this.myTransform = transform;\n  }\n  updateCameraTransform(transform) {\n    this.cameraTransform = transform;\n  }\n  setDisable() {\n    this.disabled = true;\n    this.myTransform.position = V3(0, -999, 0);\n    for (let i = 0; i < this.particles.length; i++) {\n      this.particles[i].position = V3(0, -999, 0);\n      this.particles[i].velocity = V3(0, 0, 0);\n    }\n  }\n  timeUpdate(t) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    super.timeUpdate(t, ...args);\n\n    /**\n     * This is one way to check and see if we are in our first timeUpdate call.\n     * We initialized this.lastTimeUpdate to -1, so if it is less than 0 we know it's our first time calling this function.\n     */\n    if (this.lastTimeUpdate < 0) {\n      this.lastTimeUpdate = t;\n    }\n    let timePassed = t - this.lastTimeUpdate;\n    this.lastTimeUpdate = t;\n    this.timeSinceEmitted += timePassed;\n    if (this.disabled) return;\n\n    /**\n     * Let's emit a new particle\n     */\n    // if (this.emissionCount < this.nParticles || this.timeSinceEmitted > 0){\n    //     this.emit();\n    //     this.timeSinceEmitted = 0;\n    //     if(this.emissionCount < this.nParticles) this.emissionCount++;\n    // }\n    this.emit();\n\n    /**\n     * Here we will define some behavior for our particles. This is a bare minimum simple forward euler simulation.\n     */\n\n    for (let i = 0; i < this.particles.length; i++) {\n      let p = this.particles[i];\n      p.position = p.position.plus(p.velocity.times(3 * timePassed));\n      p.update(t, timePassed);\n    }\n\n    /**\n     * This is important! You need to signal that the particles have been updated to trigger re-rendering of the view!\n     */\n    this.signalParticlesUpdated();\n  }\n}) || _class);","map":{"version":3,"names":["AParticleSystemModel","ASerializable","Color","GetAppState","NodeTransform3D","Quaternion","V3","BillboardParticle","BillboardParticleSystemView","appState","BillboardParticleSystemModel","emit","i","lastEmittedIndex","nParticles","startingPosition","times","Math","random","getRotatedByQuaternion","RotationY","PI","plus","myTransform","position","rotation","startingVelocity","initialUpSpeed","particles","right","velocity","sinOffset","mass","size","initialSize","visible","timeSinceEmitted","color","particleColor","initParticles","newp","addParticle","constructor","transform","lastTimeUpdate","cameraTransform","disabled","emissionCount","FromRGBA","MAX_PARTICLES","signalParticlesUpdated","undefined","updateCameraTransform","setDisable","length","timeUpdate","t","args","timePassed","p","update"],"sources":["/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/src/app/main/Nodes/BillboardParticleSystem/BillboardParticleSystemModel.ts"],"sourcesContent":["import {AParticleSystemModel} from \"../../../../anigraph/effects/particles/AParticleSystemModel\";\nimport {ASerializable, Color, GetAppState, NodeTransform3D, Quaternion, V3, Vec3} from \"../../../../anigraph\";\nimport {AppConfigs} from \"../../../AppConfigs\";\nimport {BillboardParticle} from \"./BillboardParticle\";\nimport { v3 } from \"uuid\";\nimport {BillboardParticleSystemView} from \"./BillboardParticleSystemView\";\n\n\nlet appState = GetAppState();\n\n@ASerializable(\"BillboardParticleSystemModel\")\nexport class BillboardParticleSystemModel extends AParticleSystemModel<BillboardParticle>{\n    //particles:ABillboardParticle[]\n    lastEmittedIndex:number=0;\n    lastTimeUpdate:number=-1;\n    cameraTransform:NodeTransform3D = new NodeTransform3D();\n    myTransform:NodeTransform3D = new NodeTransform3D();\n    disabled:boolean = false;\n    timeSinceEmitted:number = 0;\n    emissionCount:number = 0;\n\n    initialUpSpeed:number = .5;\n    initialSize:number = 1;\n    particleColor:Color = Color.FromRGBA(222 + (256 - 222) * Math.random() / 256, 106 / 256, 44 / 256, .8);\n\n    // /**\n    //  * This is an example of how you can add particle system controls to the control panel\n    //  * @constructor\n    //  */\n    // static AddParticleSystemControls(){\n    // }\n\n    /**\n     * This will emit a new particle. The starter implementation does this in a round-robin order, so it will recycle\n     * the particle that was emitted least recently.\n     */\n    emit(){\n        let i=(this.lastEmittedIndex+1)%(this.nParticles);\n\n        // set starting position to a random point inside a circle on the xz plane\n        let startingPosition = V3(.5, 0, 0).times(Math.random()).getRotatedByQuaternion(Quaternion.RotationY(Math.random() * 2 * Math.PI));\n        startingPosition = startingPosition.plus(this.myTransform.position);\n        let rotation = Quaternion.RotationY(Math.random() * 2 * Math.PI);\n        let startingVelocity = V3(0,this.initialUpSpeed,0).getRotatedByQuaternion(rotation);\n\n        this.particles[i].right = this.particles[i].right.getRotatedByQuaternion(rotation);\n        this.particles[i].position = startingPosition;\n        this.particles[i].velocity = startingVelocity;\n        this.particles[i].sinOffset = Math.random() * 2 * Math.PI\n        this.particles[i].mass = 3;\n        this.particles[i].size = this.initialSize;\n        this.particles[i].visible=true;\n        this.particles[i].timeSinceEmitted=0;\n        this.particles[i].color = this.particleColor;\n        this.lastEmittedIndex=i;\n    }\n\n    /**\n     * Here you initialize the particles\n     * @param nParticles\n     */\n    initParticles(nParticles:number){\n        for(let i=0;i<nParticles;i++){\n            let newp = new BillboardParticle();\n\n            /**\n             * Here we will initialize the particles to be invisible.\n             * This won't do anything on its own, though; you will have to ensure that invisible particles are not visible in your corresponding custom view class.\n             */\n            newp.visible=false;\n\n            /**\n             * Let's add the particle...\n             */\n            newp.initialUpSpeed = this.initialUpSpeed;\n            this.addParticle(newp);\n        }\n    }\n\n    constructor(transform?:NodeTransform3D, ...args:any[]) {\n        super();\n        this.initParticles(BillboardParticleSystemView.MAX_PARTICLES);\n        this.signalParticlesUpdated();\n        if (transform != undefined)\n            this.myTransform = transform;\n    }\n\n    updateCameraTransform(transform: NodeTransform3D){\n        this.cameraTransform = transform\n    }\n\n    setDisable() {\n        this.disabled = true;\n        this.myTransform.position = V3(0, -999, 0);\n        for(let i=0;i<this.particles.length;i++){\n            this.particles[i].position = V3(0, -999, 0);\n            this.particles[i].velocity = V3(0, 0, 0);\n        }\n    }\n\n    timeUpdate(t: number, ...args:any[]) {\n        super.timeUpdate(t, ...args);\n\n        /**\n         * This is one way to check and see if we are in our first timeUpdate call.\n         * We initialized this.lastTimeUpdate to -1, so if it is less than 0 we know it's our first time calling this function.\n         */\n        if(this.lastTimeUpdate<0){\n            this.lastTimeUpdate=t;\n        }\n\n        let timePassed = t-this.lastTimeUpdate;\n        this.lastTimeUpdate=t;\n        this.timeSinceEmitted += timePassed;\n        if (this.disabled) return;\n\n        /**\n         * Let's emit a new particle\n         */\n        // if (this.emissionCount < this.nParticles || this.timeSinceEmitted > 0){\n        //     this.emit();\n        //     this.timeSinceEmitted = 0;\n        //     if(this.emissionCount < this.nParticles) this.emissionCount++;\n        // }\n        this.emit();\n\n        /**\n         * Here we will define some behavior for our particles. This is a bare minimum simple forward euler simulation.\n         */\n\n        for(let i=0;i<this.particles.length;i++){\n            let p =this.particles[i];\n            p.position=p.position.plus(\n                p.velocity.times(\n                  3*timePassed\n                )\n            );\n\n            p.update(t, timePassed);\n        }\n\n        /**\n         * This is important! You need to signal that the particles have been updated to trigger re-rendering of the view!\n         */\n        this.signalParticlesUpdated();\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}