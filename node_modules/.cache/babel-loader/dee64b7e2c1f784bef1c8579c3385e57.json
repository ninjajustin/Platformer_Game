{"ast":null,"code":"const e = Symbol(),\n  t = Symbol(),\n  r = Symbol(),\n  n = Object.getPrototypeOf,\n  o = new WeakMap(),\n  s = e => e && (o.has(e) ? o.get(e) : n(e) === Object.prototype || n(e) === Array.prototype),\n  c = e => \"object\" == typeof e && null !== e,\n  i = (n, o) => {\n    let s = !1;\n    const c = (t, r, o) => {\n        if (!s) {\n          let s = t.a.get(n);\n          s || (s = new Set(), t.a.set(n, s)), o && s.has(e) || s.add(r);\n        }\n      },\n      i = {\n        f: o,\n        get(e, t) {\n          return t === r ? n : (c(this, t), a(e[t], this.a, this.c));\n        },\n        has(e, r) {\n          return r === t ? (s = !0, this.a.delete(n), !0) : (c(this, r), r in e);\n        },\n        getOwnPropertyDescriptor(e, t) {\n          return c(this, t, !0), Object.getOwnPropertyDescriptor(e, t);\n        },\n        ownKeys(t) {\n          return c(this, e), Reflect.ownKeys(t);\n        }\n      };\n    return o && (i.set = i.deleteProperty = () => !1), i;\n  },\n  a = (e, t, o) => {\n    if (!s(e)) return e;\n    const c = e[r] || e,\n      a = (e => Object.isFrozen(e) || Object.values(Object.getOwnPropertyDescriptors(e)).some(e => !e.writable))(c);\n    let l = o && o.get(c);\n    return l && l.f === a || (l = i(c, a), l.p = new Proxy(a ? (e => {\n      if (Array.isArray(e)) return Array.from(e);\n      const t = Object.getOwnPropertyDescriptors(e);\n      return Object.values(t).forEach(e => {\n        e.configurable = !0;\n      }), Object.create(n(e), t);\n    })(c) : c, l), o && o.set(c, l)), l.a = t, l.c = o, l.p;\n  },\n  l = (e, t) => {\n    const r = Reflect.ownKeys(e),\n      n = Reflect.ownKeys(t);\n    return r.length !== n.length || r.some((e, t) => e !== n[t]);\n  },\n  u = (t, r, n, o) => {\n    if (Object.is(t, r)) return !1;\n    if (!c(t) || !c(r)) return !0;\n    const s = n.get(t);\n    if (!s) return !0;\n    if (o) {\n      const e = o.get(t);\n      if (e && e.n === r) return e.g;\n      o.set(t, {\n        n: r,\n        g: !1\n      });\n    }\n    let i = null;\n    for (const c of s) {\n      const s = c === e ? l(t, r) : u(t[c], r[c], n, o);\n      if (!0 !== s && !1 !== s || (i = s), i) break;\n    }\n    return null === i && (i = !0), o && o.set(t, {\n      n: r,\n      g: i\n    }), i;\n  },\n  f = e => !!s(e) && t in e,\n  y = e => s(e) && e[r] || null,\n  p = function (e) {\n    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;\n    o.set(e, t);\n  },\n  g = (e, t) => {\n    const r = [],\n      n = new WeakSet(),\n      o = (e, s) => {\n        if (n.has(e)) return;\n        c(e) && n.add(e);\n        const i = t.get(e);\n        i ? i.forEach(t => {\n          o(e[t], s ? [...s, t] : [t]);\n        }) : s && r.push(s);\n      };\n    return o(e), r;\n  };\nexport { g as affectedToPathList, a as createProxy, y as getUntracked, u as isChanged, p as markToTrack, f as trackMemo };","map":null,"metadata":{},"sourceType":"module"}