{"ast":null,"code":"import _initializerDefineProperty from \"/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/node_modules/@babel/runtime/helpers/esm/initializerDefineProperty.js\";\nimport _applyDecoratedDescriptor from \"/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/node_modules/@babel/runtime/helpers/esm/applyDecoratedDescriptor.js\";\nimport _initializerWarningHelper from \"/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/node_modules/@babel/runtime/helpers/esm/initializerWarningHelper.js\";\nvar _dec, _class, _class2, _descriptor;\nimport { AObject, AObjectState } from \"./AObject\";\nimport { ASerializable } from \"../aserial\";\nimport { ref } from \"valtio\";\nexport let AObjectNodeEvents;\n(function (AObjectNodeEvents) {\n  AObjectNodeEvents[\"NewParent\"] = \"NewParent\";\n  AObjectNodeEvents[\"NewRoot\"] = \"NewRoot\";\n  AObjectNodeEvents[\"NewChild\"] = \"NewChild\";\n  AObjectNodeEvents[\"NewDescendant\"] = \"NewDescendant\";\n  AObjectNodeEvents[\"ChildRemoved\"] = \"ChildRemoved\";\n  AObjectNodeEvents[\"DescendantRemoved\"] = \"DescendantRemoved\";\n})(AObjectNodeEvents || (AObjectNodeEvents = {}));\nexport let AObjectNode = (_dec = ASerializable(\"AObjectNode\"), _dec(_class = (_class2 = class AObjectNode extends AObject {\n  get children() {\n    return this._children;\n  }\n  get root() {\n    return this._root;\n  }\n  set root(node) {\n    if (this._root.uid === node.uid) {\n      return;\n    } else {\n      this._root = node;\n      this.signalEvent(AObjectNodeEvents.NewRoot);\n\n      // set all the children nodes' roots, which will cause them to set their children nodes' root...\n      this.mapOverChildren(child => {\n        child.root = node;\n      });\n    }\n  }\n  _setRootSilent(node) {\n    if (this._root.uid === node.uid) {\n      return;\n    } else {\n      this._root = node;\n      // set all the children nodes' roots, which will cause them to set their children nodes' root...\n      this.mapOverChildren(child => {\n        child._setRootSilent(node);\n      });\n    }\n  }\n  constructor() {\n    var _this$_root, _this$_parent;\n    super();\n    // @ts-ignore\n    _initializerDefineProperty(this, \"_children\", _descriptor, this);\n    this._parent = void 0;\n    this._root = void 0;\n    this._children = this.children === undefined ? [] : this.children;\n    this._root = (_this$_root = this._root) !== null && _this$_root !== void 0 ? _this$_root : (_this$_parent = this._parent) !== null && _this$_parent !== void 0 ? _this$_parent : this;\n    // @ts-ignore\n    this._parent = this._parent === undefined ? null : this._parent;\n  }\n  addNewParentListener(callback, handle) {\n    let synchronous = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return this.addEventListener(AObjectNodeEvents.NewParent, callback, handle);\n  }\n  signalNewParent(newParent, oldParent) {\n    this.signalEvent(AObjectNodeEvents.NewParent, newParent, oldParent);\n  }\n\n  /**\n   * Signals new parent on child\n   * which signals new root on descendants\n   * new child on this node\n   * @param child\n   * @param position\n   * @param signalEvent\n   */\n  _addChild(child, position) {\n    let signalAncestorEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    let signalDescendantEvents = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (this.children.includes(child)) {\n      throw new Error(`Tried to add existing child ${child} to node ${this}`);\n    }\n    if (child.parent) {\n      throw new Error(`Child ${child} already has parent ${child.parent} when trying to add as child of ${this}`);\n    } else {\n      if (signalDescendantEvents) {\n        let oldParent = child._parent;\n        let newParent = this;\n        child._parent = newParent;\n        if (newParent !== oldParent) {\n          child.signalEvent(AObjectNodeEvents.NewParent, newParent, oldParent);\n          child.root = this.root;\n        }\n      } else {\n        child._parent = this;\n        child._setRootSilent(this.root);\n      }\n    }\n    if (position !== undefined) {\n      this.children.splice(position, 0, ref(child));\n    } else {\n      this.children.push(ref(child));\n    }\n    if (signalAncestorEvents) {\n      this.signalEvent(AObjectNodeEvents.NewChild, child);\n      child.mapOverAncestors(ancestor => {\n        ancestor.signalEvent(AObjectNodeEvents.NewDescendant, child);\n      });\n    }\n  }\n  addChild(child, position) {\n    return this._addChild(child, position, true, true);\n  }\n  get parent() {\n    return this._parent;\n  }\n  mapOverChildren(fn) {\n    var rvals = [];\n    for (let child of this.children) {\n      rvals.push(fn(child));\n    }\n    return rvals;\n  }\n  mapOverAncestors(fn) {\n    var rvals = [];\n    let parent = this.parent;\n    let lastParent = this;\n    while (parent && parent !== lastParent) {\n      rvals.push(fn(parent));\n      lastParent = parent;\n      parent = parent.parent;\n    }\n    return rvals;\n  }\n  getAncestorList() {\n    var rvals = [];\n    let parent = this.parent;\n    let lastParent = this;\n    while (parent && parent !== lastParent) {\n      rvals.push(parent);\n      lastParent = parent;\n      parent = parent.parent;\n    }\n    return rvals;\n  }\n  getDescendantList() {\n    const rval = [];\n    this.mapOverChildren(c => {\n      rval.push(c);\n      for (let cc of c.getDescendantList()) {\n        rval.push(cc);\n      }\n      ;\n    });\n    return rval;\n  }\n  filterChildren(fn) {\n    return this.children.filter(fn);\n  }\n  filterDescendants(fn) {\n    return this.getDescendantList().filter(fn);\n  }\n  mapOverDescendants(fn) {\n    return this.getDescendantList().map(fn);\n  }\n  release() {\n    this.releaseChildren(...arguments);\n    if (this._parent !== null) {\n      this._parent._removeChild(this);\n    }\n    //would do super.release(args) here...\n  }\n\n  /**\n   * A potentially silent version of removeChild\n   * Signals new parent on the child\n   * child removed on this node\n   * descendant removed on ancestors\n   * and new root on descendants\n   * @param child\n   * @param signalNewParentEvent\n   * @private\n   */\n  _removeChild(child) {\n    let signalAncestorEvents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let signalDescendantEvents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    for (let c = 0; c < this.children.length; c++) {\n      if (this.children[c].uid === child.uid) {\n        this.children.splice(c, 1);\n        child._parent = null;\n        if (signalDescendantEvents) {\n          child.signalEvent(AObjectNodeEvents.NewParent, child, null);\n          child.root = child;\n        } else {\n          child._setRootSilent(child);\n        }\n        if (signalAncestorEvents) {\n          this.signalEvent(AObjectNodeEvents.ChildRemoved, child);\n          this.mapOverAncestors(ancestor => {\n            ancestor.signalEvent(AObjectNodeEvents.DescendantRemoved, child);\n          });\n        }\n        return;\n      }\n    }\n    throw new Error(`Tried to remove node ${child} that is not a child of ${this}`);\n  }\n  removeChild(child) {\n    return this._removeChild(child, true, true);\n  }\n\n  /**\n   * Release all children\n   * @param args\n   * @returns {any[]}\n   */\n  releaseChildren() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return this.mapOverChildren(child => {\n      return child.release(...args);\n    });\n  }\n\n  /**\n   * Remove all children without necessarily releasing them\n   * @returns {any[]}\n   */\n  removeChildren() {\n    const self = this;\n    return this.mapOverChildren(child => {\n      self.removeChild(child);\n    });\n  }\n  static fromJSON(state_dict) {\n    const rval = this.CreateWithState(state_dict);\n    rval.mapOverChildren(c => {\n      c._parent = rval;\n    });\n    return rval;\n  }\n  toJSON() {\n    return this.state;\n  }\n\n  //##################//--Reparenting--\\\\##################\n  //<editor-fold desc=\"Reparenting\">\n\n  getChildWithID(uid) {\n    for (let c = 0; c < this.children.length; c++) {\n      if (this.children[c].uid === uid) {\n        return this.children[c];\n      }\n    }\n  }\n  _uidsToChildrenList(uidList) {\n    let aon_array = [];\n    for (let uid of uidList) {\n      let child = this.getChildWithID(uid);\n      if (child) {\n        aon_array.push(child);\n      } else {\n        throw new Error(`unrecognized child uid: ${uid}`);\n      }\n    }\n    return aon_array;\n  }\n  _childrenListToUIDs(childrenList) {\n    let rval = [];\n    for (let c of childrenList) {\n      rval.push(c.uid);\n    }\n    return rval;\n  }\n  reorderChildren(uidList) {\n    for (let uid of uidList) {\n      let child = this.getChildWithID(uid);\n      if (child) {\n        child.reparent(this, false);\n      } else {\n        throw new Error(\"Tried to reorder children with uid that does not belong to parent.\");\n      }\n    }\n  }\n  reparent(newParent) {\n    let signalEvents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (this.parent) {\n      this.parent._removeChild(this, signalEvents, signalEvents);\n    }\n    newParent._addChild(this, undefined, signalEvents, signalEvents);\n  }\n  //</editor-fold>\n  //##################\\\\--Reparenting--//##################\n}, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, \"_children\", [AObjectState], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class2)) || _class);","map":{"version":3,"names":["AObject","AObjectState","ASerializable","ref","AObjectNodeEvents","AObjectNode","children","_children","root","_root","node","uid","signalEvent","NewRoot","mapOverChildren","child","_setRootSilent","constructor","_parent","undefined","addNewParentListener","callback","handle","synchronous","addEventListener","NewParent","signalNewParent","newParent","oldParent","_addChild","position","signalAncestorEvents","signalDescendantEvents","includes","Error","parent","splice","push","NewChild","mapOverAncestors","ancestor","NewDescendant","addChild","fn","rvals","lastParent","getAncestorList","getDescendantList","rval","c","cc","filterChildren","filter","filterDescendants","mapOverDescendants","map","release","releaseChildren","_removeChild","length","ChildRemoved","DescendantRemoved","removeChild","args","removeChildren","self","fromJSON","state_dict","CreateWithState","toJSON","state","getChildWithID","_uidsToChildrenList","uidList","aon_array","_childrenListToUIDs","childrenList","reorderChildren","reparent","signalEvents"],"sources":["/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/src/anigraph/base/aobject/AObjectNode.ts"],"sourcesContent":["import {AObject, AObjectState} from \"./AObject\";\nimport {ASerializable} from \"../aserial\";\nimport {ref} from \"valtio\";\n\nexport enum AObjectNodeEvents{\n    // Descendant Events\n    NewParent = 'NewParent',\n    NewRoot = 'NewRoot',\n\n    //Ancestor Events\n    NewChild = 'NewChild',\n    NewDescendant = 'NewDescendant',\n    ChildRemoved = 'ChildRemoved',\n    DescendantRemoved = 'DescendantRemoved'\n}\n\n@ASerializable(\"AObjectNode\")\nexport class AObjectNode extends AObject{\n    @AObjectState public _children:AObjectNode[];\n    get children(){\n        return this._children;\n    }\n\n    protected _parent!:AObjectNode|null;\n    protected _root!:AObjectNode;\n\n    get root(){\n        return this._root;\n    }\n    set root(node:AObjectNode){\n        if(this._root.uid===node.uid){\n            return;\n        }else{\n            this._root = node;\n            this.signalEvent(AObjectNodeEvents.NewRoot);\n\n            // set all the children nodes' roots, which will cause them to set their children nodes' root...\n            this.mapOverChildren((child:AObjectNode)=>{\n                child.root = node;\n            })\n        }\n    }\n\n    protected _setRootSilent(node:AObjectNode){\n        if(this._root.uid===node.uid){\n            return;\n        }else{\n            this._root = node;\n            // set all the children nodes' roots, which will cause them to set their children nodes' root...\n            this.mapOverChildren((child:AObjectNode)=>{\n                child._setRootSilent(node);\n            })\n        }\n    }\n\n\n    constructor(){\n        super();\n        // @ts-ignore\n        this._children = (this.children===undefined)?[]:this.children;\n        this._root = this._root??(this._parent??this);\n        // @ts-ignore\n        this._parent = (this._parent===undefined)?null:this._parent;\n\n\n    }\n\n    addNewParentListener(callback:(newParent?:AObjectNode, oldParent?:AObjectNode)=>void, handle?:string, synchronous:boolean=true){\n        return this.addEventListener(AObjectNodeEvents.NewParent, callback, handle);\n    }\n\n    signalNewParent(newParent?:AObjectNode, oldParent?:AObjectNode){\n        this.signalEvent(AObjectNodeEvents.NewParent, newParent, oldParent);\n    }\n\n    /**\n     * Signals new parent on child\n     * which signals new root on descendants\n     * new child on this node\n     * @param child\n     * @param position\n     * @param signalEvent\n     */\n    _addChild(child:AObjectNode, position?:number, signalAncestorEvents:boolean=true, signalDescendantEvents:boolean=true){\n        if(this.children.includes(child)){\n            throw new Error(`Tried to add existing child ${child} to node ${this}`);\n        }\n        if(child.parent){\n            throw new Error(`Child ${child} already has parent ${child.parent} when trying to add as child of ${this}`);\n        }else{\n            if(signalDescendantEvents) {\n                let oldParent = child._parent;\n                let newParent = this;\n                child._parent=newParent;\n                if(newParent!==oldParent){\n                    child.signalEvent(AObjectNodeEvents.NewParent, newParent, oldParent);\n                    child.root = this.root;\n                }\n            }else{\n                child._parent = this;\n                child._setRootSilent(this.root);\n            }\n        }\n        if(position!==undefined){\n            this.children.splice(position, 0, ref(child));\n        }else{\n            this.children.push(ref(child));\n        }\n        if(signalAncestorEvents) {\n            this.signalEvent(AObjectNodeEvents.NewChild, child);\n            child.mapOverAncestors((ancestor:AObjectNode)=>{\n                ancestor.signalEvent(AObjectNodeEvents.NewDescendant, child);\n            })\n        }\n    }\n\n    addChild(child:AObjectNode, position?:number){\n        return this._addChild(child, position, true, true);\n    }\n\n    public get parent():AObjectNode|null{\n        return this._parent;\n    };\n\n    mapOverChildren(fn:(child:AObjectNode)=>any[]|void){\n        var rvals = [];\n        for(let child of this.children){\n            rvals.push(fn(child));\n        }\n        return rvals;\n    }\n\n    mapOverAncestors(fn:(ancestor:AObjectNode)=>any[]|void){\n        var rvals = [];\n        let parent = this.parent;\n        let lastParent = (this as AObjectNode);\n        while(parent && (parent!==lastParent)){\n            rvals.push(fn(parent));\n            lastParent = parent;\n            parent = parent.parent;\n        }\n        return rvals;\n    }\n\n    getAncestorList(){\n        var rvals = [];\n        let parent = this.parent;\n        let lastParent = (this as AObjectNode);\n        while(parent && (parent!==lastParent)){\n            rvals.push(parent);\n            lastParent = parent;\n            parent = parent.parent;\n        }\n        return rvals;\n    }\n\n    getDescendantList(){\n        const rval:AObjectNode[] = [];\n        this.mapOverChildren((c:AObjectNode)=>{\n            rval.push(c);\n            for(let cc of c.getDescendantList()){\n                rval.push(cc);\n            };\n        })\n        return rval;\n    }\n\n    filterChildren(fn:(child:AObjectNode, index?:number, array?:AObjectNode[])=>boolean){\n        return this.children.filter(fn);\n    }\n\n    filterDescendants(fn:(child:AObjectNode, index?:number, array?:AObjectNode[])=>boolean){\n        return this.getDescendantList().filter(fn);\n    }\n\n    mapOverDescendants(fn:(descendant:AObjectNode)=>any[]|void){\n        return this.getDescendantList().map(fn);\n    }\n\n    release(...args:any[]){\n        this.releaseChildren(...args)\n        if(this._parent!==null){\n            this._parent._removeChild(this);\n        }\n        //would do super.release(args) here...\n    }\n\n    /**\n     * A potentially silent version of removeChild\n     * Signals new parent on the child\n     * child removed on this node\n     * descendant removed on ancestors\n     * and new root on descendants\n     * @param child\n     * @param signalNewParentEvent\n     * @private\n     */\n    _removeChild(child:AObjectNode, signalAncestorEvents:boolean=true, signalDescendantEvents:boolean=true){\n        for(let c=0;c<this.children.length;c++){\n            if(this.children[c].uid===child.uid){\n                this.children.splice(c,1);\n                child._parent = null;\n                if(signalDescendantEvents){\n                    child.signalEvent(AObjectNodeEvents.NewParent, child, null);\n                    child.root = child;\n                }else{\n                    child._setRootSilent(child);\n                }\n                if(signalAncestorEvents) {\n                    this.signalEvent(AObjectNodeEvents.ChildRemoved, child);\n                    this.mapOverAncestors((ancestor: AObjectNode) => {\n                        ancestor.signalEvent(AObjectNodeEvents.DescendantRemoved, child);\n                    })\n                }\n                return;\n            }\n        }\n        throw new Error(`Tried to remove node ${child} that is not a child of ${this}`);\n    }\n\n    removeChild(child:AObjectNode){\n        return this._removeChild(child, true, true);\n    }\n\n    /**\n     * Release all children\n     * @param args\n     * @returns {any[]}\n     */\n    releaseChildren(...args:any[]){\n        return this.mapOverChildren((child:AObjectNode)=>{return child.release(...args);});\n    }\n\n    /**\n     * Remove all children without necessarily releasing them\n     * @returns {any[]}\n     */\n    removeChildren(){\n        const self = this;\n        return this.mapOverChildren((child:AObjectNode)=>{self.removeChild(child);});\n    }\n\n\n    static fromJSON(state_dict:{[name:string]:any}){\n        const rval = (this.CreateWithState(state_dict) as AObjectNode);\n        rval.mapOverChildren((c:AObjectNode)=>{\n                c._parent = rval;\n            }\n        );\n        return rval;\n    }\n    toJSON(){\n        return this.state;\n    }\n\n\n    //##################//--Reparenting--\\\\##################\n    //<editor-fold desc=\"Reparenting\">\n\n    getChildWithID(uid:string){\n        for(let c=0;c<this.children.length;c++){\n            if(this.children[c].uid===uid){\n                return this.children[c];\n            }\n        }\n    }\n\n    _uidsToChildrenList(uidList:string[]){\n        let aon_array:AObjectNode[] = [];\n        for(let uid of uidList){\n            let child = this.getChildWithID(uid);\n            if(child) {\n                aon_array.push(child);\n            }else{\n                throw new Error(`unrecognized child uid: ${uid}`);\n            }\n        }\n        return aon_array;\n    }\n\n    _childrenListToUIDs(childrenList:AObjectNode[]){\n        let rval:string[]= [];\n        for(let c of childrenList){\n            rval.push(c.uid);\n        }\n        return rval;\n    }\n\n    reorderChildren(uidList:string[]){\n        for(let uid of uidList){\n            let child = this.getChildWithID(uid);\n            if(child){\n                child.reparent(this, false);\n            }else{\n                throw new Error (\"Tried to reorder children with uid that does not belong to parent.\")\n            }\n        }\n    }\n\n    reparent(newParent:AObjectNode, signalEvents:boolean=true){\n        if(this.parent){\n            this.parent._removeChild(this, signalEvents, signalEvents);\n        }\n        newParent._addChild(this, undefined, signalEvents, signalEvents);\n    }\n    //</editor-fold>\n    //##################\\\\--Reparenting--//##################\n\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}