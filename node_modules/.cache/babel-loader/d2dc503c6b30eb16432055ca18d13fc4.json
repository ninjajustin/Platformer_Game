{"ast":null,"code":"var Rule = function Rule(name, fn, args, modifiers) {\n  this.name = name;\n  this.fn = fn;\n  this.args = args;\n  this.modifiers = modifiers;\n};\nRule.prototype._test = function _test(value) {\n  var fn = this.fn;\n  try {\n    testAux(this.modifiers.slice(), fn, this)(value);\n  } catch (ex) {\n    fn = function () {\n      return false;\n    };\n  }\n  try {\n    return testAux(this.modifiers.slice(), fn, this)(value);\n  } catch (ex$1) {\n    return false;\n  }\n};\nRule.prototype._check = function _check(value) {\n  try {\n    testAux(this.modifiers.slice(), this.fn, this)(value);\n  } catch (ex) {\n    if (testAux(this.modifiers.slice(), function (it) {\n      return it;\n    }, this)(false)) {\n      return;\n    }\n  }\n  if (!testAux(this.modifiers.slice(), this.fn, this)(value)) {\n    throw null;\n  }\n};\nRule.prototype._testAsync = function _testAsync(value) {\n  var this$1 = this;\n  return new Promise(function (resolve, reject) {\n    testAsyncAux(this$1.modifiers.slice(), this$1.fn, this$1)(value).then(function (valid) {\n      if (valid) {\n        resolve(value);\n      } else {\n        reject(null);\n      }\n    }).catch(function (ex) {\n      return reject(ex);\n    });\n  });\n};\nfunction pickFn(fn, variant) {\n  if (variant === void 0) variant = 'simple';\n  return typeof fn === 'object' ? fn[variant] : fn;\n}\nfunction testAux(modifiers, fn, rule) {\n  if (modifiers.length) {\n    var modifier = modifiers.shift();\n    var nextFn = testAux(modifiers, fn, rule);\n    return modifier.perform(nextFn, rule);\n  } else {\n    return pickFn(fn);\n  }\n}\nfunction testAsyncAux(modifiers, fn, rule) {\n  if (modifiers.length) {\n    var modifier = modifiers.shift();\n    var nextFn = testAsyncAux(modifiers, fn, rule);\n    return modifier.performAsync(nextFn, rule);\n  } else {\n    return function (value) {\n      return Promise.resolve(pickFn(fn, 'async')(value));\n    };\n  }\n}\nvar Modifier = function Modifier(name, perform, performAsync) {\n  this.name = name;\n  this.perform = perform;\n  this.performAsync = performAsync;\n};\nvar ValidationError = /*@__PURE__*/function (Error) {\n  function ValidationError(rule, value, cause, target) {\n    var remaining = [],\n      len = arguments.length - 4;\n    while (len-- > 0) remaining[len] = arguments[len + 4];\n    Error.call(this, remaining);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ValidationError);\n    }\n    this.rule = rule;\n    this.value = value;\n    this.cause = cause;\n    this.target = target;\n  }\n  if (Error) ValidationError.__proto__ = Error;\n  ValidationError.prototype = Object.create(Error && Error.prototype);\n  ValidationError.prototype.constructor = ValidationError;\n  return ValidationError;\n}(Error);\nvar Context = function Context(chain, nextRuleModifiers) {\n  if (chain === void 0) chain = [];\n  if (nextRuleModifiers === void 0) nextRuleModifiers = [];\n  this.chain = chain;\n  this.nextRuleModifiers = nextRuleModifiers;\n};\nContext.prototype._applyRule = function _applyRule(ruleFn, name) {\n  var this$1 = this;\n  return function () {\n    var args = [],\n      len = arguments.length;\n    while (len--) args[len] = arguments[len];\n    this$1.chain.push(new Rule(name, ruleFn.apply(this$1, args), args, this$1.nextRuleModifiers));\n    this$1.nextRuleModifiers = [];\n    return this$1;\n  };\n};\nContext.prototype._applyModifier = function _applyModifier(modifier, name) {\n  this.nextRuleModifiers.push(new Modifier(name, modifier.simple, modifier.async));\n  return this;\n};\nContext.prototype._clone = function _clone() {\n  return new Context(this.chain.slice(), this.nextRuleModifiers.slice());\n};\nContext.prototype.test = function test(value) {\n  return this.chain.every(function (rule) {\n    return rule._test(value);\n  });\n};\nContext.prototype.testAll = function testAll(value) {\n  var err = [];\n  this.chain.forEach(function (rule) {\n    try {\n      rule._check(value);\n    } catch (ex) {\n      err.push(new ValidationError(rule, value, ex));\n    }\n  });\n  return err;\n};\nContext.prototype.check = function check(value) {\n  this.chain.forEach(function (rule) {\n    try {\n      rule._check(value);\n    } catch (ex) {\n      throw new ValidationError(rule, value, ex);\n    }\n  });\n};\nContext.prototype.testAsync = function testAsync(value) {\n  var this$1 = this;\n  return new Promise(function (resolve, reject) {\n    executeAsyncRules(value, this$1.chain.slice(), resolve, reject);\n  });\n};\nfunction executeAsyncRules(value, rules, resolve, reject) {\n  if (rules.length) {\n    var rule = rules.shift();\n    rule._testAsync(value).then(function () {\n      executeAsyncRules(value, rules, resolve, reject);\n    }, function (cause) {\n      reject(new ValidationError(rule, value, cause));\n    });\n  } else {\n    resolve(value);\n  }\n}\nvar consideredEmpty = function (value, considerTrimmedEmptyString) {\n  if (considerTrimmedEmptyString && typeof value === 'string' && value.trim().length === 0) {\n    return true;\n  }\n  return value === undefined || value === null;\n};\nfunction optional(validation, considerTrimmedEmptyString) {\n  if (considerTrimmedEmptyString === void 0) considerTrimmedEmptyString = false;\n  return {\n    simple: function (value) {\n      return consideredEmpty(value, considerTrimmedEmptyString) || validation.check(value) === undefined;\n    },\n    async: function (value) {\n      return consideredEmpty(value, considerTrimmedEmptyString) || validation.testAsync(value);\n    }\n  };\n}\nfunction v8n() {\n  return typeof Proxy !== 'undefined' ? proxyContext(new Context()) : proxylessContext(new Context());\n}\n\n// Custom rules\nvar customRules = {};\nv8n.extend = function (newRules) {\n  Object.assign(customRules, newRules);\n};\nv8n.clearCustomRules = function () {\n  customRules = {};\n};\nfunction proxyContext(context) {\n  return new Proxy(context, {\n    get: function get(obj, prop) {\n      if (prop in obj) {\n        return obj[prop];\n      }\n      var newContext = proxyContext(context._clone());\n      if (prop in availableModifiers) {\n        return newContext._applyModifier(availableModifiers[prop], prop);\n      }\n      if (prop in customRules) {\n        return newContext._applyRule(customRules[prop], prop);\n      }\n      if (prop in availableRules) {\n        return newContext._applyRule(availableRules[prop], prop);\n      }\n    }\n  });\n}\nfunction proxylessContext(context) {\n  var addRuleSet = function (ruleSet, targetContext) {\n    Object.keys(ruleSet).forEach(function (prop) {\n      targetContext[prop] = function () {\n        var args = [],\n          len = arguments.length;\n        while (len--) args[len] = arguments[len];\n        var newContext = proxylessContext(targetContext._clone());\n        var contextWithRuleApplied = newContext._applyRule(ruleSet[prop], prop).apply(void 0, args);\n        return contextWithRuleApplied;\n      };\n    });\n    return targetContext;\n  };\n  var contextWithAvailableRules = addRuleSet(availableRules, context);\n  var contextWithAllRules = addRuleSet(customRules, contextWithAvailableRules);\n  Object.keys(availableModifiers).forEach(function (prop) {\n    Object.defineProperty(contextWithAllRules, prop, {\n      get: function () {\n        var newContext = proxylessContext(contextWithAllRules._clone());\n        return newContext._applyModifier(availableModifiers[prop], prop);\n      }\n    });\n  });\n  return contextWithAllRules;\n}\nvar availableModifiers = {\n  not: {\n    simple: function (fn) {\n      return function (value) {\n        return !fn(value);\n      };\n    },\n    async: function (fn) {\n      return function (value) {\n        return Promise.resolve(fn(value)).then(function (result) {\n          return !result;\n        }).catch(function () {\n          return true;\n        });\n      };\n    }\n  },\n  some: {\n    simple: function (fn) {\n      return function (value) {\n        return split(value).some(function (item) {\n          try {\n            return fn(item);\n          } catch (ex) {\n            return false;\n          }\n        });\n      };\n    },\n    async: function (fn) {\n      return function (value) {\n        return Promise.all(split(value).map(function (item) {\n          try {\n            return fn(item).catch(function () {\n              return false;\n            });\n          } catch (ex) {\n            return false;\n          }\n        })).then(function (result) {\n          return result.some(Boolean);\n        });\n      };\n    }\n  },\n  every: {\n    simple: function (fn) {\n      return function (value) {\n        return value !== false && split(value).every(fn);\n      };\n    },\n    async: function (fn) {\n      return function (value) {\n        return Promise.all(split(value).map(fn)).then(function (result) {\n          return result.every(Boolean);\n        });\n      };\n    }\n  },\n  strict: {\n    simple: function (fn, rule) {\n      return function (value) {\n        if (isSchemaRule(rule) && value && typeof value === 'object') {\n          return Object.keys(rule.args[0]).length === Object.keys(value).length && fn(value);\n        }\n        return fn(value);\n      };\n    },\n    async: function (fn, rule) {\n      return function (value) {\n        return Promise.resolve(fn(value)).then(function (result) {\n          if (isSchemaRule(rule) && value && typeof value === 'object') {\n            return Object.keys(rule.args[0]).length === Object.keys(value).length && result;\n          }\n          return result;\n        }).catch(function () {\n          return false;\n        });\n      };\n    }\n  }\n};\nfunction isSchemaRule(rule) {\n  return rule && rule.name === 'schema' && rule.args.length > 0 && typeof rule.args[0] === 'object';\n}\nfunction split(value) {\n  if (typeof value === 'string') {\n    return value.split('');\n  }\n  return value;\n}\nvar availableRules = {\n  // Value\n\n  equal: function (expected) {\n    return function (value) {\n      return value == expected;\n    };\n  },\n  exact: function (expected) {\n    return function (value) {\n      return value === expected;\n    };\n  },\n  // Types\n\n  number: function (allowInfinite) {\n    if (allowInfinite === void 0) allowInfinite = true;\n    return function (value) {\n      return typeof value === 'number' && (allowInfinite || isFinite(value));\n    };\n  },\n  integer: function () {\n    return function (value) {\n      var isInteger = Number.isInteger || isIntegerPolyfill;\n      return isInteger(value);\n    };\n  },\n  numeric: function () {\n    return function (value) {\n      return !isNaN(parseFloat(value)) && isFinite(value);\n    };\n  },\n  string: function () {\n    return testType('string');\n  },\n  boolean: function () {\n    return testType('boolean');\n  },\n  undefined: function () {\n    return testType('undefined');\n  },\n  null: function () {\n    return testType('null');\n  },\n  array: function () {\n    return testType('array');\n  },\n  object: function () {\n    return testType('object');\n  },\n  instanceOf: function (instance) {\n    return function (value) {\n      return value instanceof instance;\n    };\n  },\n  // Pattern\n\n  pattern: function (expected) {\n    return function (value) {\n      return expected.test(value);\n    };\n  },\n  lowercase: function () {\n    return function (value) {\n      return typeof value === 'boolean' || value === value.toLowerCase() && value.trim() !== '';\n    };\n  },\n  uppercase: function () {\n    return function (value) {\n      return value === value.toUpperCase() && value.trim() !== '';\n    };\n  },\n  vowel: function () {\n    return function (value) {\n      return /^[aeiou]+$/i.test(value);\n    };\n  },\n  consonant: function () {\n    return function (value) {\n      return /^(?=[^aeiou])([a-z]+)$/i.test(value);\n    };\n  },\n  // Value at\n\n  first: function (expected) {\n    return function (value) {\n      return value[0] == expected;\n    };\n  },\n  last: function (expected) {\n    return function (value) {\n      return value[value.length - 1] == expected;\n    };\n  },\n  // Length\n\n  empty: function () {\n    return function (value) {\n      return value.length === 0;\n    };\n  },\n  length: function (min, max) {\n    return function (value) {\n      return value.length >= min && value.length <= (max || min);\n    };\n  },\n  minLength: function (min) {\n    return function (value) {\n      return value.length >= min;\n    };\n  },\n  maxLength: function (max) {\n    return function (value) {\n      return value.length <= max;\n    };\n  },\n  // Range\n\n  negative: function () {\n    return function (value) {\n      return value < 0;\n    };\n  },\n  positive: function () {\n    return function (value) {\n      return value >= 0;\n    };\n  },\n  between: function (a, b) {\n    return function (value) {\n      return value >= a && value <= b;\n    };\n  },\n  range: function (a, b) {\n    return function (value) {\n      return value >= a && value <= b;\n    };\n  },\n  lessThan: function (n) {\n    return function (value) {\n      return value < n;\n    };\n  },\n  lessThanOrEqual: function (n) {\n    return function (value) {\n      return value <= n;\n    };\n  },\n  greaterThan: function (n) {\n    return function (value) {\n      return value > n;\n    };\n  },\n  greaterThanOrEqual: function (n) {\n    return function (value) {\n      return value >= n;\n    };\n  },\n  // Divisible\n\n  even: function () {\n    return function (value) {\n      return value % 2 === 0;\n    };\n  },\n  odd: function () {\n    return function (value) {\n      return value % 2 !== 0;\n    };\n  },\n  includes: function (expected) {\n    return function (value) {\n      return ~value.indexOf(expected);\n    };\n  },\n  schema: function (schema) {\n    return testSchema(schema);\n  },\n  // branching\n\n  passesAnyOf: function () {\n    var validations = [],\n      len = arguments.length;\n    while (len--) validations[len] = arguments[len];\n    return function (value) {\n      return validations.some(function (validation) {\n        return validation.test(value);\n      });\n    };\n  },\n  optional: optional\n};\nfunction testType(expected) {\n  return function (value) {\n    return Array.isArray(value) && expected === 'array' || value === null && expected === 'null' || typeof value === expected;\n  };\n}\nfunction isIntegerPolyfill(value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n}\nfunction testSchema(schema) {\n  return {\n    simple: function (value) {\n      var causes = [];\n      Object.keys(schema).forEach(function (key) {\n        var nestedValidation = schema[key];\n        try {\n          nestedValidation.check((value || {})[key]);\n        } catch (ex) {\n          ex.target = key;\n          causes.push(ex);\n        }\n      });\n      if (causes.length > 0) {\n        throw causes;\n      }\n      return true;\n    },\n    async: function (value) {\n      var causes = [];\n      var nested = Object.keys(schema).map(function (key) {\n        var nestedValidation = schema[key];\n        return nestedValidation.testAsync((value || {})[key]).catch(function (ex) {\n          ex.target = key;\n          causes.push(ex);\n        });\n      });\n      return Promise.all(nested).then(function () {\n        if (causes.length > 0) {\n          throw causes;\n        }\n        return true;\n      });\n    }\n  };\n}\nexport default v8n;","map":null,"metadata":{},"sourceType":"module"}