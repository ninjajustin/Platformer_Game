{"ast":null,"code":"var _dec, _class;\nimport { AGraphicElement } from \"../graphicobject\";\nimport { VertexArray2D } from \"../../geometry\";\nimport { LineSegmentsGeometry } from \"three/examples/jsm/lines/LineSegmentsGeometry\";\nimport * as THREE from \"three\";\nimport { ASerializable } from \"../../base\";\nimport { LineGeometry } from \"three/examples/jsm/lines/LineGeometry\";\nimport { Line2 } from \"three/examples/jsm/lines/Line2\";\nexport let ALineSegmentsGraphic = (_dec = ASerializable(\"ALineSegmentsGraphic\"), _dec(_class = class ALineSegmentsGraphic extends AGraphicElement {\n  get geometry() {\n    return this._geometry;\n  }\n\n  // get color() {\n  //     return this.material.color;\n  // }\n\n  // setColor(color: Color) {\n  //     this.material.color = color.asThreeJS();\n  // }\n\n  // getColor() {\n  //     return Color.FromThreeJS(this.color);\n  // }\n\n  get lineWidth() {\n    return this.material.linewidth;\n  }\n  setLineWidth(lineWidth) {\n    this.material.linewidth = lineWidth;\n  }\n  onMaterialUpdate(newMaterial) {\n    super.onMaterialUpdate(newMaterial);\n  }\n  onMaterialChange(newMaterial) {\n    super.onMaterialUpdate(newMaterial);\n  }\n  get threejs() {\n    return this._element;\n  }\n  get material() {\n    return this._material;\n  }\n  static Create(verts, material, lineWidth) {\n    // let newElement = new this(verts, material);\n    let newElement = new ALineSegmentsGraphic();\n    newElement.init(verts, material);\n    if (lineWidth !== undefined) {\n      newElement.setLineWidth(lineWidth);\n    }\n    return newElement;\n  }\n\n  // With Line Segment Geometry\n  _createLineGeometry() {\n    this._geometry = new LineSegmentsGeometry();\n    // this._geometry = new LineGeometry();\n  }\n\n  // _createLineGeometry(){\n  //     this._geometry = new THREE.BufferGeometry();\n  // }\n\n  init(geometry, material) {\n    if (this._element) {\n      throw new Error(`Tried to call init on GraphicElement that already has _element ${this._element}`);\n    }\n    this._initIfNotAlready(geometry, material);\n  }\n  _initIfNotAlready(geometry, material) {\n    if (geometry) {\n      if (geometry instanceof LineSegmentsGeometry || geometry instanceof LineGeometry) {\n        this._geometry = geometry;\n      } else {\n        // this._createLineGeometry();\n        this.setGeometry(geometry);\n      }\n    }\n    if (material) {\n      this.setMaterial(material);\n    }\n    if (this.material && this.geometry) {\n      // @ts-ignore\n      this._element = new Line2(this.geometry, this.material);\n      this._element.matrixAutoUpdate = false;\n    }\n  }\n  constructor() {\n    super();\n  }\n  setColors(rgba) {\n    let colors;\n    if (rgba instanceof Float32Array) {\n      colors = rgba;\n    } else {\n      colors = new Float32Array(rgba);\n    }\n    const instanceColorBuffer = new THREE.InstancedInterleavedBuffer(colors, 8, 1); // rgba, rgba\n    this.geometry.setAttribute('instanceColorStart', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 4, 0)); // rgba\n    this.geometry.setAttribute('instanceColorEnd', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 4, 4)); // rgba\n  }\n\n  setVerts2D(verts) {\n    let geometry = verts;\n    if (Array.isArray(verts)) {\n      // geometry = VertexArray2D.CreateLineSegments2D(verts);\n      throw new Error(\"Setting verts from array not implemented yet\");\n    }\n    if (this._geometry) {\n      this._geometry.dispose();\n    }\n    this._createLineGeometry();\n    if (geometry.nVerts > 0) {\n      this.geometry.setPositions(geometry.position.getElementsSlice());\n      if (geometry.color !== undefined && geometry.color.nVerts > 0) {\n        this.setColors(geometry.color.getElementsSlice());\n      }\n    }\n    if (this._element) {\n      this.element.geometry = this._geometry;\n    }\n  }\n\n  /**\n   * For some subclasses this will be different from setGeometry, because some subclasses will compute procedural\n   * geometry based on verts and then set the geometry to the output of that procedure\n   * @param verts\n   */\n  setVerts(verts) {\n    if (verts instanceof VertexArray2D && 'setVerts2D' in this) {\n      // @ts-ignore\n      this.setVerts2D(verts);\n    } else {\n      this.setGeometry(verts);\n    }\n  }\n}) || _class);","map":{"version":3,"names":["AGraphicElement","VertexArray2D","LineSegmentsGeometry","THREE","ASerializable","LineGeometry","Line2","ALineSegmentsGraphic","geometry","_geometry","lineWidth","material","linewidth","setLineWidth","onMaterialUpdate","newMaterial","onMaterialChange","threejs","_element","_material","Create","verts","newElement","init","undefined","_createLineGeometry","Error","_initIfNotAlready","setGeometry","setMaterial","matrixAutoUpdate","constructor","setColors","rgba","colors","Float32Array","instanceColorBuffer","InstancedInterleavedBuffer","setAttribute","InterleavedBufferAttribute","setVerts2D","Array","isArray","dispose","nVerts","setPositions","position","getElementsSlice","color","element","setVerts"],"sources":["/Users/home/Desktop/cs4620-final-project/src/anigraph/rendering/graphicelements/ALineSegmentsGraphic.ts"],"sourcesContent":["import {AGraphicElement} from \"../graphicobject\";\nimport {Color} from \"../../math\";\nimport {VertexArray, VertexArray2D} from \"../../geometry\";\nimport {LineSegmentsGeometry} from \"three/examples/jsm/lines/LineSegmentsGeometry\";\nimport {LineSegments2} from \"three/examples/jsm/lines/LineSegments2\";\nimport * as THREE from \"three\";\nimport {AMaterial, AThreeJSLineMaterial} from \"../material\";\nimport {ASerializable} from \"../../base\";\nimport {LineGeometry} from \"three/examples/jsm/lines/LineGeometry\";\nimport {Line2} from \"three/examples/jsm/lines/Line2\";\n\n@ASerializable(\"ALineSegmentsGraphic\")\nexport class ALineSegmentsGraphic extends AGraphicElement {\n    get geometry(): LineGeometry {\n        return this._geometry as LineGeometry;\n    }\n\n    // get color() {\n    //     return this.material.color;\n    // }\n\n    // setColor(color: Color) {\n    //     this.material.color = color.asThreeJS();\n    // }\n\n    // getColor() {\n    //     return Color.FromThreeJS(this.color);\n    // }\n\n    get lineWidth() {\n        return this.material.linewidth;\n    }\n\n    setLineWidth(lineWidth: number) {\n        this.material.linewidth = lineWidth;\n    }\n\n    onMaterialUpdate(newMaterial: AMaterial) {\n        super.onMaterialUpdate(newMaterial);\n    }\n\n    onMaterialChange(newMaterial: AMaterial) {\n        super.onMaterialUpdate(newMaterial);\n    }\n\n    get threejs(): LineSegments2 {\n        return this._element as LineSegments2;\n    }\n\n    get material(): AThreeJSLineMaterial {\n        return this._material as AThreeJSLineMaterial;\n    }\n\n    static Create(verts?: VertexArray<any>, material?: Color | THREE.Color | THREE.Material | THREE.Material[] | AMaterial, lineWidth?: number) {\n        // let newElement = new this(verts, material);\n        let newElement = new ALineSegmentsGraphic();\n        newElement.init(verts, material);\n        if (lineWidth !== undefined) {\n            newElement.setLineWidth(lineWidth);\n        }\n        return newElement;\n    }\n\n    // With Line Segment Geometry\n    _createLineGeometry() {\n        this._geometry = new LineSegmentsGeometry();\n        // this._geometry = new LineGeometry();\n    }\n\n    // _createLineGeometry(){\n    //     this._geometry = new THREE.BufferGeometry();\n    // }\n\n    init(geometry?: LineSegmentsGeometry | LineGeometry | VertexArray<any>, material?: Color | THREE.Color | THREE.Material | THREE.Material[] | AMaterial) {\n        if (this._element) {\n            throw new Error(`Tried to call init on GraphicElement that already has _element ${this._element}`);\n        }\n        this._initIfNotAlready(geometry, material);\n    }\n\n    _initIfNotAlready(geometry?: LineSegmentsGeometry | LineGeometry | VertexArray<any>, material?: Color | THREE.Color | THREE.Material | THREE.Material[] | AMaterial) {\n        if (geometry) {\n            if (geometry instanceof LineSegmentsGeometry || geometry instanceof LineGeometry) {\n                this._geometry = geometry;\n            } else {\n                // this._createLineGeometry();\n                this.setGeometry(geometry);\n            }\n        }\n        if (material) {\n            this.setMaterial(material);\n        }\n        if (this.material && this.geometry) {\n            // @ts-ignore\n            this._element = new Line2(this.geometry, this.material);\n            this._element.matrixAutoUpdate = false;\n        }\n    }\n\n    constructor() {\n        super();\n    }\n\n    setColors(rgba: number[] | Float32Array) {\n        let colors: Float32Array;\n        if (rgba instanceof Float32Array) {\n            colors = rgba;\n        } else {\n            colors = new Float32Array(rgba);\n        }\n        const instanceColorBuffer = new THREE.InstancedInterleavedBuffer(colors, 8, 1); // rgba, rgba\n        this.geometry.setAttribute('instanceColorStart', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 4, 0)); // rgba\n        this.geometry.setAttribute('instanceColorEnd', new THREE.InterleavedBufferAttribute(instanceColorBuffer, 4, 4)); // rgba\n    }\n\n    setVerts2D(verts: VertexArray<any> | number[]) {\n        let geometry = verts;\n        if (Array.isArray(verts)) {\n            // geometry = VertexArray2D.CreateLineSegments2D(verts);\n            throw new Error(\"Setting verts from array not implemented yet\")\n        }\n\n        if (this._geometry) {\n            this._geometry.dispose();\n        }\n        this._createLineGeometry();\n        if ((geometry as VertexArray<any>).nVerts > 0) {\n            this.geometry.setPositions((geometry as VertexArray<any>).position.getElementsSlice());\n            if((geometry as VertexArray<any>).color !== undefined && (geometry as VertexArray<any>).color.nVerts>0) {\n                this.setColors((geometry as VertexArray<any>).color.getElementsSlice());\n            }\n        }\n\n        if (this._element) {\n            this.element.geometry = this._geometry;\n        }\n    }\n\n    /**\n     * For some subclasses this will be different from setGeometry, because some subclasses will compute procedural\n     * geometry based on verts and then set the geometry to the output of that procedure\n     * @param verts\n     */\n    setVerts(verts: VertexArray<any>) {\n        if (verts instanceof VertexArray2D && 'setVerts2D' in this) {\n            // @ts-ignore\n            this.setVerts2D(verts);\n        } else {\n            this.setGeometry(verts);\n        }\n    }\n\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}