{"ast":null,"code":"var _dec, _class;\nimport { ATexture } from \"../../../../anigraph/rendering/ATexture\";\nimport { ASerializable, V3, VertexArray3D } from \"../../../../anigraph\";\nimport { CharacterModel } from \"../../../BaseClasses\";\nimport { TriangleMeshCharacterModel } from \"./TriangleMeshCharacterModel\";\nimport { AppConfigs } from \"../../../AppConfigs\";\nexport let BotModel = (_dec = ASerializable(\"BotModel\"), _dec(_class = class BotModel extends TriangleMeshCharacterModel {\n  /**\n   * Creates a new bot model to be textured with the provided diffuse texture map.\n   * @param diffuseMap\n   * @param size\n   * @param args\n   * @returns {Promise<BotModel>}\n   * @constructor\n   */\n  static async Create(diffuseMap, size) {\n    var _size;\n    size = (_size = size) !== null && _size !== void 0 ? _size : AppConfigs.DefaultBotSize;\n\n    /**\n     * Set the vertices to be a box. The Box3D helper function creates box geometry based on opposite corners,\n     * specifically the minimumum and maximum x,y,z coordinate values for an axis-aligned box\n     */\n    let verts = VertexArray3D.Box3D(V3(-0.5, -0.5, 0).times(size), V3(0.5, 0.5, 1.0).times(size));\n\n    /**\n     * Create the new bot model, initialize it with the provided diffuse map, and return it when that is done\n     * @type {BotModel}\n     */\n    let newmodel = new this(verts);\n    await newmodel.init(diffuseMap);\n    return newmodel;\n  }\n  async init(diffuseMap) {\n    /**\n     * The diffuseMap input can be an ATexture object or a path to a texture. If it is a path, then we load the\n     * corresponding texture into an ATexture object\n     * @type {ATexture}\n     */\n    let texture = diffuseMap instanceof ATexture ? diffuseMap : await ATexture.LoadAsync(diffuseMap);\n\n    /**\n     * Sets the material for our model to the corresponding AShaderMaterial instance, with the provided texture as\n     * the diffuse texture.\n     */\n    this.setMaterial(CharacterModel.ShaderModel.CreateMaterial(texture));\n  }\n}) || _class);","map":{"version":3,"names":["ATexture","ASerializable","V3","VertexArray3D","CharacterModel","TriangleMeshCharacterModel","AppConfigs","BotModel","Create","diffuseMap","size","DefaultBotSize","verts","Box3D","times","newmodel","init","texture","LoadAsync","setMaterial","ShaderModel","CreateMaterial"],"sources":["/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/src/app/main/Nodes/CharacterNodes/BotModel.ts"],"sourcesContent":["import {ATexture} from \"../../../../anigraph/rendering/ATexture\";\nimport {ASerializable, V3, VertexArray3D} from \"../../../../anigraph\";\nimport {CharacterModel} from \"../../../BaseClasses\";\nimport {TriangleMeshCharacterModel} from \"./TriangleMeshCharacterModel\";\nimport {AppConfigs} from \"../../../AppConfigs\";\n\n@ASerializable(\"BotModel\")\nexport class BotModel extends TriangleMeshCharacterModel {\n\n  /**\n   * Creates a new bot model to be textured with the provided diffuse texture map.\n   * @param diffuseMap\n   * @param size\n   * @param args\n   * @returns {Promise<BotModel>}\n   * @constructor\n   */\n  static async Create(diffuseMap: string | ATexture, size?: number, ...args: any[]) {\n    size = size ?? AppConfigs.DefaultBotSize;\n\n    /**\n     * Set the vertices to be a box. The Box3D helper function creates box geometry based on opposite corners,\n     * specifically the minimumum and maximum x,y,z coordinate values for an axis-aligned box\n     */\n    let verts = VertexArray3D.Box3D(\n      V3(-0.5, -0.5, 0).times(size),\n      V3(0.5, 0.5, 1.0).times(size)\n    );\n\n    /**\n     * Create the new bot model, initialize it with the provided diffuse map, and return it when that is done\n     * @type {BotModel}\n     */\n    let newmodel = new this(verts);\n    await newmodel.init(diffuseMap);\n    return newmodel;\n  }\n\n  async init(diffuseMap: string | ATexture, ...args: any[]) {\n    /**\n     * The diffuseMap input can be an ATexture object or a path to a texture. If it is a path, then we load the\n     * corresponding texture into an ATexture object\n     * @type {ATexture}\n     */\n    let texture = (diffuseMap instanceof ATexture) ? diffuseMap : await ATexture.LoadAsync(diffuseMap);\n\n    /**\n     * Sets the material for our model to the corresponding AShaderMaterial instance, with the provided texture as\n     * the diffuse texture.\n     */\n    this.setMaterial(CharacterModel.ShaderModel.CreateMaterial(\n      texture\n    ));\n  }\n\n}\n\n\n"],"mappings":";AAAA,SAAQA,QAAQ,QAAO,yCAAyC;AAChE,SAAQC,aAAa,EAAEC,EAAE,EAAEC,aAAa,QAAO,sBAAsB;AACrE,SAAQC,cAAc,QAAO,sBAAsB;AACnD,SAAQC,0BAA0B,QAAO,8BAA8B;AACvE,SAAQC,UAAU,QAAO,qBAAqB;AAE9C,WACaC,QAAQ,WADpBN,aAAa,CAAC,UAAU,CAAC,gBAA1B,MACaM,QAAQ,SAASF,0BAA0B,CAAC;EAEvD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,aAAaG,MAAM,CAACC,UAA6B,EAAEC,IAAa,EAAkB;IAAA;IAChFA,IAAI,YAAGA,IAAI,yCAAIJ,UAAU,CAACK,cAAc;;IAExC;AACJ;AACA;AACA;IACI,IAAIC,KAAK,GAAGT,aAAa,CAACU,KAAK,CAC7BX,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,GAAG,EAAE,CAAC,CAAC,CAACY,KAAK,CAACJ,IAAI,CAAC,EAC7BR,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAACY,KAAK,CAACJ,IAAI,CAAC,CAC9B;;IAED;AACJ;AACA;AACA;IACI,IAAIK,QAAQ,GAAG,IAAI,IAAI,CAACH,KAAK,CAAC;IAC9B,MAAMG,QAAQ,CAACC,IAAI,CAACP,UAAU,CAAC;IAC/B,OAAOM,QAAQ;EACjB;EAEA,MAAMC,IAAI,CAACP,UAA6B,EAAkB;IACxD;AACJ;AACA;AACA;AACA;IACI,IAAIQ,OAAO,GAAIR,UAAU,YAAYT,QAAQ,GAAIS,UAAU,GAAG,MAAMT,QAAQ,CAACkB,SAAS,CAACT,UAAU,CAAC;;IAElG;AACJ;AACA;AACA;IACI,IAAI,CAACU,WAAW,CAACf,cAAc,CAACgB,WAAW,CAACC,cAAc,CACxDJ,OAAO,CACR,CAAC;EACJ;AAEF,CAAC"},"metadata":{},"sourceType":"module"}