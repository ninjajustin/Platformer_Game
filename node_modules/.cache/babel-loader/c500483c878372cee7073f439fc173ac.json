{"ast":null,"code":"var _dec, _class;\nimport { ASerializable, NodeTransform3D, Vec3 } from \"../../../anigraph\";\nimport { MainAppInteractionMode } from \"../../BaseClasses/MainAppInteractionMode\";\nimport { AppConfigs } from \"../../AppConfigs\";\nexport let GameInteractionMode = (_dec = ASerializable(\"GameInteractionMode\"), _dec(_class = class GameInteractionMode extends MainAppInteractionMode {\n  get camera() {\n    return this.model.camera;\n  }\n  constructor(owner, name, interactionCallbacks) {\n    for (var _len = arguments.length, args = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      args[_key - 3] = arguments[_key];\n    }\n    super(name, owner, interactionCallbacks, ...args);\n    // this.reset();\n  }\n\n  get player() {\n    return this.model.player;\n  }\n  reset() {\n    // You can reset the control mode here\n    this.camera.pose = NodeTransform3D.LookAt(this.player.position.plus(Vec3.UnitZ().times(3)), this.player.position, Vec3.UnitY());\n  }\n\n  /**\n   * This gets called immediately before the interaction mode is activated. For now, we will call reset()\n   * @param args\n   */\n  beforeActivate() {\n    super.beforeActivate(...arguments);\n    this.reset();\n  }\n\n  /**\n   * Create an instance in a single call, instead of calling new followed by init\n   * @param owner\n   * @param args\n   * @returns {ASceneInteractionMode}\n   * @constructor\n   */\n  static Create(owner) {\n    let controls = new this();\n    controls.init(owner);\n    return controls;\n  }\n\n  // onWheelMove(event: AInteractionEvent, interaction: AWheelInteraction) {\n  //     let zoom = (event.DOMEvent as WheelEvent).deltaY;\n  //     let movedir = this.camera.pose.rotation.getLocalZ();\n  //     this.camera.pose.position = this.camera.pose.position.plus( movedir.times(0.0005 * zoom));\n  // }\n\n  // onDragStart(event: AInteractionEvent, interaction: ADragInteraction): void {\n  //     interaction.setInteractionState('lastCursor', event.ndcCursor);\n  // }\n  // onDragMove(event: AInteractionEvent, interaction: ADragInteraction): void {\n  //     if(!event.ndcCursor){\n  //         return;\n  //     }\n  //     let mouseMovement = event.ndcCursor.minus(interaction.getInteractionState('lastCursor'));\n  //     interaction.setInteractionState('lastCursor', event.ndcCursor);\n  //     let rotationX = -mouseMovement.x;\n  //     let rotationY = mouseMovement.y;\n  //     let qX = Quaternion.FromAxisAngle(this.camera.up, rotationX);\n  //     let qY = Quaternion.FromAxisAngle(this.camera.right, rotationY);\n  //     let newPose = this.camera.pose.clone();\n  //     newPose = new NodeTransform3D(qX.appliedTo(newPose.position), newPose.rotation.times(qX));\n  //     newPose = new NodeTransform3D(qY.appliedTo(newPose.position), newPose.rotation.times(qY));\n  //     this.cameraModel.setPose(newPose);\n  //     this.cameraModel.signalTransformUpdate();\n  // }\n  // onDragEnd(event: AInteractionEvent, interaction: ADragInteraction): void {\n  //     let cursorWorldCoordinates:Vec2|null = event.ndcCursor;\n  //     let dragStartWorldCoordinates:Vec2|null = interaction.dragStartEvent.ndcCursor;\n  // }\n\n  onKeyDown(event, interaction) {\n    if (interaction.keysDownState['w'] || interaction.keysDownState['ArrowUp'] || interaction.keysDownState['Up']) {\n      this.player.requestJump = true;\n    }\n    if (interaction.keysDownState['a'] || interaction.keysDownState['ArrowLeft'] || interaction.keysDownState['Left']) {\n      this.player.velocity.x = -AppConfigs.MoveSpeed;\n      this.player.horizontalMoving = true;\n    }\n    if (interaction.keysDownState['d'] || interaction.keysDownState['ArrowRight'] || interaction.keysDownState['Right']) {\n      this.player.velocity.x = AppConfigs.MoveSpeed;\n      this.player.horizontalMoving = true;\n    }\n  }\n  onKeyUp(event, interaction) {\n    // if(!(interaction.keysDownState['w'] ||\n    //   interaction.keysDownState['ArrowUp'] ||\n    //   interaction.keysDownState['Up'])){\n    //     //this.player.position.y = this.player.position.y+this.keyboardMovementSpeed;\n    // }\n    if (!(interaction.keysDownState['a'] || interaction.keysDownState['ArrowLeft'] || interaction.keysDownState['Left'] || interaction.keysDownState['d'] || interaction.keysDownState['ArrowRight'] || interaction.keysDownState['Right'])) {\n      this.player.horizontalMoving = false;\n    }\n  }\n\n  /**\n   * This would be a good place to implement the time update of any movement filters\n   * @param t\n   * @param args\n   */\n  timeUpdate(t) {}\n}) || _class);","map":{"version":3,"names":["ASerializable","NodeTransform3D","Vec3","MainAppInteractionMode","AppConfigs","GameInteractionMode","camera","model","constructor","owner","name","interactionCallbacks","args","player","reset","pose","LookAt","position","plus","UnitZ","times","UnitY","beforeActivate","Create","controls","init","onKeyDown","event","interaction","keysDownState","requestJump","velocity","x","MoveSpeed","horizontalMoving","onKeyUp","timeUpdate","t"],"sources":["/Users/home/Desktop/cs4620-final-project/src/app/main/InteractionModes/GameInteractionMode.ts"],"sourcesContent":["import type {HasInteractionModeCallbacks} from \"../../../anigraph\";\nimport {\n  ADragInteraction,\n  AInteractionEvent,\n  AKeyboardInteraction,\n  ASerializable,\n  NodeTransform3D,\n  Quaternion,\n  Vec2,\n  Vec3\n} from \"../../../anigraph\";\nimport {AWheelInteraction} from \"../../../anigraph/interaction/AWheelInteraction\";\nimport {ASceneInteractionMode} from \"../../../anigraph/scene/interactionmodes/ASceneInteractionMode\";\nimport {MainSceneController} from \"../Scene/MainSceneController\";\nimport {MainAppInteractionMode} from \"../../BaseClasses/MainAppInteractionMode\";\nimport {AppConfigs} from \"../../AppConfigs\";\n\n\n@ASerializable(\"GameInteractionMode\")\nexport class GameInteractionMode extends MainAppInteractionMode{\n\n    get camera(){\n        return this.model.camera;\n    }\n\n    constructor(owner?:MainSceneController,\n                name?:string,\n                interactionCallbacks?:HasInteractionModeCallbacks,\n                ...args:any[]) {\n        super(name, owner, interactionCallbacks, ...args);\n        // this.reset();\n    }\n\n    get player(){\n        return this.model.player;\n    }\n\n    reset(){\n        // You can reset the control mode here\n        this.camera.pose = NodeTransform3D.LookAt(\n            this.player.position.plus(Vec3.UnitZ().times(3)),\n            this.player.position,\n            Vec3.UnitY()\n        )\n    }\n\n    /**\n     * This gets called immediately before the interaction mode is activated. For now, we will call reset()\n     * @param args\n     */\n    beforeActivate(...args:any[]) {\n        super.beforeActivate(...args);\n        this.reset();\n    }\n\n    /**\n     * Create an instance in a single call, instead of calling new followed by init\n     * @param owner\n     * @param args\n     * @returns {ASceneInteractionMode}\n     * @constructor\n     */\n    static Create(owner: MainSceneController, ...args: any[]) {\n        let controls = new this();\n        controls.init(owner);\n        return controls;\n    }\n\n    // onWheelMove(event: AInteractionEvent, interaction: AWheelInteraction) {\n    //     let zoom = (event.DOMEvent as WheelEvent).deltaY;\n    //     let movedir = this.camera.pose.rotation.getLocalZ();\n    //     this.camera.pose.position = this.camera.pose.position.plus( movedir.times(0.0005 * zoom));\n    // }\n\n    // onDragStart(event: AInteractionEvent, interaction: ADragInteraction): void {\n    //     interaction.setInteractionState('lastCursor', event.ndcCursor);\n    // }\n    // onDragMove(event: AInteractionEvent, interaction: ADragInteraction): void {\n    //     if(!event.ndcCursor){\n    //         return;\n    //     }\n    //     let mouseMovement = event.ndcCursor.minus(interaction.getInteractionState('lastCursor'));\n    //     interaction.setInteractionState('lastCursor', event.ndcCursor);\n    //     let rotationX = -mouseMovement.x;\n    //     let rotationY = mouseMovement.y;\n    //     let qX = Quaternion.FromAxisAngle(this.camera.up, rotationX);\n    //     let qY = Quaternion.FromAxisAngle(this.camera.right, rotationY);\n    //     let newPose = this.camera.pose.clone();\n    //     newPose = new NodeTransform3D(qX.appliedTo(newPose.position), newPose.rotation.times(qX));\n    //     newPose = new NodeTransform3D(qY.appliedTo(newPose.position), newPose.rotation.times(qY));\n    //     this.cameraModel.setPose(newPose);\n    //     this.cameraModel.signalTransformUpdate();\n    // }\n    // onDragEnd(event: AInteractionEvent, interaction: ADragInteraction): void {\n    //     let cursorWorldCoordinates:Vec2|null = event.ndcCursor;\n    //     let dragStartWorldCoordinates:Vec2|null = interaction.dragStartEvent.ndcCursor;\n    // }\n\n    onKeyDown(event:AInteractionEvent, interaction:AKeyboardInteraction){\n        if(interaction.keysDownState['w'] ||\n          interaction.keysDownState['ArrowUp'] ||\n          interaction.keysDownState['Up']){\n            this.player.requestJump = true;\n        }\n        if(interaction.keysDownState['a'] ||\n          interaction.keysDownState['ArrowLeft'] ||\n          interaction.keysDownState['Left']){\n            this.player.velocity.x = -AppConfigs.MoveSpeed;\n            this.player.horizontalMoving = true;\n\n        }\n        if(interaction.keysDownState['d'] ||\n          interaction.keysDownState['ArrowRight'] ||\n          interaction.keysDownState['Right']){\n            this.player.velocity.x = AppConfigs.MoveSpeed;\n            this.player.horizontalMoving = true;\n        }\n    }\n\n    onKeyUp(event:AInteractionEvent, interaction:AKeyboardInteraction){\n        // if(!(interaction.keysDownState['w'] ||\n        //   interaction.keysDownState['ArrowUp'] ||\n        //   interaction.keysDownState['Up'])){\n        //     //this.player.position.y = this.player.position.y+this.keyboardMovementSpeed;\n        // }\n        if(!(interaction.keysDownState['a'] ||\n          interaction.keysDownState['ArrowLeft'] ||\n          interaction.keysDownState['Left'] ||\n          interaction.keysDownState['d'] ||\n          interaction.keysDownState['ArrowRight'] ||\n          interaction.keysDownState['Right'])){\n            this.player.horizontalMoving = false;\n        }\n    }\n\n    /**\n     * This would be a good place to implement the time update of any movement filters\n     * @param t\n     * @param args\n     */\n    timeUpdate(t: number, ...args:any[]) {\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}