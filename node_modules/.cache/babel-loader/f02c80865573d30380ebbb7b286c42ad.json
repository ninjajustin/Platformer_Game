{"ast":null,"code":"/**\n * @file Main scene model\n * @description Scene model for your application\n */\n\nimport { ACameraModel, Color, GetAppState, NodeTransform3D, V3, Vec2, Vec3 } from \"../../../../../anigraph\";\nimport { A3DModelLoader } from \"../../../../../anigraph\";\nimport { BaseSceneModel, CharacterModel } from \"../../../../BaseClasses\";\nimport { PlayerModel } from \"../../../Nodes\";\nimport { ATexture } from \"src/anigraph/rendering/ATexture\";\nimport { APointLightModel } from \"../../../../../anigraph/scene/lights\";\nimport { AppConfigs } from \"../../../../AppConfigs\";\n//import {PlayerModel} from \"../Nodes/PlayerNode\";\n//import {BotModel} from \"../Nodes/CharacterNodes/BotModel\";\nimport { GameTerrainModel } from \"../Nodes/GameTerrain/GameTerrainModel\";\nimport { ExampleLoadedCharacterModel } from \"../Nodes/Loaded/ExampleLoadedCharacterModel\";\nimport { AddStandardUniforms } from \"./HowToAddUniformToControlPanel\";\nimport { ABasicShaderModel } from \"src/anigraph/rendering/shadermodels/ABasicShaderModel\";\nconst exampleLevel = {\n  player: [0, 2],\n  terrains: [[-1, 0, 8, 1], [10, 1, 5, 1], [17, 3, 5, 1], [27, 0, 10, 1]]\n};\nlet appState = GetAppState();\n\n/**\n * Here we will define some enums that are simple strings.\n * These will be what we call different shader model instances. Note that we could just type these strings directly into\n * the code when we use them, but defining them as an enum will help avoid bugs caused by typos, and it will let you use\n * refactoring features of your IDE if you want to change these variables later.\n */\nvar MyMaterialNames;\n(function (MyMaterialNames) {\n  MyMaterialNames[\"basicshader1\"] = \"basicshader1\";\n  MyMaterialNames[\"mymaterial2\"] = \"mymaterial2\";\n})(MyMaterialNames || (MyMaterialNames = {}));\nexport class Example4SceneModel extends BaseSceneModel {\n  constructor() {\n    super(...arguments);\n    this._player = void 0;\n    this._mesh = void 0;\n    this.playerTexture = void 0;\n    this.bots = [];\n    this.gameTerrains = [];\n    this.loaded3DModel = void 0;\n    this.playerMaterial = void 0;\n  }\n  get player() {\n    return this._player;\n  }\n  set player(v) {\n    this._player = v;\n  }\n  get mesh() {\n    return this._mesh;\n  }\n  set mesh(v) {\n    this._mesh = v;\n  }\n  async loadModelFromFile(path, transform) {\n    /**\n     * Here we need to load the .ply file into an AObject3DModelWrapper instance\n     */\n    let meshObject = await A3DModelLoader.LoadFromPath(path);\n    meshObject.sourceTransform = transform !== null && transform !== void 0 ? transform : new NodeTransform3D();\n    return meshObject;\n  }\n  async PreloadAssets() {\n    await super.PreloadAssets();\n    await GameTerrainModel.LoadShader();\n    //await TerrainModel.LoadShader();\n    await CharacterModel.LoadShader();\n    await PlayerModel.LoadShader();\n    // this.materials.setMaterialModel(\"textured\", await ABasicShaderModel.CreateModel(\"basic\"));\n    /**\n     * Here we will create a shader model and name it with the string defined in `MyMaterialNames.basicshader1`.\n     * The shaderName argument to CreateModel is the name used in the shader folder and glsl files under\n     * `public/shaders/`\n     */\n    let basicshader1ShaderMaterialModel = await ABasicShaderModel.CreateModel(\"customexample1\");\n    await this.materials.setMaterialModel(MyMaterialNames.basicshader1, basicshader1ShaderMaterialModel);\n\n    /**\n     * If we want to use vertex colors in our shader, we need to set useVertexColors to true.\n     * This will turn vertex colors on by default for materials created with this model.\n     * Each time you create a material, you can turn off vertex colors for that material if you want.\n     */\n    basicshader1ShaderMaterialModel.usesVertexColors = true;\n\n    /**\n     * Once a shader model is set like this, we can access it with the material name we assigned it to like so:\n     */\n    this.playerMaterial = this.materials.CreateShaderMaterial(MyMaterialNames.basicshader1);\n  }\n  initCamera() {\n    this.cameraModel = ACameraModel.CreatePerspectiveFOV(90, 1, 0.01, 100);\n    this.cameraModel.setPose(NodeTransform3D.LookAt(V3(0.0, 0, 5), V3(0, 0, 0), V3(0, 1, 0)));\n  }\n\n  /**\n   * The view light is a light that is attached to the camera.\n   */\n  initViewLight() {\n    /**\n     * Create a point light\n     * You can have up to 16 point lights in the scene at once by default\n     */\n    this.viewLight = new APointLightModel(this.camera.pose, Color.FromString(\"#ffffff\"), 0.5, AppConfigs.ViewLightRange, 1);\n\n    /**\n     * Add it as a child of the camera model so that it will move with the camera\n     */\n    this.cameraModel.addChild(this.viewLight);\n  }\n  async initGameTerrain() {\n    for (let [x1, y1, w, h] of exampleLevel.terrains) {\n      let terrain = await GameTerrainModel.Create(w, h);\n      terrain.position.x = x1 + w / 2;\n      terrain.position.y = y1 + h / 2;\n      this.gameTerrains.push(terrain);\n      this.addChild(terrain);\n    }\n  }\n  async initGameHero() {\n    this.playerTexture = await ATexture.LoadAsync(\"./images/tanktexburngreen.jpeg\");\n    this.player = await PlayerModel.Create(this.playerTexture);\n    this.player.position = new Vec3(...exampleLevel.player, 0);\n    this.addChild(this.player);\n  }\n  async initMeshes() {\n    /**\n     * First we will initialze the player and add it to the scene.\n     */\n    /**\n     * Here we will initialize our player using the loaded .ply model and the shader material model we attached to\n     * the string MyMaterialNames.basicshader1\n     * @type {ExampleLoadedCharacterModel}\n     */\n    this.mesh = new ExampleLoadedCharacterModel(this.loaded3DModel, this.playerMaterial);\n    AddStandardUniforms(this.player.material);\n    this.addChild(this.player);\n  }\n  async initModel(model, texture, scale, pos) {\n    let transform = NodeTransform3D.FromPositionZUpAndScale(V3(pos), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), scale);\n    const glb = await this.loadModelFromFile(model, transform);\n    const b = this.materials.CreateShaderMaterial(MyMaterialNames.basicshader1);\n    const d = await ATexture.LoadAsync(texture);\n    b.setTexture('diffuse', d);\n    const a = new ExampleLoadedCharacterModel(glb, b);\n    AddStandardUniforms(a.material);\n    this.addChild(a);\n  }\n  async initScene() {\n    await this.initGameTerrain();\n    await this.initGameHero();\n    //await this.initMeshes();\n\n    await this.initModel(\"./models/gltf/cat.glb\", \"./models/gltf/Cat_diffuse.jpg\", 0.01, [.5, -1.5, 0]);\n    /**\n     * Now let's initialize the view light\n     */\n    this.initViewLight();\n  }\n  timeUpdate(t) {\n    let debug = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    /**\n     * We can call timeUpdate on all of the model nodes in the scene here, which will trigger any updates that they\n     * individually define.\n     */\n    for (let c of this.getDescendantList()) {\n      c.timeUpdate(t);\n    }\n    if (!debug) {\n      this.player.update(this.gameTerrains);\n      if (this.player.position.y < -10 || t <= 0.5) {\n        this.player.position = new Vec3(...exampleLevel.player, 0);\n        this.player.velocity = new Vec3();\n        const playerPos = this.player.position;\n        const cameraPos = playerPos.clone();\n        cameraPos.z = 10;\n        this.cameraModel.setPose(NodeTransform3D.LookAt(cameraPos, playerPos, new Vec3(0, 1, 0)));\n      }\n      if (Math.abs(this.cameraModel.pose.position.x - this.player.position.x) >= 0.01 || Math.abs(this.cameraModel.pose.position.y - this.player.position.y) >= 0.01) {\n        const cameraPos = this.cameraModel.pose.position.clone();\n        const playerPos = this.player.position.clone();\n        const playerVel = this.player.velocity.clone();\n        // higher gravity will look like player falling down harder\n        const g = AppConfigs.Gravity > 10 ? (AppConfigs.Gravity - 10) / 10 : 0;\n        playerVel.y = playerVel.y < g * playerVel.y ? 0 : playerVel.y;\n        // rate of camera movement, with 1 being camera on player at all times\n        const rate = this.cameraModel.pose.position.y < this.player.position.y ? 0.04 : 0.05;\n        // 1.5 is how much screen moves with player\n        const velocityCamera = cameraPos.clone().plus(playerVel.clone().times(1.5));\n        const new_camera_pos = velocityCamera.clone().plus(playerPos.clone().minus(velocityCamera).times(rate));\n        new_camera_pos.z = 10;\n        const new_target_pos = new_camera_pos.clone();\n        new_target_pos.z = 0;\n        this.cameraModel.setPose(NodeTransform3D.LookAt(new_camera_pos, new_target_pos, new Vec3(0, 1, 0)));\n      }\n      this.cameraModel.signalCameraProjectionUpdate();\n    }\n\n    // /**\n    //  * For interactions between models, we can trigger logic here. For example, if you want characters to walk on\n    //  * uneven terrain, you can make that happen by completing the functions used here:\n    //  */\n    // const self = this;\n    // function adjustHeight(character:Particle3D){\n    //     let height = self.terrain.getTerrainHeightAtPoint(character.position.xy);\n    //     if(character.position.z<height){character.position.z = height;}\n    // }\n    //\n    // /**\n    //  * Here we would apply our adjust height function to the player\n    //  */\n    // adjustHeight(this.player);\n    //\n    // /**\n    //  * Now lets update bots\n    //  */\n    // let orbitradius = 0.25;\n    // for(let ei=0;ei<this.bots.length;ei++){\n    //     let e = this.bots[ei];\n    //\n    //     /**\n    //      * Characters have velocity and mass properties in case you want to implement particle physics\n    //      * But for now we will just have them orbit each other.\n    //      */\n    //     e.position = new Vec3(Math.cos(t*(ei+1)), Math.sin(t*(ei+1)),0).times(orbitradius);\n    //\n    //     /**\n    //      * adjust their height\n    //      */\n    //     adjustHeight(e);\n    // }\n  }\n\n  getCoordinatesForCursorEvent(event) {\n    var _event$ndcCursor;\n    return (_event$ndcCursor = event.ndcCursor) !== null && _event$ndcCursor !== void 0 ? _event$ndcCursor : new Vec2();\n  }\n}","map":{"version":3,"names":["ACameraModel","Color","GetAppState","NodeTransform3D","V3","Vec2","Vec3","A3DModelLoader","BaseSceneModel","CharacterModel","PlayerModel","ATexture","APointLightModel","AppConfigs","GameTerrainModel","ExampleLoadedCharacterModel","AddStandardUniforms","ABasicShaderModel","exampleLevel","player","terrains","appState","MyMaterialNames","Example4SceneModel","_player","_mesh","playerTexture","bots","gameTerrains","loaded3DModel","playerMaterial","v","mesh","loadModelFromFile","path","transform","meshObject","LoadFromPath","sourceTransform","PreloadAssets","LoadShader","basicshader1ShaderMaterialModel","CreateModel","materials","setMaterialModel","basicshader1","usesVertexColors","CreateShaderMaterial","initCamera","cameraModel","CreatePerspectiveFOV","setPose","LookAt","initViewLight","viewLight","camera","pose","FromString","ViewLightRange","addChild","initGameTerrain","x1","y1","w","h","terrain","Create","position","x","y","push","initGameHero","LoadAsync","initMeshes","material","initModel","model","texture","scale","pos","FromPositionZUpAndScale","UnitZ","times","UnitY","glb","b","d","setTexture","a","initScene","timeUpdate","t","debug","c","getDescendantList","update","velocity","playerPos","cameraPos","clone","z","Math","abs","playerVel","g","Gravity","rate","velocityCamera","plus","new_camera_pos","minus","new_target_pos","signalCameraProjectionUpdate","getCoordinatesForCursorEvent","event","ndcCursor"],"sources":["/Users/home/Desktop/cs4620-final-project/src/app/main/Scene/ExampleScenes/Example4/Example4SceneModel.ts"],"sourcesContent":["/**\n * @file Main scene model\n * @description Scene model for your application\n */\n\nimport {ACameraModel, AInteractionEvent, Color, GetAppState, NodeTransform3D, V3, Vec2, Vec3} from \"../../../../../anigraph\";\nimport {A3DModelLoader, AObject3DModelWrapper, AShaderMaterial} from \"../../../../../anigraph\";\nimport {BaseSceneModel, CharacterModel, CharacterModelInterface} from \"../../../../BaseClasses\";\nimport {\n    BotModel,\n    ExampleParticleSystemModel,\n    ExampleThreeJSNodeModel,\n    PlayerModel,\n    SphereParticle,\n} from \"../../../Nodes\";\nimport {ATexture} from \"src/anigraph/rendering/ATexture\";\nimport {APointLightModel} from \"../../../../../anigraph/scene/lights\";\nimport {AppConfigs} from \"../../../../AppConfigs\";\n//import {PlayerModel} from \"../Nodes/PlayerNode\";\n//import {BotModel} from \"../Nodes/CharacterNodes/BotModel\";\nimport {GameTerrainModel} from \"../Nodes/GameTerrain/GameTerrainModel\";\nimport { ExampleLoadedCharacterModel } from \"../Nodes/Loaded/ExampleLoadedCharacterModel\";\nimport { AddStandardUniforms } from \"./HowToAddUniformToControlPanel\";\nimport { LoadedCharacterModel } from \"src/app/BaseClasses/LoadedCharacterModel\";\nimport { ABasicShaderModel } from \"src/anigraph/rendering/shadermodels/ABasicShaderModel\";\n\nconst exampleLevel: {player: [number, number], terrains: [number, number, number, number][]} = {\n    player: [0, 2],\n    terrains: [\n        [-1, 0, 8, 1],\n        [10, 1, 5, 1],\n        [17, 3, 5, 1],\n        [27, 0, 10, 1],\n    ],\n};\n\nlet appState = GetAppState();\n\n/**\n * Here we will define some enums that are simple strings.\n * These will be what we call different shader model instances. Note that we could just type these strings directly into\n * the code when we use them, but defining them as an enum will help avoid bugs caused by typos, and it will let you use\n * refactoring features of your IDE if you want to change these variables later.\n */\nenum MyMaterialNames {\n    basicshader1 = \"basicshader1\",\n    mymaterial2 = \"mymaterial2\",\n}\n\n\nexport class Example4SceneModel extends BaseSceneModel {\n    /**\n     * Our custom player model, and a texture to use for our player\n     */\n    _player!:PlayerModel;\n    get player():PlayerModel{\n        return this._player as PlayerModel;\n    }\n    set player(v:PlayerModel){\n        this._player = v;\n    }\n\n    _mesh!: CharacterModelInterface;\n    get mesh(): CharacterModelInterface {\n        return this._mesh as LoadedCharacterModel;\n    }\n    set mesh(v: CharacterModelInterface) {\n        this._mesh = v;\n    }\n\n    playerTexture!:ATexture;\n\n    /**\n     * An array of bots. Your\n     */\n    bots:BotModel[]=[];\n\n    gameTerrains:GameTerrainModel[]=[];\n\n    /**\n     * Our custom terrain model\n     */\n        //terrain!: TerrainModel;\n\n    loaded3DModel!: AObject3DModelWrapper;\n    playerMaterial!: AShaderMaterial;\n\n\n    async loadModelFromFile(path: string, transform?: NodeTransform3D) {\n        /**\n         * Here we need to load the .ply file into an AObject3DModelWrapper instance\n         */\n        let meshObject = await A3DModelLoader.LoadFromPath(path)\n        meshObject.sourceTransform = transform ?? new NodeTransform3D();\n        return meshObject;\n    }\n\n\n    async PreloadAssets() {\n        await super.PreloadAssets();\n        await GameTerrainModel.LoadShader();\n        //await TerrainModel.LoadShader();\n        await CharacterModel.LoadShader();\n        await PlayerModel.LoadShader();\n        // this.materials.setMaterialModel(\"textured\", await ABasicShaderModel.CreateModel(\"basic\"));\n        /**\n         * Here we will create a shader model and name it with the string defined in `MyMaterialNames.basicshader1`.\n         * The shaderName argument to CreateModel is the name used in the shader folder and glsl files under\n         * `public/shaders/`\n         */\n        let basicshader1ShaderMaterialModel = await ABasicShaderModel.CreateModel(\"customexample1\");\n        await this.materials.setMaterialModel(MyMaterialNames.basicshader1, basicshader1ShaderMaterialModel);\n\n        /**\n         * If we want to use vertex colors in our shader, we need to set useVertexColors to true.\n         * This will turn vertex colors on by default for materials created with this model.\n         * Each time you create a material, you can turn off vertex colors for that material if you want.\n         */\n        basicshader1ShaderMaterialModel.usesVertexColors = true;\n\n        /**\n         * Once a shader model is set like this, we can access it with the material name we assigned it to like so:\n         */\n        this.playerMaterial = this.materials.CreateShaderMaterial(MyMaterialNames.basicshader1);\n\n\n    }\n\n    initCamera() {\n        this.cameraModel = ACameraModel.CreatePerspectiveFOV(90, 1, 0.01, 100);\n        this.cameraModel.setPose(\n            NodeTransform3D.LookAt(\n                V3(0.0, 0, 5), V3(0,0,0),\n                V3(0,1,0)\n            )\n        )\n    }\n\n    /**\n     * The view light is a light that is attached to the camera.\n     */\n    initViewLight(){\n\n        /**\n         * Create a point light\n         * You can have up to 16 point lights in the scene at once by default\n         */\n        this.viewLight = new APointLightModel(\n            this.camera.pose,\n            Color.FromString(\"#ffffff\"),\n            0.5,\n            AppConfigs.ViewLightRange,\n            1\n        );\n\n        /**\n         * Add it as a child of the camera model so that it will move with the camera\n         */\n        this.cameraModel.addChild(this.viewLight);\n    }\n\n    async initGameTerrain() {\n        for (let [x1, y1, w, h] of exampleLevel.terrains) {\n            let terrain = await GameTerrainModel.Create(w, h);\n            terrain.position.x = x1 + w / 2;\n            terrain.position.y = y1 + h / 2;\n            this.gameTerrains.push(terrain);\n            this.addChild(terrain);\n        }\n    }\n\n    async initGameHero() {\n        this.playerTexture = await ATexture.LoadAsync(\"./images/tanktexburngreen.jpeg\")\n        this.player = await PlayerModel.Create(this.playerTexture);\n        this.player.position = new Vec3(...exampleLevel.player, 0);\n        this.addChild(this.player);\n    }\n\n    async initMeshes() {\n        /**\n         * First we will initialze the player and add it to the scene.\n         */\n        /**\n         * Here we will initialize our player using the loaded .ply model and the shader material model we attached to\n         * the string MyMaterialNames.basicshader1\n         * @type {ExampleLoadedCharacterModel}\n         */\n        this.mesh = new ExampleLoadedCharacterModel(\n            this.loaded3DModel,\n            this.playerMaterial,\n        );\n        AddStandardUniforms(this.player.material);\n        this.addChild(this.player);\n    }\n\n\n    async initModel(model: string, texture: string, scale: number, pos: Array<number>) {\n        let transform = NodeTransform3D.FromPositionZUpAndScale(V3(pos), Vec3.UnitZ().times(1), Vec3.UnitY().times(-1), scale);\n        const glb = await this.loadModelFromFile(model, transform);\n\n        const b = this.materials.CreateShaderMaterial(MyMaterialNames.basicshader1);\n        const d = await ATexture.LoadAsync(texture);\n\n        b.setTexture('diffuse', d)\n        const a = new ExampleLoadedCharacterModel(\n            glb,\n            b\n        );\n        AddStandardUniforms(a.material);\n        this.addChild(a);\n    }\n\n\n    async initScene() {\n        await this.initGameTerrain();\n        await this.initGameHero();\n        //await this.initMeshes();\n\n        await this.initModel(\"./models/gltf/cat.glb\", \"./models/gltf/Cat_diffuse.jpg\", 0.01, [.5, -1.5, 0]);\n        /**\n         * Now let's initialize the view light\n         */\n        this.initViewLight();\n    }\n\n    timeUpdate(t: number, debug: boolean = false, ...args:any[]) {\n\n        /**\n         * We can call timeUpdate on all of the model nodes in the scene here, which will trigger any updates that they\n         * individually define.\n         */\n        for(let c of this.getDescendantList()){\n            c.timeUpdate(t);\n        }\n\n        if (!debug) {\n\n            this.player.update(this.gameTerrains);\n\n            if (this.player.position.y < -10 || t <= 0.5) {\n                this.player.position = new Vec3(...exampleLevel.player, 0);\n                this.player.velocity = new Vec3();\n                const playerPos = this.player.position;\n                const cameraPos = playerPos.clone();\n                cameraPos.z = 10;\n                this.cameraModel.setPose(\n                    NodeTransform3D.LookAt(\n                        cameraPos, playerPos,\n                        new Vec3(0, 1, 0)\n                    )\n                );\n            }\n\n            if (Math.abs(this.cameraModel.pose.position.x - this.player.position.x)  >= 0.01 ||\n                Math.abs(this.cameraModel.pose.position.y - this.player.position.y) >= 0.01) {\n\n                const cameraPos = this.cameraModel.pose.position.clone()\n                const playerPos = this.player.position.clone();\n                const playerVel = this.player.velocity.clone();\n                // higher gravity will look like player falling down harder\n                const g = AppConfigs.Gravity > 10? (AppConfigs.Gravity - 10)/10 : 0\n                playerVel.y = playerVel.y < g * playerVel.y ? 0 : playerVel.y\n                // rate of camera movement, with 1 being camera on player at all times\n                const rate = this.cameraModel.pose.position.y < this.player.position.y ? 0.04 : 0.05\n                // 1.5 is how much screen moves with player\n                const velocityCamera = cameraPos.clone().plus(playerVel.clone().times(1.5))\n                const new_camera_pos = velocityCamera.clone().plus(playerPos.clone().minus(velocityCamera).times(rate))\n                new_camera_pos.z = 10;\n\n                const new_target_pos = new_camera_pos.clone()\n                new_target_pos.z = 0;\n\n                this.cameraModel.setPose(\n                    NodeTransform3D.LookAt(\n                        new_camera_pos, new_target_pos,\n                        new Vec3(0, 1, 0)\n                    )\n                );\n            }\n            this.cameraModel.signalCameraProjectionUpdate();\n        }\n\n\n        // /**\n        //  * For interactions between models, we can trigger logic here. For example, if you want characters to walk on\n        //  * uneven terrain, you can make that happen by completing the functions used here:\n        //  */\n        // const self = this;\n        // function adjustHeight(character:Particle3D){\n        //     let height = self.terrain.getTerrainHeightAtPoint(character.position.xy);\n        //     if(character.position.z<height){character.position.z = height;}\n        // }\n        //\n        // /**\n        //  * Here we would apply our adjust height function to the player\n        //  */\n        // adjustHeight(this.player);\n        //\n        // /**\n        //  * Now lets update bots\n        //  */\n        // let orbitradius = 0.25;\n        // for(let ei=0;ei<this.bots.length;ei++){\n        //     let e = this.bots[ei];\n        //\n        //     /**\n        //      * Characters have velocity and mass properties in case you want to implement particle physics\n        //      * But for now we will just have them orbit each other.\n        //      */\n        //     e.position = new Vec3(Math.cos(t*(ei+1)), Math.sin(t*(ei+1)),0).times(orbitradius);\n        //\n        //     /**\n        //      * adjust their height\n        //      */\n        //     adjustHeight(e);\n        // }\n    }\n\n    getCoordinatesForCursorEvent(event: AInteractionEvent){\n        return event.ndcCursor??new Vec2();\n    }\n}\n\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}