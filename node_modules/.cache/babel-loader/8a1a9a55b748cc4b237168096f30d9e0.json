{"ast":null,"code":"var _dec, _class;\nimport { AParticleSystemModel } from \"../../../../anigraph/effects/particles/AParticleSystemModel\";\nimport { ASerializable, Color, GetAppState, NodeTransform3D, Quaternion, V3 } from \"../../../../anigraph\";\nimport { BillboardParticle } from \"./BillboardParticle\";\nimport { BillboardParticleSystemView } from \"./BillboardParticleSystemView\";\nlet appState = GetAppState();\nexport let BillboardParticleSystemModel = (_dec = ASerializable(\"BillboardParticleSystemModel\"), _dec(_class = class BillboardParticleSystemModel extends AParticleSystemModel {\n  //particles:ABillboardParticle[]\n\n  // /**\n  //  * This is an example of how you can add particle system controls to the control panel\n  //  * @constructor\n  //  */\n  // static AddParticleSystemControls(){\n  // }\n\n  /**\n   * This will emit a new particle. The starter implementation does this in a round-robin order, so it will recycle\n   * the particle that was emitted least recently.\n   * @param position\n   * @param velocity\n   * @param mass\n   * @param radius\n   * @param t0\n   */\n  emit() {\n    let t0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    let i = (this.lastEmittedIndex + 1) % this.nParticles;\n\n    // set starting position to a random point inside a circle on the xz plane\n    let startingPosition = V3(.5, 0, 0).times(Math.random()).getRotatedByQuaternion(Quaternion.RotationY(Math.random() * 2 * Math.PI));\n    startingPosition = startingPosition.plus(this.myTransform.position);\n    let startingVelocity = V3(1, 1, 0).getRotatedByQuaternion(Quaternion.RotationY(Math.random() * 2 * Math.PI));\n    this.particles[i].position = startingPosition;\n    this.particles[i].velocity = startingVelocity;\n    this.particles[i].sinOffset = Math.random() * 2 * Math.PI;\n    this.particles[i].mass = 3;\n    this.particles[i].size = .7;\n    this.particles[i].visible = true;\n    this.particles[i].t0 = t0;\n    this.particles[i].color = Color.FromRGBA(222 + (256 - 222) * Math.random() / 256, 70 / 256, 35 / 256, 1);\n    this.lastEmittedIndex = i;\n  }\n\n  /**\n   * Here you initialize the particles\n   * @param nParticles\n   */\n  initParticles(nParticles) {\n    for (let i = 0; i < nParticles; i++) {\n      let newp = new BillboardParticle();\n\n      /**\n       * Here we will initialize the particles to be invisible.\n       * This won't do anything on its own, though; you will have to ensure that invisible particles are not visible in your corresponding custom view class.\n       */\n      newp.visible = false;\n\n      /**\n       * Let's add the particle...\n       */\n      this.addParticle(newp);\n    }\n  }\n  constructor(transform) {\n    super();\n    this.lastEmittedIndex = 0;\n    this.lastTimeUpdate = -1;\n    this.cameraTransform = new NodeTransform3D();\n    this.myTransform = new NodeTransform3D();\n    this.disabled = false;\n    this.initParticles(BillboardParticleSystemView.MAX_PARTICLES);\n    this.signalParticlesUpdated();\n    if (transform != undefined) this.myTransform = transform;\n  }\n  updateCameraTransform(transform) {\n    this.cameraTransform = transform;\n  }\n  setDisable() {\n    this.disabled = true;\n    this.myTransform.position = V3(0, -999, 0);\n    for (let i = 0; i < this.particles.length; i++) {\n      this.particles[i].position = V3(0, -999, 0);\n      this.particles[i].velocity = V3(0, 0, 0);\n    }\n  }\n  timeUpdate(t) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    super.timeUpdate(t, ...args);\n\n    /**\n     * This is one way to check and see if we are in our first timeUpdate call.\n     * We initialized this.lastTimeUpdate to -1, so if it is less than 0 we know it's our first time calling this function.\n     */\n    if (this.lastTimeUpdate < 0) {\n      this.lastTimeUpdate = t;\n    }\n    let timePassed = t - this.lastTimeUpdate;\n    this.lastTimeUpdate = t;\n    if (this.disabled) return;\n\n    /**\n     * Let's emit a new particle\n     */\n    this.emit();\n\n    /**\n     * Here we will define some behavior for our particles. This is a bare minimum simple forward euler simulation.\n     */\n\n    for (let i = 0; i < this.particles.length; i++) {\n      let p = this.particles[i];\n      p.position = p.position.plus(p.velocity.times(3 * timePassed));\n      p.size /= 1.02;\n      p.updateVelocity(t, timePassed);\n    }\n\n    /**\n     * This is important! You need to signal that the particles have been updated to trigger re-rendering of the view!\n     */\n    this.signalParticlesUpdated();\n  }\n}) || _class);","map":{"version":3,"names":["AParticleSystemModel","ASerializable","Color","GetAppState","NodeTransform3D","Quaternion","V3","BillboardParticle","BillboardParticleSystemView","appState","BillboardParticleSystemModel","emit","t0","i","lastEmittedIndex","nParticles","startingPosition","times","Math","random","getRotatedByQuaternion","RotationY","PI","plus","myTransform","position","startingVelocity","particles","velocity","sinOffset","mass","size","visible","color","FromRGBA","initParticles","newp","addParticle","constructor","transform","lastTimeUpdate","cameraTransform","disabled","MAX_PARTICLES","signalParticlesUpdated","undefined","updateCameraTransform","setDisable","length","timeUpdate","t","args","timePassed","p","updateVelocity"],"sources":["/Users/home/Desktop/cs4620-final-project/src/app/main/Nodes/BillboardParticleSystem/BillboardParticleSystemModel.ts"],"sourcesContent":["import {AParticleSystemModel} from \"../../../../anigraph/effects/particles/AParticleSystemModel\";\nimport {ASerializable, Color, GetAppState, NodeTransform3D, Quaternion, V3, Vec3} from \"../../../../anigraph\";\nimport {AppConfigs} from \"../../../AppConfigs\";\nimport {BillboardParticle} from \"./BillboardParticle\";\nimport { v3 } from \"uuid\";\nimport {BillboardParticleSystemView} from \"./BillboardParticleSystemView\";\n\n\nlet appState = GetAppState();\n\n@ASerializable(\"BillboardParticleSystemModel\")\nexport class BillboardParticleSystemModel extends AParticleSystemModel<BillboardParticle>{\n    //particles:ABillboardParticle[]\n    lastEmittedIndex:number=0;\n    lastTimeUpdate:number=-1;\n    cameraTransform:NodeTransform3D = new NodeTransform3D();\n    myTransform:NodeTransform3D = new NodeTransform3D();\n    disabled:boolean = false;\n\n    // /**\n    //  * This is an example of how you can add particle system controls to the control panel\n    //  * @constructor\n    //  */\n    // static AddParticleSystemControls(){\n    // }\n\n    /**\n     * This will emit a new particle. The starter implementation does this in a round-robin order, so it will recycle\n     * the particle that was emitted least recently.\n     * @param position\n     * @param velocity\n     * @param mass\n     * @param radius\n     * @param t0\n     */\n    emit(t0:number=-1){\n        let i=(this.lastEmittedIndex+1)%(this.nParticles);\n\n        // set starting position to a random point inside a circle on the xz plane\n        let startingPosition = V3(.5, 0, 0).times(Math.random()).getRotatedByQuaternion(Quaternion.RotationY(Math.random() * 2 * Math.PI));\n        startingPosition = startingPosition.plus(this.myTransform.position);\n        let startingVelocity = V3(1,1,0).getRotatedByQuaternion(Quaternion.RotationY(Math.random() * 2 * Math.PI));\n\n        this.particles[i].position = startingPosition;\n        this.particles[i].velocity = startingVelocity;\n        this.particles[i].sinOffset = Math.random() * 2 * Math.PI\n        this.particles[i].mass = 3;\n        this.particles[i].size = .7;\n        this.particles[i].visible=true;\n        this.particles[i].t0=t0;\n        this.particles[i].color = Color.FromRGBA(222 + (256 - 222) * Math.random() / 256, 70 / 256, 35 / 256, 1);\n        this.lastEmittedIndex=i;\n    }\n\n    /**\n     * Here you initialize the particles\n     * @param nParticles\n     */\n    initParticles(nParticles:number){\n        for(let i=0;i<nParticles;i++){\n            let newp = new BillboardParticle();\n\n            /**\n             * Here we will initialize the particles to be invisible.\n             * This won't do anything on its own, though; you will have to ensure that invisible particles are not visible in your corresponding custom view class.\n             */\n            newp.visible=false;\n\n            /**\n             * Let's add the particle...\n             */\n            this.addParticle(newp);\n        }\n    }\n\n    constructor(transform?:NodeTransform3D, ...args:any[]) {\n        super();\n        this.initParticles(BillboardParticleSystemView.MAX_PARTICLES);\n        this.signalParticlesUpdated();\n        if (transform != undefined)\n            this.myTransform = transform;\n    }\n\n    updateCameraTransform(transform: NodeTransform3D){\n        this.cameraTransform = transform\n    }\n\n    setDisable() {\n        this.disabled = true;\n        this.myTransform.position = V3(0, -999, 0);\n        for(let i=0;i<this.particles.length;i++){\n            this.particles[i].position = V3(0, -999, 0);\n            this.particles[i].velocity = V3(0, 0, 0);\n        }\n    }\n\n    timeUpdate(t: number, ...args:any[]) {\n        super.timeUpdate(t, ...args);\n\n        /**\n         * This is one way to check and see if we are in our first timeUpdate call.\n         * We initialized this.lastTimeUpdate to -1, so if it is less than 0 we know it's our first time calling this function.\n         */\n        if(this.lastTimeUpdate<0){\n            this.lastTimeUpdate=t;\n        }\n\n        let timePassed = t-this.lastTimeUpdate;\n        this.lastTimeUpdate=t;\n        if (this.disabled) return;\n\n        /**\n         * Let's emit a new particle\n         */\n        this.emit();\n\n        /**\n         * Here we will define some behavior for our particles. This is a bare minimum simple forward euler simulation.\n         */\n\n        for(let i=0;i<this.particles.length;i++){\n            let p =this.particles[i];\n            p.position=p.position.plus(\n                p.velocity.times(\n                  3*timePassed\n                )\n            );\n            p.size /= 1.02;\n\n            p.updateVelocity(t, timePassed);\n        }\n\n        /**\n         * This is important! You need to signal that the particles have been updated to trigger re-rendering of the view!\n         */\n        this.signalParticlesUpdated();\n    }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}