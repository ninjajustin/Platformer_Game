{"ast":null,"code":"var _dec, _class;\nimport { V2, V3, Vec3, V4, V4A } from \"../\";\nimport { VertexAttributeArray2D, VertexAttributeArray3D, VertexAttributeArrayFromThreeJS, VertexAttributeColorArray } from \"./VertexAttributeArray\";\nimport { ASerializable } from \"../\";\nimport { VertexArray } from \"./VertexArray\";\nimport { VertexIndexArray } from \"./VertexIndexArray\";\nimport { BoundingBox3D } from \"./BoundingBox3D\";\nimport { Color } from \"../\";\n\n// import { ATexture } from \"../arender/ATexture\";\n\nexport let VertexArray3D = (_dec = ASerializable(\"VertexArray3D\"), _dec(_class = class VertexArray3D extends VertexArray {\n  constructor() {\n    super();\n    this.position = new VertexAttributeArray3D();\n  }\n  getBounds() {\n    let b = new BoundingBox3D();\n    b.boundVertexPositionArrray(this.position);\n    return b;\n  }\n\n  /** Get set position */\n  set position(value) {\n    this.attributes[\"position\"] = value;\n  }\n  get position() {\n    return this.attributes[\"position\"];\n  }\n  setAttributeArray(name, attributeArray) {\n    this.attributes[name] = attributeArray;\n  }\n  static FromThreeJS(buffergeo) {\n    let varray = new VertexArray3D();\n    varray.indices = VertexIndexArray.FromThreeJS(buffergeo.index);\n    for (let atrname in buffergeo.attributes) {\n      varray.attributes[atrname] = VertexAttributeArrayFromThreeJS(buffergeo.attributes[atrname]);\n    }\n    return varray;\n  }\n\n  // static FromVertexArray2D(v2:VertexArray2D, transform:Mat4){\n  //     let v3=new VertexArray3D();\n  // }\n\n  addTriangleCCW(A, B, C, uv, color) {\n    let i = this.nVerts;\n    let AB = B.minus(A);\n    let AC = C.minus(A);\n    let N = AB.getNormalized().cross(AC.getNormalized());\n    let colorv = color;\n    if (colorv !== undefined) {\n      for (let c = 0; c < (colorv === null || colorv === void 0 ? void 0 : colorv.length); c++) {\n        if (colorv[c] instanceof Color) {\n          colorv[c] = colorv[c].Vec4;\n        }\n      }\n    }\n    this.addVertex(A, N, uv ? uv[0] : undefined, colorv ? colorv[0] : undefined);\n    this.addVertex(B, N, uv ? uv[1] : undefined, colorv ? colorv[1] : undefined);\n    this.addVertex(C, N, uv ? uv[2] : undefined, colorv ? colorv[2] : undefined);\n    this.indices.push([i, i + 1, i + 2]);\n  }\n  static Axis() {\n    let scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let o = V3(0, 0, 0);\n    let x = V3(scale, 0, 0);\n    let y = V3(0, scale, 0);\n    let nz = V3(0, 0, -scale);\n    let verts = VertexArray3D.CreateForRendering(false, false, true);\n    verts.addVertex(o, undefined, undefined, Color.FromString(\"#ff0000\"));\n    verts.addVertex(x, undefined, undefined, Color.FromString(\"#ff0000\"));\n    verts.addVertex(o, undefined, undefined, Color.FromString(\"#00ff00\"));\n    verts.addVertex(y, undefined, undefined, Color.FromString(\"#00ff00\"));\n    verts.addVertex(o, undefined, undefined, Color.FromString(\"#0000ff\"));\n    verts.addVertex(nz, undefined, undefined, Color.FromString(\"#0000ff\"));\n    verts.indices = new VertexIndexArray(2);\n    verts.indices.push([0, 1, 2, 3, 4, 5]);\n    return verts;\n  }\n  static FrustumFromProjectionMatrix(P) {\n    let imagePlaneDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n    let imagePlaneNDC = 0.0;\n    let baseNDC = [V4(-1, -1, imagePlaneNDC, 1), V4(1, -1, imagePlaneNDC, 1), V4(1, 1, imagePlaneNDC, 1), V4(-1, 1, imagePlaneNDC, 1)];\n    let PInv = P.getInverse();\n    let baseV = baseNDC.map(v => {\n      return PInv.times(v);\n    });\n    let verts = new VertexArray3D();\n    verts.normal = new VertexAttributeArray3D();\n    verts.indices = new VertexIndexArray(3);\n    for (let i = 0; i < 3; i++) {\n      verts.addTriangleCCW(V3(0, 0, 0), baseV[i].Point3D.getHomogenized().times(-imagePlaneDepth), baseV[i + 1].Point3D.getHomogenized().times(-imagePlaneDepth));\n    }\n    verts.addTriangleCCW(V3(0, 0, 0), baseV[3].Point3D.getHomogenized().times(-imagePlaneDepth), baseV[0].Point3D.getHomogenized().times(-imagePlaneDepth));\n    return verts;\n  }\n  static CreateForRendering() {\n    let hasNormals = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let hasTextureCoords = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let hasColors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let v = new this();\n    v.indices = new VertexIndexArray(3);\n    if (hasNormals) {\n      v.normal = new VertexAttributeArray3D();\n    }\n    if (hasTextureCoords) {\n      v.uv = new VertexAttributeArray2D();\n    }\n    if (hasColors) {\n      v.color = new VertexAttributeColorArray();\n    }\n    return v;\n  }\n  static SquareXYUV() {\n    let scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let wraps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let verts = new VertexArray3D();\n    verts.position = new VertexAttributeArray3D();\n    verts.position.push(V3(-0.5, -0.5, 0.0).times(scale));\n    verts.position.push(V3(0.5, -0.5, 0.0).times(scale));\n    verts.position.push(V3(0.5, 0.5, 0.0).times(scale));\n    verts.position.push(V3(-0.5, 0.5, 0.0).times(scale));\n    verts.uv = new VertexAttributeArray2D();\n    verts.uv.push(V2(0, 0).times(wraps));\n    verts.uv.push(V2(1, 0).times(wraps));\n    verts.uv.push(V2(1, 1).times(wraps));\n    verts.uv.push(V2(0, 1).times(wraps));\n    verts.normal = new VertexAttributeArray3D();\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n    verts.indices = new VertexIndexArray(3);\n    verts.indices.push([0, 1, 2]);\n    verts.indices.push([0, 2, 3]);\n    return verts;\n  }\n  static IndexedGrid() {\n    var _color;\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    let widthSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    let heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n    let textureWraps = arguments.length > 4 ? arguments[4] : undefined;\n    let color = arguments.length > 5 ? arguments[5] : undefined;\n    // let width:number=1, height:number=1, widthSegments:number=1,heightSegments:number=1;\n\n    color = (_color = color) !== null && _color !== void 0 ? _color : Color.FromString(\"#ffffff\");\n    if (textureWraps === undefined) {\n      textureWraps = V2(1, 1);\n    }\n    let halfW = width * 0.5;\n    let halfH = height * 0.5;\n    // let's use normals, texture coords, and colors...\n    let v = VertexArray3D.CreateForRendering(true, true, true);\n    for (let y = 0; y < heightSegments + 1; y++) {\n      for (let x = 0; x < widthSegments + 1; x++) {\n        v.addVertex(V3(-halfW + x / widthSegments * width, -halfH + y / heightSegments * height, 0), V3(0, 0, 1), V2(x * textureWraps.x / widthSegments, y * textureWraps.y / heightSegments), color);\n      }\n    }\n    for (let y = 0; y < heightSegments; y++) {\n      for (let x = 0; x < widthSegments; x++) {\n        v.indices.push([x + y * (widthSegments + 1), x + 1 + y * (widthSegments + 1), x + 1 + (y + 1) * (widthSegments + 1)]);\n        v.indices.push([x + 1 + (y + 1) * (widthSegments + 1), x + (y + 1) * (widthSegments + 1), x + y * (widthSegments + 1)]);\n      }\n    }\n    return v;\n  }\n\n  // static VertsForBounds2D(bound:BoundingBox3D){\n  //     let verts = new VertexArray3D();\n  //     verts.position= new VertexAttributeArray3D();\n  //     verts.position.push(V3(-0.5*aspect,-0.5,0.0).times(scale))\n  //     verts.position.push(V3(0.5*aspect,-0.5,0.0).times(scale))\n  //     verts.position.push(V3(0.5*aspect,0.5,0.0).times(scale))\n  //     verts.position.push(V3(-0.5*aspect,0.5,0.0).times(scale))\n  //     verts.uv = new VertexAttributeArray2D()\n  //     verts.uv.push(V2(0,0));\n  //     verts.uv.push(V2(1,0));\n  //     verts.uv.push(V2(1,1));\n  //     verts.uv.push(V2(0,1));\n  //\n  //     verts.normal = new VertexAttributeArray3D();\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //\n  //     verts.indices = new VertexIndexArray(3);\n  //     verts.indices.push([0,1,2]);\n  //     verts.indices.push([0,2,3]);\n  //     return verts;\n  // }\n\n  static Box3D(minPoint, maxPoint) {\n    // let va = new VertexArray3D();\n    let va = VertexArray3D.CreateForRendering(true, true);\n    let corners = [minPoint.clone(), V3(maxPoint.x, minPoint.y, minPoint.z), V3(maxPoint.x, maxPoint.y, minPoint.z), V3(minPoint.x, maxPoint.y, minPoint.z), V3(minPoint.x, minPoint.y, maxPoint.z), V3(maxPoint.x, minPoint.y, maxPoint.z), maxPoint.clone(), V3(minPoint.x, maxPoint.y, maxPoint.z)];\n    va.indices = new VertexIndexArray(3);\n    let startIndex = 0;\n    function addSide(verts) {\n      let si = startIndex;\n      // let normal = verts[1].minus(verts[0]).cross(verts[3].minus(verts[0])).getNormalized().times(-1);\n      let normal = V3(0, 0, 1);\n      va.addVertex(verts[0], normal, V2(0, 0));\n      va.addVertex(verts[1], normal, V2(1, 0));\n      va.addVertex(verts[2], normal, V2(1, 1));\n      va.addVertex(verts[3], normal, V2(0, 1));\n      va.indices.push([si, si + 1, si + 2]);\n      va.indices.push([si, si + 2, si + 3]);\n      startIndex = startIndex + 4;\n    }\n    addSide([corners[0], corners[1], corners[2], corners[3]]);\n    addSide([corners[0], corners[1], corners[5], corners[4]]);\n    addSide([corners[0], corners[3], corners[7], corners[4]]);\n    addSide([corners[4], corners[5], corners[6], corners[7]]);\n    addSide([corners[2], corners[3], corners[7], corners[6]]);\n    addSide([corners[1], corners[2], corners[6], corners[5]]);\n    return va;\n  }\n  static MeshVertsForBoundingBox3D(bounds) {\n    return bounds.GetBoxTriangleMeshVerts();\n  }\n  static BoundingBoxMeshVertsForObject3D(obj) {\n    return BoundingBox3D.FromTHREEJSObject(obj).GetBoxTriangleMeshVerts();\n  }\n\n  /**\n   * Slightly modified from ThreeJS\n   * @param radius\n   * @param widthSegments\n   * @param heightSegments\n   * @param phiStart\n   * @param phiLength\n   * @param thetaStart\n   * @param thetaLength\n   * @constructor\n   */\n  static Sphere() {\n    let radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let widthSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n    let heightSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16;\n    let phiStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let phiLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Math.PI * 2;\n    let thetaStart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    let thetaLength = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Math.PI;\n    let sphere = VertexArray3D.CreateForRendering(true, true);\n    widthSegments = Math.max(3, Math.floor(widthSegments));\n    heightSegments = Math.max(2, Math.floor(heightSegments));\n    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    let index = 0;\n    const grid = [];\n    const vertex = new Vec3();\n    // const normal = new Vec3();\n    // generate vertices, normals and uvs\n\n    for (let iy = 0; iy <= heightSegments; iy++) {\n      const verticesRow = [];\n      const v = iy / heightSegments;\n      // special case for the poles\n      let uOffset = 0;\n      if (iy === 0 && thetaStart === 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy === heightSegments && thetaEnd === Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n      for (let ix = 0; ix <= widthSegments; ix++) {\n        const u = ix / widthSegments;\n        // vertex\n        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n\n        // uv\n        let uv = V2(u + uOffset, 1 - v);\n        verticesRow.push(index++);\n        sphere.addVertex(vertex, vertex.getNormalized(), uv);\n      }\n      grid.push(verticesRow);\n    }\n\n    // indices\n\n    for (let iy = 0; iy < heightSegments; iy++) {\n      for (let ix = 0; ix < widthSegments; ix++) {\n        const a = grid[iy][ix + 1];\n        const b = grid[iy][ix];\n        const c = grid[iy + 1][ix];\n        const d = grid[iy + 1][ix + 1];\n        if (iy !== 0 || thetaStart > 0) {\n          sphere.indices.push([a, b, d]);\n        }\n        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) {\n          sphere.indices.push([b, c, d]);\n        }\n      }\n    }\n    return sphere;\n  }\n\n  /**\n   * Slightly modified from ThreeJS\n   * @param radius\n   * @param widthSegments\n   * @param heightSegments\n   * @param phiStart\n   * @param phiLength\n   * @param thetaStart\n   * @param thetaLength\n   * @constructor\n   */\n  static ColoredSphere() {\n    let radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    let widthSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;\n    let heightSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16;\n    let color = arguments.length > 3 ? arguments[3] : undefined;\n    // color = color??Color.RandomRGBA();\n    let phiStart = 0;\n    let phiLength = Math.PI * 2;\n    let thetaStart = 0;\n    let thetaLength = Math.PI;\n    let sphere = VertexArray3D.CreateForRendering(true, true, true);\n    widthSegments = Math.max(3, Math.floor(widthSegments));\n    heightSegments = Math.max(2, Math.floor(heightSegments));\n    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    let index = 0;\n    const grid = [];\n    const vertex = new Vec3();\n    // const normal = new Vec3();\n    // generate vertices, normals and uvs\n\n    for (let iy = 0; iy <= heightSegments; iy++) {\n      const verticesRow = [];\n      const v = iy / heightSegments;\n      // special case for the poles\n      let uOffset = 0;\n      if (iy === 0 && thetaStart === 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy === heightSegments && thetaEnd === Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n      for (let ix = 0; ix <= widthSegments; ix++) {\n        const u = ix / widthSegments;\n        // vertex\n        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n\n        // uv\n        let uv = V2(u + uOffset, 1 - v);\n        verticesRow.push(index++);\n        sphere.addVertex(vertex, vertex.getNormalized(), uv, Color.RandomRGBA());\n      }\n      grid.push(verticesRow);\n    }\n\n    // indices\n\n    for (let iy = 0; iy < heightSegments; iy++) {\n      for (let ix = 0; ix < widthSegments; ix++) {\n        const a = grid[iy][ix + 1];\n        const b = grid[iy][ix];\n        const c = grid[iy + 1][ix];\n        const d = grid[iy + 1][ix + 1];\n        if (iy !== 0 || thetaStart > 0) {\n          sphere.indices.push([a, b, d]);\n        }\n        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) {\n          sphere.indices.push([b, c, d]);\n        }\n      }\n    }\n    return sphere;\n  }\n\n  // static SpriteGeometry(texture: ATexture, scale: number = 100) {\n  //   let verts = new VertexArray3D();\n  //   let aspect = texture.width / texture.height;\n  //   verts.position = new VertexAttributeArray3D();\n  //   verts.position.push(V3(-0.5 * aspect, -0.5, 0.0).times(scale));\n  //   verts.position.push(V3(0.5 * aspect, -0.5, 0.0).times(scale));\n  //   verts.position.push(V3(0.5 * aspect, 0.5, 0.0).times(scale));\n  //   verts.position.push(V3(-0.5 * aspect, 0.5, 0.0).times(scale));\n  //   verts.uv = new VertexAttributeArray2D();\n  //   verts.uv.push(V2(0, 0));\n  //   verts.uv.push(V2(1, 0));\n  //   verts.uv.push(V2(1, 1));\n  //   verts.uv.push(V2(0, 1));\n  //\n  //   verts.normal = new VertexAttributeArray3D();\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //\n  //   verts.indices = new VertexIndexArray(3);\n  //   verts.indices.push([0, 1, 2]);\n  //   verts.indices.push([0, 2, 3]);\n  //   return verts;\n  // }\n\n  addVertex(v, normal, uv, color) {\n    this.position.push(v);\n    if (color) {\n      var _this$color;\n      (_this$color = this.color) === null || _this$color === void 0 ? void 0 : _this$color.push(V4A(...color.elements));\n    }\n    if (normal) {\n      var _this$normal;\n      (_this$normal = this.normal) === null || _this$normal === void 0 ? void 0 : _this$normal.push(V3(...normal.elements));\n    }\n    if (uv) {\n      var _this$uv;\n      (_this$uv = this.uv) === null || _this$uv === void 0 ? void 0 : _this$uv.push(V2(...uv.elements));\n    }\n  }\n  static FromVec3List(verts) {\n    let va = new VertexArray3D();\n    for (let v of verts) {\n      va.addVertex(v);\n    }\n    return va;\n  }\n}) || _class);","map":{"version":3,"names":["V2","V3","Vec3","V4","V4A","VertexAttributeArray2D","VertexAttributeArray3D","VertexAttributeArrayFromThreeJS","VertexAttributeColorArray","ASerializable","VertexArray","VertexIndexArray","BoundingBox3D","Color","VertexArray3D","constructor","position","getBounds","b","boundVertexPositionArrray","value","attributes","setAttributeArray","name","attributeArray","FromThreeJS","buffergeo","varray","indices","index","atrname","addTriangleCCW","A","B","C","uv","color","i","nVerts","AB","minus","AC","N","getNormalized","cross","colorv","undefined","c","length","Vec4","addVertex","push","Axis","scale","o","x","y","nz","verts","CreateForRendering","FromString","FrustumFromProjectionMatrix","P","imagePlaneDepth","imagePlaneNDC","baseNDC","PInv","getInverse","baseV","map","v","times","normal","Point3D","getHomogenized","hasNormals","hasTextureCoords","hasColors","SquareXYUV","wraps","IndexedGrid","width","height","widthSegments","heightSegments","textureWraps","halfW","halfH","Box3D","minPoint","maxPoint","va","corners","clone","z","startIndex","addSide","si","MeshVertsForBoundingBox3D","bounds","GetBoxTriangleMeshVerts","BoundingBoxMeshVertsForObject3D","obj","FromTHREEJSObject","Sphere","radius","phiStart","phiLength","Math","PI","thetaStart","thetaLength","sphere","max","floor","thetaEnd","min","grid","vertex","iy","verticesRow","uOffset","ix","u","cos","sin","a","d","ColoredSphere","RandomRGBA","elements","FromVec3List"],"sources":["/Users/home/Desktop/cs4620-final-project/src/anigraph/geometry/VertexArray3D.ts"],"sourcesContent":["import {V2, Vec2, V3, Vec3, V4, Vec4, Mat4, V4A} from \"../\";\nimport {\n  VertexAttributeArray,\n  VertexAttributeArray2D,\n  VertexAttributeArray3D,\n  VertexAttributeArray4D,\n  VertexAttributeArrayFromThreeJS, VertexAttributeColorArray,\n} from \"./VertexAttributeArray\";\nimport { ASerializable} from \"../\";\nimport { VertexArray } from \"./VertexArray\";\nimport { VertexIndexArray } from \"./VertexIndexArray\";\nimport { BoundingBox3D } from \"./BoundingBox3D\";\nimport { Color} from \"../\";\n\n// import { ATexture } from \"../arender/ATexture\";\n\n@ASerializable(\"VertexArray3D\")\nexport class VertexArray3D extends VertexArray<Vec3> {\n  constructor() {\n    super();\n    this.position = new VertexAttributeArray3D();\n  }\n\n  getBounds(): BoundingBox3D {\n    let b = new BoundingBox3D();\n    b.boundVertexPositionArrray(this.position);\n    return b;\n  }\n\n  /** Get set position */\n  set position(value: VertexAttributeArray3D) {\n    this.attributes[\"position\"] = value;\n  }\n  get position() {\n    return this.attributes[\"position\"] as VertexAttributeArray3D;\n  }\n\n  setAttributeArray(name: string, attributeArray: VertexAttributeArray<any>) {\n    this.attributes[name] = attributeArray;\n  }\n\n  static FromThreeJS(buffergeo: THREE.BufferGeometry) {\n    let varray = new VertexArray3D();\n    varray.indices = VertexIndexArray.FromThreeJS(buffergeo.index);\n    for (let atrname in buffergeo.attributes) {\n      varray.attributes[atrname] = VertexAttributeArrayFromThreeJS(\n        buffergeo.attributes[atrname]\n      );\n    }\n    return varray;\n  }\n\n  // static FromVertexArray2D(v2:VertexArray2D, transform:Mat4){\n  //     let v3=new VertexArray3D();\n  // }\n\n  addTriangleCCW(A: Vec3, B: Vec3, C: Vec3, uv?: Vec2[], color?: Vec4[]|Color[]) {\n    let i = this.nVerts;\n    let AB = B.minus(A);\n    let AC = C.minus(A);\n    let N = AB.getNormalized().cross(AC.getNormalized());\n\n    let colorv=color;\n    if(colorv !== undefined) {\n      for(let c=0; c<colorv?.length;c++) {\n        if (colorv[c] instanceof Color) {\n          colorv[c] = (colorv[c] as Color).Vec4;\n        }\n      }\n    }\n\n    this.addVertex(A, N, uv ? uv[0] : undefined, colorv ? colorv[0] : undefined);\n    this.addVertex(B, N, uv ? uv[1] : undefined, colorv ? colorv[1] : undefined);\n    this.addVertex(C, N, uv ? uv[2] : undefined, colorv ? colorv[2] : undefined);\n\n    this.indices.push([i, i + 1, i + 2]);\n  }\n\n  static Axis(scale = 1) {\n    let o = V3(0, 0, 0);\n    let x = V3(scale, 0, 0);\n    let y = V3(0, scale, 0);\n    let nz = V3(0, 0, -scale);\n    let verts = VertexArray3D.CreateForRendering(false, false, true);\n    verts.addVertex(o, undefined, undefined, Color.FromString(\"#ff0000\"));\n    verts.addVertex(x, undefined, undefined, Color.FromString(\"#ff0000\"));\n    verts.addVertex(o, undefined, undefined, Color.FromString(\"#00ff00\"));\n    verts.addVertex(y, undefined, undefined, Color.FromString(\"#00ff00\"));\n    verts.addVertex(o, undefined, undefined, Color.FromString(\"#0000ff\"));\n    verts.addVertex(nz, undefined, undefined, Color.FromString(\"#0000ff\"));\n    verts.indices = new VertexIndexArray(2);\n    verts.indices.push([0, 1, 2, 3, 4, 5]);\n    return verts;\n  }\n\n  static FrustumFromProjectionMatrix(P: Mat4, imagePlaneDepth = 100) {\n    let imagePlaneNDC = 0.0;\n    let baseNDC = [\n      V4(-1, -1, imagePlaneNDC, 1),\n      V4(1, -1, imagePlaneNDC, 1),\n      V4(1, 1, imagePlaneNDC, 1),\n      V4(-1, 1, imagePlaneNDC, 1),\n    ];\n\n    let PInv = P.getInverse();\n    let baseV = baseNDC.map((v: Vec4) => {\n      return PInv.times(v);\n    });\n\n    let verts = new VertexArray3D();\n    verts.normal = new VertexAttributeArray3D();\n    verts.indices = new VertexIndexArray(3);\n\n    for (let i = 0; i < 3; i++) {\n      verts.addTriangleCCW(\n        V3(0, 0, 0),\n        baseV[i].Point3D.getHomogenized().times(-imagePlaneDepth),\n        baseV[i + 1].Point3D.getHomogenized().times(-imagePlaneDepth)\n      );\n    }\n    verts.addTriangleCCW(\n      V3(0, 0, 0),\n      baseV[3].Point3D.getHomogenized().times(-imagePlaneDepth),\n      baseV[0].Point3D.getHomogenized().times(-imagePlaneDepth)\n    );\n    return verts;\n  }\n\n  static CreateForRendering(\n    hasNormals: boolean = true,\n    hasTextureCoords: boolean = true,\n    hasColors: boolean = false\n  ) {\n    let v = new this();\n    v.indices = new VertexIndexArray(3);\n    if (hasNormals) {\n      v.normal = new VertexAttributeArray3D();\n    }\n    if (hasTextureCoords) {\n      v.uv = new VertexAttributeArray2D();\n    }\n    if (hasColors) {\n      v.color = new VertexAttributeColorArray();\n    }\n    return v;\n  }\n\n  static SquareXYUV(scale: number = 1, wraps: number = 1) {\n    let verts = new VertexArray3D();\n    verts.position = new VertexAttributeArray3D();\n    verts.position.push(V3(-0.5, -0.5, 0.0).times(scale));\n    verts.position.push(V3(0.5, -0.5, 0.0).times(scale));\n    verts.position.push(V3(0.5, 0.5, 0.0).times(scale));\n    verts.position.push(V3(-0.5, 0.5, 0.0).times(scale));\n    verts.uv = new VertexAttributeArray2D();\n    verts.uv.push(V2(0, 0).times(wraps));\n    verts.uv.push(V2(1, 0).times(wraps));\n    verts.uv.push(V2(1, 1).times(wraps));\n    verts.uv.push(V2(0, 1).times(wraps));\n\n    verts.normal = new VertexAttributeArray3D();\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n    verts.normal.push(V3(0.0, 0.0, 1.0).times(scale));\n\n    verts.indices = new VertexIndexArray(3);\n    verts.indices.push([0, 1, 2]);\n    verts.indices.push([0, 2, 3]);\n    return verts;\n  }\n\n  static IndexedGrid(\n    width: number = 1,\n    height: number = 1,\n    widthSegments: number = 1,\n    heightSegments: number = 1,\n    textureWraps?:Vec2,\n    color?: Color\n  ) {\n    // let width:number=1, height:number=1, widthSegments:number=1,heightSegments:number=1;\n\n    color = color ?? Color.FromString(\"#ffffff\");\n\n    if(textureWraps === undefined){\n      textureWraps = V2(1, 1);\n    }\n\n    let halfW = width * 0.5;\n    let halfH = height * 0.5;\n    // let's use normals, texture coords, and colors...\n    let v = VertexArray3D.CreateForRendering(true, true, true);\n    for (let y = 0; y < heightSegments + 1; y++) {\n      for (let x = 0; x < widthSegments + 1; x++) {\n        v.addVertex(\n          V3(\n            -halfW + (x / widthSegments) * width,\n            -halfH + (y / heightSegments) * height,\n            0\n          ),\n          V3(0, 0, 1),\n          V2(x*textureWraps.x / widthSegments, y*textureWraps.y / heightSegments),\n          color\n        );\n      }\n    }\n\n    for (let y = 0; y < heightSegments; y++) {\n      for (let x = 0; x < widthSegments; x++) {\n        v.indices.push([\n          x + y * (widthSegments + 1),\n          x + 1 + y * (widthSegments + 1),\n          x + 1 + (y + 1) * (widthSegments + 1),\n        ]);\n        v.indices.push([\n          x + 1 + (y + 1) * (widthSegments + 1),\n          x + (y + 1) * (widthSegments + 1),\n          x + y * (widthSegments + 1),\n        ]);\n      }\n    }\n    return v;\n  }\n\n  // static VertsForBounds2D(bound:BoundingBox3D){\n  //     let verts = new VertexArray3D();\n  //     verts.position= new VertexAttributeArray3D();\n  //     verts.position.push(V3(-0.5*aspect,-0.5,0.0).times(scale))\n  //     verts.position.push(V3(0.5*aspect,-0.5,0.0).times(scale))\n  //     verts.position.push(V3(0.5*aspect,0.5,0.0).times(scale))\n  //     verts.position.push(V3(-0.5*aspect,0.5,0.0).times(scale))\n  //     verts.uv = new VertexAttributeArray2D()\n  //     verts.uv.push(V2(0,0));\n  //     verts.uv.push(V2(1,0));\n  //     verts.uv.push(V2(1,1));\n  //     verts.uv.push(V2(0,1));\n  //\n  //     verts.normal = new VertexAttributeArray3D();\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //     verts.normal.push(V3(0.0,0.0,-1.0).times(scale))\n  //\n  //     verts.indices = new VertexIndexArray(3);\n  //     verts.indices.push([0,1,2]);\n  //     verts.indices.push([0,2,3]);\n  //     return verts;\n  // }\n\n  static Box3D(minPoint:Vec3, maxPoint:Vec3) {\n    // let va = new VertexArray3D();\n    let va = VertexArray3D.CreateForRendering(true, true)\n    let corners = [minPoint.clone(),\n      V3(maxPoint.x, minPoint.y, minPoint.z),\n      V3(maxPoint.x, maxPoint.y, minPoint.z),\n      V3(minPoint.x, maxPoint.y, minPoint.z),\n      V3(minPoint.x, minPoint.y, maxPoint.z),\n      V3(maxPoint.x, minPoint.y, maxPoint.z),\n        maxPoint.clone(),\n      V3(minPoint.x, maxPoint.y, maxPoint.z)\n    ];\n\n    va.indices = new VertexIndexArray(3);\n    let startIndex = 0;\n    function addSide(verts:Vec3[]){\n      let si = startIndex;\n      // let normal = verts[1].minus(verts[0]).cross(verts[3].minus(verts[0])).getNormalized().times(-1);\n      let normal = V3(0,0,1);\n      va.addVertex(verts[0],normal,V2(0,0));\n      va.addVertex(verts[1],normal,V2(1,0));\n      va.addVertex(verts[2],normal,V2(1,1));\n      va.addVertex(verts[3],normal,V2(0,1));\n      va.indices.push([si,si+1,si+2]);\n      va.indices.push([si,si+2,si+3]);\n      startIndex = startIndex+4;\n    }\n\n    addSide([corners[0],corners[1],corners[2],corners[3]])\n    addSide([corners[0],corners[1],corners[5],corners[4]])\n    addSide([corners[0],corners[3],corners[7],corners[4]])\n\n    addSide([corners[4],corners[5],corners[6],corners[7]])\n    addSide([corners[2],corners[3],corners[7],corners[6]])\n    addSide([corners[1],corners[2],corners[6],corners[5]])\n    return va;\n  }\n\n\n  static MeshVertsForBoundingBox3D(bounds: BoundingBox3D) {\n    return bounds.GetBoxTriangleMeshVerts();\n  }\n\n  static BoundingBoxMeshVertsForObject3D(obj: THREE.Object3D) {\n    return BoundingBox3D.FromTHREEJSObject(obj).GetBoxTriangleMeshVerts();\n  }\n\n  /**\n   * Slightly modified from ThreeJS\n   * @param radius\n   * @param widthSegments\n   * @param heightSegments\n   * @param phiStart\n   * @param phiLength\n   * @param thetaStart\n   * @param thetaLength\n   * @constructor\n   */\n  static Sphere(\n    radius = 1,\n    widthSegments = 32,\n    heightSegments = 16,\n    phiStart = 0,\n    phiLength = Math.PI * 2,\n    thetaStart = 0,\n    thetaLength = Math.PI\n  ) {\n    let sphere = VertexArray3D.CreateForRendering(true, true);\n    widthSegments = Math.max(3, Math.floor(widthSegments));\n    heightSegments = Math.max(2, Math.floor(heightSegments));\n    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    let index = 0;\n    const grid = [];\n    const vertex = new Vec3();\n    // const normal = new Vec3();\n    // generate vertices, normals and uvs\n\n    for (let iy = 0; iy <= heightSegments; iy++) {\n      const verticesRow = [];\n      const v = iy / heightSegments;\n      // special case for the poles\n      let uOffset = 0;\n      if (iy === 0 && thetaStart === 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy === heightSegments && thetaEnd === Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n      for (let ix = 0; ix <= widthSegments; ix++) {\n        const u = ix / widthSegments;\n        // vertex\n        vertex.x =\n          -radius *\n          Math.cos(phiStart + u * phiLength) *\n          Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z =\n          radius *\n          Math.sin(phiStart + u * phiLength) *\n          Math.sin(thetaStart + v * thetaLength);\n\n        // uv\n        let uv = V2(u + uOffset, 1 - v);\n\n        verticesRow.push(index++);\n        sphere.addVertex(vertex, vertex.getNormalized(), uv);\n      }\n      grid.push(verticesRow);\n    }\n\n    // indices\n\n    for (let iy = 0; iy < heightSegments; iy++) {\n      for (let ix = 0; ix < widthSegments; ix++) {\n        const a = grid[iy][ix + 1];\n        const b = grid[iy][ix];\n        const c = grid[iy + 1][ix];\n        const d = grid[iy + 1][ix + 1];\n        if (iy !== 0 || thetaStart > 0) {\n          sphere.indices.push([a, b, d]);\n        }\n        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) {\n          sphere.indices.push([b, c, d]);\n        }\n      }\n    }\n    return sphere;\n  }\n\n\n  /**\n   * Slightly modified from ThreeJS\n   * @param radius\n   * @param widthSegments\n   * @param heightSegments\n   * @param phiStart\n   * @param phiLength\n   * @param thetaStart\n   * @param thetaLength\n   * @constructor\n   */\n  static ColoredSphere(\n      radius = 1,\n      widthSegments = 32,\n      heightSegments = 16,\n      color?:Color\n  ) {\n    // color = color??Color.RandomRGBA();\n    let phiStart = 0;\n    let phiLength = Math.PI * 2;\n    let thetaStart = 0;\n    let thetaLength = Math.PI\n    let sphere = VertexArray3D.CreateForRendering(true, true, true);\n    widthSegments = Math.max(3, Math.floor(widthSegments));\n    heightSegments = Math.max(2, Math.floor(heightSegments));\n    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    let index = 0;\n    const grid = [];\n    const vertex = new Vec3();\n    // const normal = new Vec3();\n    // generate vertices, normals and uvs\n\n    for (let iy = 0; iy <= heightSegments; iy++) {\n      const verticesRow = [];\n      const v = iy / heightSegments;\n      // special case for the poles\n      let uOffset = 0;\n      if (iy === 0 && thetaStart === 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy === heightSegments && thetaEnd === Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n      for (let ix = 0; ix <= widthSegments; ix++) {\n        const u = ix / widthSegments;\n        // vertex\n        vertex.x =\n            -radius *\n            Math.cos(phiStart + u * phiLength) *\n            Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z =\n            radius *\n            Math.sin(phiStart + u * phiLength) *\n            Math.sin(thetaStart + v * thetaLength);\n\n        // uv\n        let uv = V2(u + uOffset, 1 - v);\n\n        verticesRow.push(index++);\n        sphere.addVertex(vertex, vertex.getNormalized(), uv,Color.RandomRGBA());\n      }\n      grid.push(verticesRow);\n    }\n\n    // indices\n\n    for (let iy = 0; iy < heightSegments; iy++) {\n      for (let ix = 0; ix < widthSegments; ix++) {\n        const a = grid[iy][ix + 1];\n        const b = grid[iy][ix];\n        const c = grid[iy + 1][ix];\n        const d = grid[iy + 1][ix + 1];\n        if (iy !== 0 || thetaStart > 0) {\n          sphere.indices.push([a, b, d]);\n        }\n        if (iy !== heightSegments - 1 || thetaEnd < Math.PI) {\n          sphere.indices.push([b, c, d]);\n        }\n      }\n    }\n    return sphere;\n  }\n\n\n  // static SpriteGeometry(texture: ATexture, scale: number = 100) {\n  //   let verts = new VertexArray3D();\n  //   let aspect = texture.width / texture.height;\n  //   verts.position = new VertexAttributeArray3D();\n  //   verts.position.push(V3(-0.5 * aspect, -0.5, 0.0).times(scale));\n  //   verts.position.push(V3(0.5 * aspect, -0.5, 0.0).times(scale));\n  //   verts.position.push(V3(0.5 * aspect, 0.5, 0.0).times(scale));\n  //   verts.position.push(V3(-0.5 * aspect, 0.5, 0.0).times(scale));\n  //   verts.uv = new VertexAttributeArray2D();\n  //   verts.uv.push(V2(0, 0));\n  //   verts.uv.push(V2(1, 0));\n  //   verts.uv.push(V2(1, 1));\n  //   verts.uv.push(V2(0, 1));\n  //\n  //   verts.normal = new VertexAttributeArray3D();\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //   verts.normal.push(V3(0.0, 0.0, -1.0).times(scale));\n  //\n  //   verts.indices = new VertexIndexArray(3);\n  //   verts.indices.push([0, 1, 2]);\n  //   verts.indices.push([0, 2, 3]);\n  //   return verts;\n  // }\n\n  addVertex(v: Vec3, normal?: Vec3, uv?: Vec2, color?: Color | Vec4) {\n    this.position.push(v);\n    if (color) {\n      this.color?.push(V4A(...color.elements));\n    }\n    if (normal) {\n      this.normal?.push(V3(...normal.elements));\n    }\n    if (uv) {\n      this.uv?.push(V2(...uv.elements));\n    }\n  }\n\n  static FromVec3List(verts: Vec3[]) {\n    let va = new VertexArray3D();\n    for (let v of verts) {\n      va.addVertex(v);\n    }\n    return va;\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}