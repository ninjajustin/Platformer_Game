{"ast":null,"code":"var _dec, _class;\nimport { ASerializable } from \"../../base\";\nimport { Vec2, Vec3, Mat3, Quaternion } from \"../linalg\";\nimport { Precision } from \"../Precision\";\nimport { NodeTransform3D } from \"./NodeTransform3D\";\nexport let NodeTransform2D = (_dec = ASerializable(\"NodeTransform2D\"), _dec(_class = class NodeTransform2D {\n  get scale() {\n    return this._scale;\n  }\n  set scale(value) {\n    if (value instanceof Vec2) {\n      this._scale = value;\n    } else {\n      this._scale = new Vec2(value, value);\n    }\n  }\n  constructor() {\n    this.position = void 0;\n    this.anchor = void 0;\n    this._scale = void 0;\n    this.rotation = void 0;\n    if ((arguments.length <= 0 ? undefined : arguments[0]) instanceof Mat3) {\n      let pos = arguments.length > 1 ? arguments.length <= 1 ? undefined : arguments[1] : undefined;\n      this.setWithMatrix(arguments.length <= 0 ? undefined : arguments[0], pos);\n      if (!this.position) {\n        this.position = new Vec2(0, 0);\n      }\n    } else {\n      this.position = arguments.length > 0 ? arguments.length <= 0 ? undefined : arguments[0] : new Vec2(0, 0);\n      this.rotation = arguments.length > 1 ? arguments.length <= 1 ? undefined : arguments[1] : 0;\n      this.scale = arguments.length > 2 ? arguments.length <= 2 ? undefined : arguments[2] : new Vec2(1, 1);\n      this.anchor = arguments.length > 3 ? arguments.length <= 3 ? undefined : arguments[3] : new Vec2(0, 0);\n    }\n  }\n  getPosition() {\n    return Vec3.FromVec2(this.position);\n  }\n  _getQuaternionRotation() {\n    throw new Error(\"Method not implemented.\");\n  }\n  _setQuaternionRotation(q) {\n    throw new Error(\"Method not implemented.\");\n  }\n  setPosition(position) {\n    this.position = position.xy;\n  }\n  clone() {\n    return new NodeTransform2D(this.position.clone(), this.rotation, this.scale.clone(), this.anchor.clone());\n  }\n\n  /**\n   * Returns the transformation matrix for this set of transform properties.\n   *\n   * @returns the transformation matrix\n   */\n  getMatrix() {\n    const position = Mat3.Translation2D(this.position);\n    const rotation = Mat3.Rotation(this.rotation);\n    const scale = Mat3.Scale2D(this.scale);\n    const anchor = Mat3.Translation2D(this.anchor.times(-1));\n    return position.times(rotation).times(scale).times(anchor);\n  }\n  getMat4() {\n    return this.getMatrix().Mat4From2DH();\n  }\n  static FromMatrix(m, position, useOldRotation) {\n    let newNT = new NodeTransform2D();\n    newNT.setWithMatrix(m, position, useOldRotation);\n    return newNT;\n  }\n\n  /**\n   * Sets the transform properties based on the given affine transformation\n   * matrix and optional position.\n   *\n   * This function should set the transform based on an input matrix and\n   * (optionally) a starting position. Calling T.getMatrix() on the resulting\n   * transform should produce the input matrix `m`. Position should\n   * be the point where changes to rotation or scale will rotate and scale around.\n   * Meanings of position, rotation, scale, and anchor match those used in Adobe\n   * standards (e.g., After Effects). The corresponding matrix is calculated\n   * as shown in getMatrix() above: (P)*(R)*(S)*(-A). Position is specified as\n   * a constraint because the two translations in the above equation create a\n   * redundancy.\n   *\n   * We recommend familiarizing yourself with the available methods in\n   * `src/anigraph/amath/Mat3.ts`.\n   *\n   * Also familiarize yourself with the available functions in\n   * `src/anigraph/amath/Precision.ts`. These are useful when dealing with\n   * floating point inaccuracies and other small numbers.\n   *\n   * Note: do not let the scale factor be less than epsilon.\n   *\n   * @param m the affine transformation matrix\n   * @param position the starting positon\n   */\n  setWithMatrix(m, position, useOldRotation) {\n    // throw new Error(\"setWithMatrix not implemented yet! Wait for assignment 2!\")\n\n    //TODO: Don't leave this in!\n    const ex = new Vec3(1, 0, 0);\n    const ey = new Vec3(0, 1, 0);\n    if (position !== undefined) {\n      this.position = position;\n    }\n    if (!useOldRotation) {\n      const Mex = m.times(ex);\n      this.rotation = Math.atan2(Mex.y, Mex.x);\n    }\n    const noRo = Mat3.Rotation(-this.rotation).times(m);\n    const scaleX = noRo.times(ex);\n    const scaleY = noRo.times(ey);\n    this.scale = new Vec2(Precision.ClampAbsAboveEpsilon(scaleX.x), Precision.ClampAbsAboveEpsilon(scaleY.y));\n    var ORSinv = Mat3.Translation2D(this.position).times(Mat3.Rotation(this.rotation).times(Mat3.Scale2D(this.scale))).getInverse();\n    if (ORSinv === null) {\n      throw new Error(`tried to set transform with matrix that has zero determinant: ${m}`);\n      return;\n    }\n    this.anchor = ORSinv.times(m).times(Vec3.From2DHPoint(new Vec2(0, 0))).Point2D.times(-1);\n  }\n  NodeTransform3D() {\n    let rval = new NodeTransform3D(new Vec3(this.position.x, this.position.y, 0), Quaternion.FromAxisAngle(new Vec3(0, 0, 1), this.rotation), new Vec3(this.scale.x, this.scale.y, 1), new Vec3(this.anchor.x, this.anchor.y, 0));\n    return rval;\n  }\n  NodeTransform2D() {\n    return this;\n  }\n  assignTo(threejsMat) {\n    this.getMat4().assignTo(threejsMat);\n  }\n}) || _class);","map":{"version":3,"names":["ASerializable","Vec2","Vec3","Mat3","Quaternion","Precision","NodeTransform3D","NodeTransform2D","scale","_scale","value","constructor","position","anchor","rotation","pos","length","undefined","setWithMatrix","getPosition","FromVec2","_getQuaternionRotation","Error","_setQuaternionRotation","q","setPosition","xy","clone","getMatrix","Translation2D","Rotation","Scale2D","times","getMat4","Mat4From2DH","FromMatrix","m","useOldRotation","newNT","ex","ey","Mex","Math","atan2","y","x","noRo","scaleX","scaleY","ClampAbsAboveEpsilon","ORSinv","getInverse","From2DHPoint","Point2D","rval","FromAxisAngle","assignTo","threejsMat"],"sources":["/Users/home/Desktop/cs4620-final-project/src/anigraph/math/nodetransforms/NodeTransform2D.ts"],"sourcesContent":["import { ASerializable } from \"../../base\";\nimport { NodeTransform } from \"./NodeTransform\";\nimport { Vec2, Vec3, Mat3, Mat4, Quaternion } from \"../linalg\";\nimport { Precision } from \"../Precision\";\nimport { NodeTransform3D } from \"./NodeTransform3D\";\nimport {Matrix4} from \"three\";\n\n@ASerializable(\"NodeTransform2D\")\nexport class NodeTransform2D implements NodeTransform<Vec2, Mat3> {\n  public position!: Vec2;\n  public anchor!: Vec2;\n  public _scale!: Vec2;\n  public rotation!: number;\n\n  get scale(): Vec2 {\n    return this._scale;\n  }\n  set scale(value: Vec2 | number) {\n    if (value instanceof Vec2) {\n      this._scale = value;\n    } else {\n      this._scale = new Vec2(value, value);\n    }\n  }\n\n  constructor(position?: Vec2, rotation?: number, scale?: Vec2, anchor?: Vec2);\n  constructor(matrix: Mat3, position?: Vec2);\n  constructor(...args: any[]) {\n    if (args[0] instanceof Mat3) {\n      let pos = args.length > 1 ? args[1] : undefined;\n      this.setWithMatrix(args[0], pos);\n      if (!this.position) {\n        this.position = new Vec2(0, 0);\n      }\n    } else {\n      this.position = (args.length > 0) ? args[0] : new Vec2(0, 0);\n      this.rotation = (args.length > 1) ? args[1] : 0;\n      this.scale = (args.length > 2) ? args[2] : new Vec2(1, 1);\n      this.anchor = (args.length > 3) ? args[3] : new Vec2(0, 0);\n    }\n  }\n\n  getPosition(): Vec3 {\n    return Vec3.FromVec2(this.position);\n  }\n  _getQuaternionRotation(): Quaternion {\n    throw new Error(\"Method not implemented.\");\n  }\n  _setQuaternionRotation(q: Quaternion): void {\n    throw new Error(\"Method not implemented.\");\n  }\n  setPosition(position: Vec3): void {\n    this.position = position.xy;\n  }\n\n\n  clone() {\n    return new NodeTransform2D(this.position.clone(),  this.rotation, this.scale.clone(), this.anchor.clone());\n  }\n\n  /**\n   * Returns the transformation matrix for this set of transform properties.\n   *\n   * @returns the transformation matrix\n   */\n  getMatrix() {\n    const position = Mat3.Translation2D(this.position);\n    const rotation = Mat3.Rotation(this.rotation);\n    const scale = Mat3.Scale2D(this.scale);\n    const anchor = Mat3.Translation2D(this.anchor.times(-1));\n    return position.times(rotation).times(scale).times(anchor);\n  }\n\n  getMat4(): Mat4 {\n    return this.getMatrix().Mat4From2DH();\n  }\n\n  static FromMatrix(m:Mat3, position?:Vec2, useOldRotation?:boolean){\n    let newNT = new NodeTransform2D();\n    newNT.setWithMatrix(m, position, useOldRotation);\n    return newNT;\n  }\n\n\n  /**\n   * Sets the transform properties based on the given affine transformation\n   * matrix and optional position.\n   *\n   * This function should set the transform based on an input matrix and\n   * (optionally) a starting position. Calling T.getMatrix() on the resulting\n   * transform should produce the input matrix `m`. Position should\n   * be the point where changes to rotation or scale will rotate and scale around.\n   * Meanings of position, rotation, scale, and anchor match those used in Adobe\n   * standards (e.g., After Effects). The corresponding matrix is calculated\n   * as shown in getMatrix() above: (P)*(R)*(S)*(-A). Position is specified as\n   * a constraint because the two translations in the above equation create a\n   * redundancy.\n   *\n   * We recommend familiarizing yourself with the available methods in\n   * `src/anigraph/amath/Mat3.ts`.\n   *\n   * Also familiarize yourself with the available functions in\n   * `src/anigraph/amath/Precision.ts`. These are useful when dealing with\n   * floating point inaccuracies and other small numbers.\n   *\n   * Note: do not let the scale factor be less than epsilon.\n   *\n   * @param m the affine transformation matrix\n   * @param position the starting positon\n   */\n  setWithMatrix(m:Mat3, position?:Vec2, useOldRotation?:boolean){\n    // throw new Error(\"setWithMatrix not implemented yet! Wait for assignment 2!\")\n\n    //TODO: Don't leave this in!\n    const ex = new Vec3(1,0,0);\n    const ey = new Vec3(0,1,0);\n\n    if(position !== undefined){\n      this.position = position;\n    }\n\n    if(!useOldRotation) {\n      const Mex = m.times(ex);\n      this.rotation = Math.atan2(Mex.y, Mex.x);\n    }\n\n    const noRo = Mat3.Rotation(-this.rotation).times(m);\n    const scaleX = noRo.times(ex);\n    const scaleY = noRo.times(ey);\n    this.scale = new Vec2(Precision.ClampAbsAboveEpsilon(scaleX.x), Precision.ClampAbsAboveEpsilon(scaleY.y));\n\n    var ORSinv = Mat3.Translation2D(this.position).times(\n        Mat3.Rotation(this.rotation).times(\n            Mat3.Scale2D(this.scale)\n        )\n    ).getInverse();\n\n    if(ORSinv===null){\n      throw new Error(`tried to set transform with matrix that has zero determinant: ${m}`);\n      return;\n    }\n    this.anchor = ORSinv.times(m).times(Vec3.From2DHPoint(new Vec2(0,0))).Point2D.times(-1);\n  }\n\n  NodeTransform3D(){\n    let rval = new NodeTransform3D(\n        new Vec3(this.position.x, this.position.y, 0),\n        Quaternion.FromAxisAngle(new Vec3(0,0,1),this.rotation),\n        new Vec3(this.scale.x, this.scale.y, 1),\n        new Vec3(this.anchor.x, this.anchor.y, 0)\n    );\n    return rval;\n  }\n\n  NodeTransform2D(){\n    return this;\n  }\n\n  assignTo(threejsMat: THREE.Matrix4) {\n    this.getMat4().assignTo(threejsMat);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}