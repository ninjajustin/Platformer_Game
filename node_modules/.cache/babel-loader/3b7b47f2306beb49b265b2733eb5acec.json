{"ast":null,"code":"var _dec, _class, _class2;\nimport { ANodeModel3D, ASerializable, AShaderModel, Color } from \"../../../../../anigraph\";\nimport { ABasicShaderModel } from \"../../../../../anigraph/rendering/shadermodels/ABasicShaderModel\";\nvar ParticleEvents;\n(function (ParticleEvents) {\n  ParticleEvents[\"PARTICLES_UPDATED\"] = \"PARTICLES_UPDATED\";\n})(ParticleEvents || (ParticleEvents = {}));\nexport let ExampleParticleSystemModel = (_dec = ASerializable(\"ExampleParticleSystemModel\"), _dec(_class = (_class2 = class ExampleParticleSystemModel extends ANodeModel3D {\n  /**\n   * Here we don't want to make particles AObjectState because we may update particles one at a time, which would\n   * cause listeners to update for every minor change. Instead, we will batch these updates by sending an update\n   * signal with `this.signalParticlesUpdated()` to anything that added a listener using `addParticlesListener`\n   */\n\n  constructor() {\n    super();\n    this.particles = void 0;\n    this.orbitRadius = 0.5;\n    this.orbitFrequency = 2;\n    this.zOffset = 0.1;\n    this.particles = [];\n    this.setMaterial(ExampleParticleSystemModel.ShaderModel.CreateMaterial());\n    this.material.setUniform(\"particleColor\", Color.FromRGBA(0.2, 1.0, 0.2, 0.5));\n  }\n  static async LoadShader() {\n    await AShaderModel.ShaderSourceLoaded(\"exampleparticle\");\n    ExampleParticleSystemModel.ShaderModel = await ABasicShaderModel.CreateModel(\"exampleparticle\");\n  }\n  addParticle(particle) {\n    this.particles.push(particle);\n  }\n\n  /**\n   *\n   * @param callback\n   * @param handle\n   * @param synchronous\n   * @returns {AStateCallbackSwitch}\n   */\n  addParticlesListener(callback, handle) {\n    let synchronous = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    return this.addEventListener(ParticleEvents.PARTICLES_UPDATED, callback, handle);\n  }\n  signalParticlesUpdated() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    this.signalEvent(ParticleEvents.PARTICLES_UPDATED, ...args);\n  }\n  timeUpdate(t) {\n    super.timeUpdate(t);\n    let phase = t * Math.PI * 2 * this.orbitFrequency;\n    for (let p = 0; p < this.particles.length; p++) {\n      let offset = p * Math.PI * 2 / this.particles.length;\n      this.particles[p].position.x = this.orbitRadius * Math.sin(offset + phase);\n      this.particles[p].position.y = this.orbitRadius * Math.cos(offset + phase);\n      this.particles[p].position.z = this.zOffset;\n    }\n    this.signalParticlesUpdated();\n  }\n}, _class2.ShaderModel = void 0, _class2)) || _class);","map":{"version":3,"names":["ANodeModel3D","ASerializable","AShaderModel","Color","ABasicShaderModel","ParticleEvents","ExampleParticleSystemModel","constructor","particles","orbitRadius","orbitFrequency","zOffset","setMaterial","ShaderModel","CreateMaterial","material","setUniform","FromRGBA","LoadShader","ShaderSourceLoaded","CreateModel","addParticle","particle","push","addParticlesListener","callback","handle","synchronous","addEventListener","PARTICLES_UPDATED","signalParticlesUpdated","args","signalEvent","timeUpdate","t","phase","Math","PI","p","length","offset","position","x","sin","y","cos","z"],"sources":["/Users/home/Desktop/College/Fall 2022/CS_4620/cs4620-final-project/src/app/main/Nodes/ExampleNodes/ExampleParticleSystemNode/ExampleParticleSystemModel.ts"],"sourcesContent":["import {ANodeModel3D, AObject, ASerializable, AShaderModel, Color,} from \"../../../../../anigraph\";\nimport {SphereParticle} from \"./SphereParticle\";\nimport {ABasicShaderModel} from \"../../../../../anigraph/rendering/shadermodels/ABasicShaderModel\";\n\nenum ParticleEvents {\n  PARTICLES_UPDATED = \"PARTICLES_UPDATED\"\n}\n\n@ASerializable(\"ExampleParticleSystemModel\")\nexport class ExampleParticleSystemModel extends ANodeModel3D {\n  static ShaderModel: ABasicShaderModel;\n  /**\n   * Here we don't want to make particles AObjectState because we may update particles one at a time, which would\n   * cause listeners to update for every minor change. Instead, we will batch these updates by sending an update\n   * signal with `this.signalParticlesUpdated()` to anything that added a listener using `addParticlesListener`\n   */\n  particles: SphereParticle[];\n  orbitRadius: number = 0.5;\n  orbitFrequency: number = 2;\n  zOffset: number = 0.1;\n\n  constructor() {\n    super();\n    this.particles = [];\n    this.setMaterial(ExampleParticleSystemModel.ShaderModel.CreateMaterial());\n    this.material.setUniform(\"particleColor\", Color.FromRGBA(0.2, 1.0, 0.2, 0.5));\n  }\n\n  static async LoadShader(...args: any[]) {\n    await AShaderModel.ShaderSourceLoaded(\"exampleparticle\");\n    ExampleParticleSystemModel.ShaderModel = await ABasicShaderModel.CreateModel(\"exampleparticle\")\n  }\n\n  addParticle(particle: SphereParticle) {\n    this.particles.push(particle);\n  }\n\n  /**\n   *\n   * @param callback\n   * @param handle\n   * @param synchronous\n   * @returns {AStateCallbackSwitch}\n   */\n  addParticlesListener(callback: (self: AObject) => void, handle?: string, synchronous: boolean = true,) {\n    return this.addEventListener(ParticleEvents.PARTICLES_UPDATED, callback, handle);\n  }\n\n  signalParticlesUpdated(...args: any[]) {\n    this.signalEvent(ParticleEvents.PARTICLES_UPDATED, ...args);\n  }\n\n  timeUpdate(t: number, ...args: any[]) {\n    super.timeUpdate(t);\n\n    let phase = t * Math.PI * 2 * this.orbitFrequency;\n    for (let p = 0; p < this.particles.length; p++) {\n      let offset = p * Math.PI * 2 / (this.particles.length);\n      this.particles[p].position.x = this.orbitRadius * Math.sin(offset + phase);\n      this.particles[p].position.y = this.orbitRadius * Math.cos(offset + phase);\n      this.particles[p].position.z = this.zOffset;\n    }\n\n    this.signalParticlesUpdated();\n  }\n\n}\n"],"mappings":";AAAA,SAAQA,YAAY,EAAWC,aAAa,EAAEC,YAAY,EAAEC,KAAK,QAAQ,yBAAyB;AAElG,SAAQC,iBAAiB,QAAO,kEAAkE;AAAC,IAE9FC,cAAc;AAAA,WAAdA,cAAc;EAAdA,cAAc;AAAA,GAAdA,cAAc,KAAdA,cAAc;AAInB,WACaC,0BAA0B,WADtCL,aAAa,CAAC,4BAA4B,CAAC,2BAA5C,MACaK,0BAA0B,SAASN,YAAY,CAAC;EAE3D;AACF;AACA;AACA;AACA;;EAMEO,WAAW,GAAG;IACZ,KAAK,EAAE;IAAC,KANVC,SAAS;IAAA,KACTC,WAAW,GAAW,GAAG;IAAA,KACzBC,cAAc,GAAW,CAAC;IAAA,KAC1BC,OAAO,GAAW,GAAG;IAInB,IAAI,CAACH,SAAS,GAAG,EAAE;IACnB,IAAI,CAACI,WAAW,CAACN,0BAA0B,CAACO,WAAW,CAACC,cAAc,EAAE,CAAC;IACzE,IAAI,CAACC,QAAQ,CAACC,UAAU,CAAC,eAAe,EAAEb,KAAK,CAACc,QAAQ,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;EAC/E;EAEA,aAAaC,UAAU,GAAiB;IACtC,MAAMhB,YAAY,CAACiB,kBAAkB,CAAC,iBAAiB,CAAC;IACxDb,0BAA0B,CAACO,WAAW,GAAG,MAAMT,iBAAiB,CAACgB,WAAW,CAAC,iBAAiB,CAAC;EACjG;EAEAC,WAAW,CAACC,QAAwB,EAAE;IACpC,IAAI,CAACd,SAAS,CAACe,IAAI,CAACD,QAAQ,CAAC;EAC/B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEE,oBAAoB,CAACC,QAAiC,EAAEC,MAAe,EAAgC;IAAA,IAA9BC,WAAoB,uEAAG,IAAI;IAClG,OAAO,IAAI,CAACC,gBAAgB,CAACvB,cAAc,CAACwB,iBAAiB,EAAEJ,QAAQ,EAAEC,MAAM,CAAC;EAClF;EAEAI,sBAAsB,GAAiB;IAAA,kCAAbC,IAAI;MAAJA,IAAI;IAAA;IAC5B,IAAI,CAACC,WAAW,CAAC3B,cAAc,CAACwB,iBAAiB,EAAE,GAAGE,IAAI,CAAC;EAC7D;EAEAE,UAAU,CAACC,CAAS,EAAkB;IACpC,KAAK,CAACD,UAAU,CAACC,CAAC,CAAC;IAEnB,IAAIC,KAAK,GAAGD,CAAC,GAAGE,IAAI,CAACC,EAAE,GAAG,CAAC,GAAG,IAAI,CAAC3B,cAAc;IACjD,KAAK,IAAI4B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAAC9B,SAAS,CAAC+B,MAAM,EAAED,CAAC,EAAE,EAAE;MAC9C,IAAIE,MAAM,GAAGF,CAAC,GAAGF,IAAI,CAACC,EAAE,GAAG,CAAC,GAAI,IAAI,CAAC7B,SAAS,CAAC+B,MAAO;MACtD,IAAI,CAAC/B,SAAS,CAAC8B,CAAC,CAAC,CAACG,QAAQ,CAACC,CAAC,GAAG,IAAI,CAACjC,WAAW,GAAG2B,IAAI,CAACO,GAAG,CAACH,MAAM,GAAGL,KAAK,CAAC;MAC1E,IAAI,CAAC3B,SAAS,CAAC8B,CAAC,CAAC,CAACG,QAAQ,CAACG,CAAC,GAAG,IAAI,CAACnC,WAAW,GAAG2B,IAAI,CAACS,GAAG,CAACL,MAAM,GAAGL,KAAK,CAAC;MAC1E,IAAI,CAAC3B,SAAS,CAAC8B,CAAC,CAAC,CAACG,QAAQ,CAACK,CAAC,GAAG,IAAI,CAACnC,OAAO;IAC7C;IAEA,IAAI,CAACmB,sBAAsB,EAAE;EAC/B;AAEF,CAAC,UAxDQjB,WAAW"},"metadata":{},"sourceType":"module"}